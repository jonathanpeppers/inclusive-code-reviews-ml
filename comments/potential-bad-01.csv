Body
"As I briefly mentioned in chat before the holidays - this _can_ be localized, but it will _hyperexplode_ the unittets. In my opinion, we should probably not hyperexplode the unittests. The solution to the unittests problem appears to be ""rewrite the entire thing"", but I need to do a bunch more investigation of WTF is going on there. I think the right path here is to do this non-localized for now, and file a follow up for adding localization to them. That way, we won't need to include a massive ""rewrite the unittests"" change as a part of this already hefty PR. Thoughts?"
"Okay, the Terrible solution I have is to have a `.../CommandlineArgs/Resources/en-us/Resources.resw`, and include it manually in each of TSE and `TerminalApp`. That'll get the resources added to the correct libraries, so `RS_A` will still work, regardless of which dll it's being called from. 

@github Will that still work for localization? "
Oh crap. I think I messed up the commits. Well this is indeed a lengthy thread. In fact I think this is most commented PR I've ever made on Github. I'll force push later.
"@github any specific preference to the preferred sort, or just sort via StringComparer.Ordinal or something?

Oddly the current comparer for the hashset-based comparer is PathComparer, which does a bunch of extra comparisons around relative pathing and such to attempt to ""normalize"" the path. I was going to just switch this over to an ImmutableSortedSet but PathComparer doesn't implement that (since it would seem insane to do so)."
"So this is a good point.  For clarity, whatever newline sequence you wrote, we will embed into your converted string.  This means from the language/compiler perspective, on that machine, the literal has the exact meaning as before (no semantics change).

Where it gets subtle though is the absolutely insane behavior of git where it may take a file and just change newlines *even that are language relevant* when sent to *another* machine.

In this case, the refactoring is in line with the lang and compiler.  However, it is *git* that ends up causing issues here as it thinks it is sensible to touch programming lines that relate to content.

--

Note that this is a refactoring though.  It is opted into the user, presumably because they actually think this is better.  And it will be very clear that a single line became multi-line.  So i think the user can be trusted to decide if that is acceptable for them given their git config."
"WTF are ""reverse forwarders""??
"
"@github @github Is the stream context completing the transport output like this a terrible hack or an elegant solution? IDK ðŸ¤· "
"> Crap, before this will work we need to update the spa-templates submodule to reference the dotnet7 feed & ingest it. I'll update that repo now.

Presumably we also need to back-port this into release/6.0 as runtime's 6.0 contains the updated transport package."
"âž¡ï¸ In the total absence of enforcement to date, we did a terrible job making sure tests clean up after themselves. I fixed enough cases in #25558 to make sure this change is viable, but I expect to see this condition hit in practice. Earlier portions of the cleanup code guarantee that all synchronous and immediately-queued cancellation requests are processed before reaching this condition. **All cases where this is hit are a bug.** However, the condition relaxes the overall acceptance criteria for this large change and allows us to pay off the debt over time."
"What happens when you have two text editors open to settings.json? Best case scenario, one tells you ""this file changed. want to reload it?"".

This is a case of ""play stupid games, win stupid prizes""."
"Not nearly as bad as enabling NRT for the first time. The `default` constraint is the only place I had trouble. We desperately need a code fix for this particular error or we're going to be fielding a ton of ""WTF"" questions."
"I concur - almost seems like we should have `ProfileSettingContainer : SettingContainer` that allows for reverting to the parent, but only for settings in profiles.

All this is terrible, but let's not pretend our settings model was designed for a GUI."
Ohhhhhhhhhh.  I'm an idiot.  we can use the return value to figure this out.  tnx.
these diffs are terrible.  I'm not srue why it threw it off so much to indent.  working on this.
"@github Can you add a comment stating the intent then? I could totally imagine somebody coming by, saying ""heh, that's stupid it's not sorted"", and adding in the exact thing you're removing.

(bonus points for having some sort of visible grouping so it's clear to users too.)"
"> Possibly a stupid question, but why rewrite this?

Short-circuiting binary operators imply a control flow. For example, if ```a``` in ```a || b``` is true, we jump over evaluation of ```b```. This should be explicitly reflected in the graph through links. See LogicalOrFlow_01 unit-test in IOperationTests_IBinaryOperatorExpression.cs.

---
In reply to: [162218816](https://github.com/dotnet/roslyn/pull/24263#discussion_r162218816) [](ancestors = 162218816)"
"I was going to suggest using `Task.WhenAll` to avoid the long declaration of `originalNodes` then I realized `GetDeclarationAsync` has side-effects. Maybe just call it something like `AddInlineWithVarEditsAsync` to make it more clear what it actually does? Sorry, I'm terrible at naming things, but I'm sure you know I'm saying :)"
"We use it to let the solution crawler back off. We have logic to back of if we are editing our files (to avoid us causing lots of GC for example), but if say you're editing a Readme file or something else we don't want to be making that terrible."
"> In order to diagnose it, I used hardcoded DebugBreak() since even ImageFileExecutionOptions didn't like running against conhost - is there are better way to debug and test these cases without being so invasive on the system?

Not really, no. `Conhost` is gross to debug.

"
"> the `ApplicationContext` which is embeded in the native ALC - and yes - that name is TERRIBLE and has to go

The `ApplicationContext` which also contains an `ExecutionContext` which is a subclass of  `LoadContext`! So much context."
"This may be out of scope for this but the old (and new) behavior seem. wrong to me.
Let say the kernel was built without IPv6 support (or v4 in distant future). The file would be missing and we would always throw even if there is nothing wrong.

In many cases like this it feels it would be better to return empty collection. Since the networking grabs massive amount of information had several cases in the past when we thrown on stupid things even if the caller really does not care.  "
"Holy crap, I saw this issue weeks ago and didn't expect this one to ever get fixed."
"> ""Wouldn't be surprised if other components in the ecosystem exhibited the same problem.""

I agree this is very likely not the only one, it's just one that keeps popping up quite often. It's been a pain point for years (first on WPF, then on UWP, now on both MAUI and WinUI 3, etc.), and something that has received countless feature requests for. The solution many have come up with is to just roll their own collection types with support for ""range operations"", with the big drawback being though that since no UI framework among these actually supports the API, they're just forced to either iterate over items one by one (which is just terrible for performance), or just reset the collection and reinitialize it (which is also bad for performance, maybe just a little bit less, and also completely breaks all animations). It's just a very unfortunate situation where customers get frustrated, and they often have to both do extra work to build these helpers, and then still end up with a suboptimal experience. I mean, we have the same exact custom collection type in the Microsoft Store too, and it has the same exact issues (and I hate it). It's just a really common issue, and I'm saying I'd love for us to find the time to coordinate with the right folks and maybe try to finally get this resolved at least for .NET 8 ðŸ™‚

I've also received multiple requests to add such a custom collection type in the .NET Community Toolkit, and I've had to reject them for the reasons mentioned above (it still results in a very bad experience, and I'd much rather just fix this properly in the BCL). The net result though is that at least for now, the API is not there and plenty of folks are frustrated.

> ""but my recollection is that it broke in a substantial way as soon as runtime merged this change originally.""

I find that surprising and I'd love to learn more about that. Even with the new APIs, as long as nobody actually calls them, there should be no functional differences in the way the currently existing APIs work at all. So I'm not sure I understand what broke. Are you sure it wasn't just folks trying out the _new_ APIs, and then reporting WPF crashing/breaking in that scenario? ðŸ¤”

> ""Would doing that be a less disruptive way for newer frameworks to get range support?""

I personally don't think that'd be the correct solution for this issue, for a number of reasons:

- The core issue is that right now, the various UI frameworks don't support multiple collection updates. Where they come from is not what's causing the issue. That is, even with a new collection type, you'd get the same exact crashes until the frameworks were updated to handle the args. And if they were updated, then there would be no reason to have a separate collection type in the first place, as it'd just be the same exact one but with two new APIs. Those should just be added on what we have.
- It'd make updating codebases much more tedious, as now you'd have to swap the whole collection type in all locations rather than just being able to opt-in into a range update whenever necessary.
- I'd argue it'd be an abstraction leak. You want an observable collection, the fact that some callsites would need to perform range operations on that is just an implementation detail of your viewmodels. You shouldn't need to use a completely different collection type just to support this.

I would really love for us to just manage to coordinate across the various teams and officially add support for this in a future release, not sooner than .NET 8 at this point. We could both update all underlying frameworks to support this (which I realize is non trivial work, especially since eg. WinUI 3 would likely need some new WinRT APIs and projections for this), and then provide the necessary migration docs, if needed. I believe this would be the best long term solution for this issue ðŸ™‚"
"I initially went along with this, but when usability testing it locally I remembered why I had done it this way in the first place.

Basically I'm using exceptions to show the users their error messages, so it really ought to be more user friendly then your actual problem being buried in amongst an Aggregate exception format and a bunch of stack-trace stuff. This all stems from me using exceptions to bail out of functions early when we find argument problems (url is null, doesn't exist) so I don't have to make every method return `Result<T>` where Result could have an error that should cause us to bail early or the value we actually asked for. If you can think of a better paradigm than using exceptions of that gross Result<T> stuff I'm on board, because I agree that using exceptions this way isn't great, it's just the best I could come up with."
"oh right. Stupid API doesn't do what I want. :grumble:
"
"I was just testing the cmd defaults and one was enough there, but if there are shells that need 2 or 3 then maybe this is a good idea.  It's a trade-off of size for every scenario vs. speed for some scenarios.

With my change, each TextAttributeRun is 20 bytes, so given there are 9001 of these created in the default cmd scenario, each increase by 1 in this small_vector costs ~176KB, which seems like enough we should think carefully about what to tune for, but not so much that bumping to 2 or 3 is terrible.

Is there any data on how often different shells are used so we could try to tune for the most common ones?"
"I have a terrible workaround for the symlinking issue, which (unlike the compression option) is consistent with our symbol publishing :)

Technically, iOS-style unversioned frameworks are valid on macOS, so... flatten the framework post-creation. That should fix the Catalyst build"
the previously display text was just terrible.
"As a sentinel, if we decide that `OutputCellIterator` is globally stupid for making the caller maintain the walk-count... (which it is... in my opinion...) we can globally change it at some point by finding all affected areas.

I know I don't need to convince you any more, just giving more clarity on my thoughts."
"Sorry for the noob question: does `""T""` and `""x""` stand for ""Type"" and ""Value"" respectively? I'm trying to understand a little bit of the code by checking some PR's (yours is pretty cool!)"
"> For this we could switch to an immutable wrapper around Dictionary<TKey, TValue>, similar to how we use ImmutableArray<T> instead of ImmutableList<T>.

My gut tells me this should be a slam dunk win.  The vast majority (probably nearly all) of cases where we use ImmutableDict, it's not to benefit from what ID is decent at, but just to ensure it will not be mutated post creation.  For that purpose it's actually a pretty terrible choice and adds a tremendous amount of overhead for functionality that we're not needing in those scenarios."
cref? This might also be a nice place to use the list syntax @github was doing since this will format like crap in Quick Info otherwise.
"Should the test that the value shouldn't change just live in the compiler?

If nothing, I wonder if this deserves a good comment in the code. If I saw this I'd go ""WTF"" and just delete it without a second thought."
"This has me thinking about how we possibly do this for the DxRenderer.

I imagine that we will either have to...
1. Form all this data into an alternate stream that looks like a TTF/OTF font instead of this old Windows Font format that GDI seems to understand on `AddFontMemoryResourceEx` and then feed it into [IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference](https://docs.microsoft.com/windows/win32/api/dwrite_3/nn-dwrite_3-idwriteinmemoryfontfileloader) per the documentation at [Custom Font Sets](https://docs.microsoft.com/windows/win32/directwrite/custom-font-sets-win10#creating-a-custom-font-set-using-font-data-loaded-into-memory).
2. Make the DxRenderer load this HFONT into a GDI HDC and then call [IDWriteGdiInterop::CreateFontFaceFromHdc](https://docs.microsoft.com/windows/win32/api/dwrite/nf-dwrite-idwritegdiinterop-createfontfacefromhdc) and use the resulting `IDWriteFontFace` normally.

I bet the second one is easier but is a little gross for using GDI inside the DX renderer. The first one is probably difficult because I think TTF/OTF always specifies fonts as vector outlines, so I'm not sure how we'd live-specify these. Probably a lot more math...

Just ideas. "
"I agree with Dustin on this one. I'd reckon that most [questions](https://github.com/microsoft/terminal/issues?q=is%3Aissue+label%3AIssue-Question) actually start out as ""bug report""s that stem from a misunderstanding or generally not reading the docs. 

It's not a terrible lot of work to swap out the tags. I know that I personally reserve the Bug tag for when I'm fairly confident something actually is a bug and either needs more investigation or is generally on the backlog somewhere. I suppose that's really `Needs-Triage`'s job. "
yes.  that name was terrible. changed to `preferredMap`.
"> Performance at the full solution goes from:

You'll get at least 60 seconds gain my moving from MSBuildWorkspace to direct creation of compilations from csc invocations in the binlog. MSBuildWorkspace is extremely terrible for end-to-end performance because there is no parallelism in the MSBuild evaluation.

csc invocations have a secondary benefit of improved accuracy."
"note: IDE pattern is to name these MyCodeAction in almost all cases.  That said, that name is pretty terrible.  So if you want to keep the name like this, i'm ok with that."
"I tend to agree that these are truly special casesâ€”since the relationship between `for`/`htmlFor` and `class`/`className` comes from the mapping between HTML attributes and DOM element property names, the spelling similarity is not a coincidence, but itâ€™s not a given either. You can imagine a world where the DOM spec decided to map the `for` HTML attribute onto `HTMLLabelElement['targetInputId']`, or the `class` HTML attribute onto `Element['cascadingStyleSheetClassName']`. Both of these would be terrible APIs, but my point is that despite the fairly small string distance between these substitutions, the string distance is not the reason they should be offered. So Iâ€™m unconvinced that they merit a change to the string distance algorithm."
"Sorry, the part that I originally found ""gross"" was that this call was ever in the `if` in the first place, not your changes; now that you've moved the parameter out though, it's at least a lot cleaner.
"
"`Assert.Equal` does an IEnumerable-based comparison. The performance of this is terrible for large buffers. So terrible that it was dominating the total time of test runs in the stream conformance tests.

`AssertExtensions.SequenceEqual` does a span-based comparison, which is much much faster. Like 20x or more. 

`AssertExtensions.SequenceEqual` also has some logic around reporting differences that's kind of nice, but that's secondary to the performance issue.

We should always use `AssertExtensions.SequenceEqual` for comparing buffers. `Assert.Equal` is fine for non-buffers."
"@github oh my you're right, I feel so stupid! Thanks"
"To my knowledge the spec is not generated when you add the packages we add, so I think @github is right that we should reduce the timeout. I made it 5 seconds, which is still probably more than is needed, but not by an insane amount if you account for slow machines."
"This is stupid, everyone knows what whitelist means, and ignorableAssemblyList means nothing on the first read."
"> 
> 
> This is very clever, and I like it. It looks like it won't harm performance, but I do think that some caution is called-for around all the thread hopping.
> 
> @github: thanks for always cutting through our layers of crap (both organizationally and code-wise) and _getting good shit done_ ðŸ˜„

Thanks! I want to be super cautious here - as the potential damage is... nice -  and  I am absolutely not in hurry to commit this one before we are fully confident! Just want to make sure we keep working on it - as it gets bigger and I am quite senile :blush:

I any case I found another concerning case:
* Assume we search backwards for some word, such that the matches are in lines 10, 20, 30:
* In this case we find the match at line 30
* Then assume the user scrolls up and selects a text in line 15. Then the user clicks ""search previous""
* We  will select the match at line 20 (because our state suggests to move from `3/3` to `2/3`), though probably the user expected to get the match in line 10 (at least VSCode in this case selects line 10 and puts the state at `1/3`)."
"Yeah it's not fun to hook this up. Not terrible, but not fun."
"Please add a comment here explaining this type lives in the VS side of things and exists to be the proxy. It makes sense to me since we have chatted about it, but @github can attest to having to debug through other frameworks where there was no documentation on what lived in what process and it drove him insane.
"
"Oh, that makes it terrible
`text%2Fplain%3B+charset%3DUTF-8`"
Terrible ðŸ˜. At least have a bool or enum property.
"It's grabbing it off of the getter.  The assumption being that the getter is normally before the setter.  Here it's suboptimal, but not terrible.  We can consider trying to do better in the cases where the getter is after the setter.  But i just wanted to ensure we weren't totally breaking code by removing preprocessor directives as the highest order thing to fix."
"(oh, i'm also an idiot since i read this as `Open Brace` not `Open Bracket`.  But the above points still stand)."
"> How does GetDiagnosticsUpdatedEventArgs work exactly?

You can think of the IDiagnosticsService as a mapping from special ""keys"" to the set of diagnostics for those keys.  This method name is actually *terrible* as these aren't really events or args.  They're really just saying ""what are all the keys we know about for this particular set of args"".  In this case, we're asking for all the keys associated with a particular document.  We can then use those keys to actually find out all the diagnostics for that doc.

You could imagine this exposed behind a helper method (which is what i think i will do :))."
"Thanks for the notice & discussion! TIL ðŸ˜„ , and it makes a lot of sense.

This actually ended up not changing much in the output: 107e10d908 only showed a few _very_ edge case tests get a small amount of extra messages. Not so terrible. Phew."
"Stupid question - won't some of the changes by overwritten by arcade in some point in time - I don't know the flow of those, but I see some files are the same and looking at history they are updated?"
"> Ping @github - let me know if you disagree with the justification.

I don't like it.  I think we should not do this if we can't move the whole feature over (analyzer and diagnostic).  I worry that we'll just end up with crap left behind that we never get to.  But not moving this at all, it highly motivates solving this in an appropriate manner."
"**This is a warning**.

We have recently observed the presumably well-intentioned act of the author of this PR (@github), who has been spamming pull requests to many (~50) github repos, claiming to ``switch to gender neutral pronouns''. In reality, the bot performs a dictionary replace of gendered nouns and pronouns, and the outcome is questionable at best, and literally harmful at worst. See:
- The bot did a terrible job at replacing these words - [EbookFoundation/free-programming-books#6801](https://github.com/EbookFoundation/free-programming-books/pull/6801/commits/5257301642c173e2dc4f034f8c0460ce7ea99de6)
- The code fails to compile at [rust-lang/rust#95508](https://github.com/rust-lang/rust/pull/95508)
- The bot ignores all context whatsoever at [moby/moby#43441](https://github.com/moby/moby/pull/43441)
- After initial PR being closed, the bot keeps sending PRs, effectly spamming the repos. For example, these 5 PRs were sent to the same repo within 2 days [#1](https://github.com/EbookFoundation/free-programming-books/pull/6801) [#2](https://github.com/EbookFoundation/free-programming-books/pull/6803) [#3](https://github.com/EbookFoundation/free-programming-books/pull/6804) [#4](https://github.com/EbookFoundation/free-programming-books/pull/6805) [#5](https://github.com/EbookFoundation/free-programming-books/pull/6806)

We have reviewed the changes in this PR. Most of the changed words are ""accidental gender pronouns"" - `he` as a prefix of `hello`, or `his` as a suffix of `this`, and both examples come from test cases where inline comments are used to split words (like `t/**/his`), and the PR wants to change them into `t/**/theirs` etc.. These changes are obviously not helpful at all.

To save more time for the open-source community, we recommend the maintainers of this repo to close this PR and ban this bot from further spamming."
"> Many workloads for which tasks were originally introduced, actually. Consider, for example, parallelized divide and conquer. A worker partitions its work into multiple pieces, queues identical workers to process N - 1 of those pieces, processes its own, and then waits for those other workers to complete. Also think about algorithms that require coordination between those pieces, such as various operations used by PLINQ (e.g. OrderBy) that needs to block each of the workers until they reach a common point so that they can exchange data and all continue on, and what would happen if one of the workers was throttled indefinitely

Today do the implementation of those kick end up doing Task.Wait?

> I think that's the wrong direction, at least for the foreseeable future. If we decided to go with an approach like the one proposed in this draft, I have trouble seeing it as anything other than opt-in, given all of the previously cited concerns, the potential for introducing deadlocks where they weren't previously, the potential for casting way too wide a net, the potential for negatively impacting the throughput of unrelated workloads, etc. _If such a mitigation was added as opt-in, and if enough testing demonstrated it was a good decision for certain workloads, then it could potentially be automatically opted-in for those, e.g. if you felt ASP.NET should always turn this on. Even there, though, I'd be surprised if in the current configuration that was a wise choice.

Yes I have similar fears but I'm looking for solutions. Maybe this isn't this one but there are aspects of this that seem interesting. Say we added a public API to enable this and it was opt-in, I could see the potential for adding a piece of middleware or filters that enables this on the current workitem before the blocking code executed. Something like this:

```C#
[HttpGet(""/blocking"")]
[EnableBlockingMitigation] // This name is terrible
public string BlockingLegacyCodez()
{
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

That filter could yield to thread pool to get off the current work item and enable mitigation on a unique workitem that's closer to this code. The equivalent of doing this:

```C#
[HttpGet(""/blocking"")]
public async Task<string> BlockingLegacyCodez()
{
      await Task.Yield(); // Make a new work item
      ThreadPool.EnableBlockingWorkitem();
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

Thoughts?"
Shouldn't this be done in the other ctor? Also how do you feel about passing in an `ILogger` \ `ILoggerFactory` instead to the ctor? This feels a little gross.
"If `Bottom` and `Top` are both `SHORT`, then can't this technically cast into something gross when it's returned as `unsigned int`?"
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"@github Those are the default settings for insane (just copied over so I could add a few more attributes). The allowed tags are separate from the allowed attributes. The current setting just says: if we allow iframes (which we don't) here are the allowed attributes for them. We can remove the line since it has no effect

 @github I'm good with removing `marked.sanitize`. The setting is deprecated and has known issues, which is why we added `insane`.

My concern is just that allowing CSS brings up a number of other considerations:

- Which css rules do we allow? Do we try sanitizing the css? If we do have a whitelist of allowed css, how do we handle feature requests to support additional properties?

- Do we want extensions to control the styling insides hovers at all? Right now we control the presentation and can try our best to make sure the hovers look ok with all themes 

- Enabling css expands the potential attack surface. If someone finds an exploit in Chromium related to CSS, it could potentially now effect VS Code too.

My feeling is that we should think through this problem more and find some other potential use cases. Issues labels seem like a very specific use case"
"wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
[sceen](http://joxi.ru/EA4Rw3xHXyZbWm)"
"> That might just be a case of ""play stupid games, win stupid prizes"".

That is how I am thinking of this feature. There are cases where the compiler can definitely determine if the user is doing something wrong, but also where it _might_ be doing something wrong. The [`Span<T>.ToArray()`](https://docs.microsoft.com/dotnet/api/system.span-1.toarray) is another example. If a user calls `ToArray()` and `T` is known to be ByRefLike, the compiler could issue a failure. However, if `T` isn't know at compile time then it would be up to the implementer to have handled this appropriately using something like the proposed intrinsi-fication of `typeof(T.).IsByRefLike` in this document. The updated `Span<T>.ToArray()` would look as follows and handle the case at runtime. The other APIs in question would have similar checks.

```diff
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public T[] ToArray()
{
+    if (typeof(T).IsByRefLike)
+        throw new InvalidProgramException();

    if (_length == 0)
        return Array.Empty<T>();

    var destination = new T[_length];
    Buffer.Memmove(ref MemoryMarshal.GetArrayDataReference(destination), ref _pointer.Value, (uint)_length);
    return destination;
}
```"
"Do we have an issue somewhere to clean this up? Throwing inside dispose isn't a nice thing to do, especially when you have inheritance involved. There are a bunch of places in this PR that will leak stuff on failed dispose ðŸ˜† 

I realize that you didn't make it worse in this PR, but it is gross so I want to make sure it's on someone's plate to fix. "
"Crap - the tree from the quarantined test jobs does appear to have https://github.com/dotnet/aspnetcore/commit/76fbd1a2831ae0d8c73afd2f3c7d8c531223a8b8, but doesn't produce binlogs. I'll see if I can find another public build since my commit that has the failures"
"this feels like a terrible nit, but all the other options are `--twoDashes` style, so this should probably be `--embedding`, right? 

(except `-ForceV1` which maybe raises more questions - maybe predates the other args)"
"Noob question ðŸ˜…Does `[iOS (13,0)]` not mean anything 13+? Then are there two Exports for the same selector? How does it get resolved?"
"Hmm, yeah, I can see how those types are a disaster in a structural comparison. For example, to structurally compare two `List<T>` instantiations, we fan out to an insane number of comparisons between instantiations of the same generic types for different type parameters, which again fans out more, etc. The cycles are very long and apparently don't get to a depth of five before we run out of memory. I stopped it in the debugger and observed a relation stack 70 levels deep that still wasn't considered deeply nested. Tough one!"
"@github @github @github Ok, I am using the SharedFramework SDK to make a new `Microsoft.NETCore.App.Runtime.Mono.<RID>.Sdk` nuget - it seems to be working at least for `iossimulator-x64`.

There are some gross cmake hacks in here, too, because I don't really know cmake.

Could you take a look at what's here so far.

Next steps: update the workload manifest to use all these new nugets.  Figure out some way to test this. 

(I tested that the msbuild target works by copy-pasting to a dummy project and setting the appropriate props and looking that the properties are getting set to reasonable-looking values.)"
"Forgive me if it's a stupid question, but what's the point of adding an empty object as a value if we are only checking ContainsKey? Can't we set the value to null and get rid of the readonly property?"
"Yeah but that looks gross if I have to do it like this 
```
private static byte[] LookupTable => new byte[] {
    (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
    (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
    (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E',
    (byte)'F',
};
```"
"You're nullable disabling/enabling around the closing brace?

Regardless, yes, it's possible for someone to implement Fail in a way that still returns, but that goes against the purpose of the method.  If we held true to the possibility that someone did that, then we'd need to remove `[DoesNotReturnIf(false)]` from Debug.Assert and all such methods, which would be terrible. #Resolved"
This is a really confusing way to declare flyout... I mean I get what it does but holy crap did it hurt my head for a second. Can you please flip this if statement around even though it will increase nesting.
edit: I am stupid
"Part of the *intention* -- and *maybe* unnecessary? -- was that we'd only emit the `brew install` commands for applications which are not present.

This check can be done for `@(RequiredProgram)`, but not for `@(RequiredPackage)`: how do you check that the package is already installed?  Â¯\_(ãƒ„)_/Â¯

Then again, I'm not sure if this will be an *actual* problem in practice.

I have similar fears about `%(HomebrewTap)`: what happens if the same `brew tap` command is executed multiple times?

In my case, it errors, but it doesn't *error* (?!):

```bash
# I already previously ran `brew tap grendello/xawindeps`

$ brew tap grendello/xawindeps
Updating Homebrew...
==> Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==> Updated Formulae
container-diff               fwup                         gradle-completion            kibana                       logstash                     opa                          pgroonga                     postgresql@9.4               pushpin                      unrar                        wtf
file-formula                 git-quick-stats              groonga                      libmagic                     nexus                        osquery                      picat                        profanity                    rocksdb                      weaver

Error: Could not link:
/Users/jon/Dropbox/share/man/man1/brew-cask.1
/Users/jon/Dropbox/share/man/man1/brew.1

Please delete these paths and run `brew update`.
$ echo $?
0
```

I'm not even sure what to make of this state of affairs. :-/

Fortunately, reinstalling a package is a no-op:

```bash
# I previously ran `brew install grendello/xawindeps/mingw-zlib`
$ brew install grendello/xawindeps/mingw-zlib
Warning: grendello/xawindeps/mingw-zlib 1.2.11 is already installed and up-to-date
To reinstall 1.2.11, run `brew reinstall mingw-zlib`
$ echo $?
0
```"
I'm not sure using this `<PackageReference/>` will work? `xabuild` is this terrible thing that references `MSBuild.exe` directly.
"It doesn't report L3 on 12 core eMAG I have access to, Trust me, Windows team is aware and helping us here ;-)

> Can we not do something like the following?

No, only when we find a reliable mechanism to detect LLC or switch to something else to calculate Gen0 size. Till then we should not trust whatever API gives us or we might stuck with 256Kb Last-Level-Cache on a 30 core machine and hit a terrible penalty on GC-intensive workloads.

Small/Destkop class hardware should not be hurt with this intrinsic, for e.g. 8 cores it picks 1Mb cache (leading to 1.8Mb gen0 size) and for single/dual-cores it's around 480Kb for Gen0."
"Yes, though it took me a while to walk through this all (it's unpleasant that there's no grammar we can just look at at this point).  

Here's the chain of productions through which we can see the 'GeneratorParameter' being passed down:

```
GeneratorDeclaration[Yield, Default] :
  function * BindingIdentifier[?Yield] ( FormalParameters[Yield,GeneratorParameter] ) { GeneratorBody[Yield] }
  ... elided ...

// FormalParameters[yield,generateparameter] leads to:
FormalParameter[Yield,GeneratorParameter] :
  BindingElement[?Yield, ?GeneratorParameter]

BindingElement[Yield, GeneratorParameter ] : See 13.2.3
  ... elided ...
  [+GeneratorParameter] BindingPattern[?Yield,GeneratorParameter] Initializer[In]opt

BindingPattern[Yield,GeneratorParameter] :
  ObjectBindingPattern[?Yield,?GeneratorParameter]
  ... elided ...

ObjectBindingPattern[Yield,GeneratorParameter] :
  ... elided ...
  { BindingPropertyList[?Yield,?GeneratorParameter] }

BindingPropertyList[Yield,GeneratorParameter] :
  BindingProperty[?Yield, ?GeneratorParameter]
  ... elided ...

BindingProperty[Yield,GeneratorParameter] :
  ... elided ...
  PropertyName[?Yield, ?GeneratorParameter] : BindingElement[?Yield, ?GeneratorParameter]

PropertyName[Yield,GeneratorParameter] :
   LiteralPropertyName
   [+GeneratorParameter] ComputedPropertyName
   [~GeneratorParameter] ComputedPropertyName[?Yield]
```

So, if you have:

```
function * foo({ [x] : ..., [y] : ... }) {
}
```

Then 'generator parameter' is used ot indicate you're creating the parameters for hte generator.  And eventually that flag bubbles down to when you're doing the computed properties.  And, within those computed properties, yield is apparently disabled.  Meaning you can't use a yield expression inside a computed property name (which is not a terrible thing IMO).

(Hopefully i'm reading that right).

Now, oddly enough, outside of a generator parameter, i think it would be legal to use 'yield'.  so if you had:

```
function * f() {
   var v = { [yield 1] : 1 }
}
```

Then that would be fine.  'generator-parameter' is the context flag that enables us to flag this down.
"
"> I don't like it. I think we should not do this if we can't move the whole feature over (analyzer and diagnostic). I worry that we'll just end up with crap left behind that we never get to. But not moving this at all, it highly motivates solving this in an appropriate manner.

From an end-user perspective, this will make no difference at all. They just need the analyzer on CI, and code fix in IDE (regardless of whether it is invoked from a NuGet package or from an implementation in IDE). My point is, do we think it is worth blocking a user feature (CI enforcement) on just the fact that we'd like to cleanup and port the fixer to NuGet package?"
"> We are making the string marshaller types public, so the innovation that can be applied to them will be fairly limited.

I'd hope we have some latitude here, but your point is fair. I don't think this argument moves me much though.

> One of my motivations for doing this is to reduce the engineering dept in NativeAOT. The built-in system in NativeAOT is using different set of helpers for interop. I wanted to use this as an opportunity to get everything on the same plan.

Ugh. Well crap... this does change my perspective. I agree reconciling all of them would be a win. I will say the new entry points do seem to clutter the implementation and make something that is nicely standalone and easy to reason about more complicated. I guess I'm going to have to review this in detail. I think this is worth exploring."
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"These relations are insane! Everything looks good to me though! Perhaps remove the newline before the curly braces when starting interfaces though for style, but your call!"
"> wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
> [sceen](http://joxi.ru/EA4Rw3xHXyZbWm)

sorry, wrong autocomplete from github."
"@github Sure enough if there's people enthusiastic about it! It's not trivial to rebase it, but it's not completely terrible either. I might be a bit busy during the start of this week but might have time in latter half. Feel free to message me here and push me forward again If I don't write an update here during this week. :-)"
"This is kinda gross. This namespace doesn't exist in Ignitor, but I could make an empty one if that's cleaner?"
Oh crap! I thought about that when I started to write the tests and then I forgot about it!
"@github 
Yea stupid me, forgot to check in the added file.  Its up now.  I moved it because it is now used in three places TimePicker, DatePicker, & Entry.  The reality is, it will most likely need to be used in more places.  Check that out again and if you want to move the BoolEventArgs somewhere else, like a separate file then we can do that."
"## TODO for this PR
- [x] Update IDL with `Has...` functions
- [x] Runtime error when `_globals->CreateChild()` is being assigned (only when loading settings.json, fine otherwise)
- [x] Update spec and propagate changes from spec
- [x] Profile has a few settings we handle manually (i.e. BI alignment). I need to hook those up properly too
- [x] ~(Bonus Points) _maybe_ make these settings observable (we'll need that soon anyways)~ Nope

(new items!)
- [x] Fix `startingDirectory` being null
- [x] Fix tests
- [x] merge master (new Profile setting)
- [x] (after #7877 merges) address ""TODO CARLOS"", copy commands/keybindings/schemes in globals 

(new items 2!)

- [x] fix/add tests
- [x] remove IInspectable crap
- [x] fix/test Copy

(new items 3!)

- [x] really do get rid of `IReference` internally"
"Tagging subscribers to this area: @github/ncl
See info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

Note, the old Begin/EndAccept methods support doing an accept and receive in a single operation. Unfortunately the API for this is terrible and forces allocation. It's also not currently supported on non-Windows platforms. So, replace this with a helper routine that performs an accept followed by a receive, and works across all platforms.

Contributes to #43845

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>geoffkizer</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`area-System.Net.Sockets`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
@github how gross is this? Having this here avoids a second dictionary lookup per page invocation.
"I'm not sure that's necessarily an improvement?

If there should *never* be more than one License file, should we `<Error/>` on it?

If there *should* be more than oneâ€¦but we only ever use oneâ€¦wtf should happen?

This just ""feels weird""."
"Okay going to show my C++ noob here, what's the proper pattern to do this call then, do I need to explicitly copy the string into another variable, like hostFxrPath for it not to get destroyed?"
"Kinda nasty, but I think I did it correctly within the locks, and added a gross test that adds/removes a bunch of schemes for correctness"
"Verified, insane. "
"See, I wanted to ensure that whatever set of args the user provided always generated a unique string. Yea, if the user puts all the args into a keybinding/command, this will be stupid long like this. At that point, the user should probably have a better name they could give the command."
"Yeah, I'm not a fan of any of these extension methods that all take lambdas that call each other. I only looked at cleaning up the solution provider ones, but I can have a pass at the rest. I think this is part of an existing one that I pulled the filtering code out of, but the diff of this file looks pretty terrible in general."
"yeah, no problem, as I said, I'm terrible at naming :) "
"Are there any custom triggers being used to represent other types of triggering, or is it really being used as ""here's a way to pass ambient state along for the ride""? I recognize this might churn stuff, but it very much feels like this CustomTags exists on trigger just because it was the convenient type that happens to be there.

Three interesting, potentially controversial, and likely terrible ideas came to mind while writing that previous sentence:
1. I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.
2. Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then _perhaps_ we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could _imagine_ people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am _not_ saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that _also_ might fix this problem too, I can't help but notice the coincidence.
3. Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.
"
"If we allow `checkExpressionCached` to continue, the relevant symbol still ends up marked referenced via `checkExpressionCached` -> `checkIdentifier` -> `markAliasReferenced` -> `markAliasSymbolAsReferenced`. In other words, it's not only `markExportAsReferenced` that will end up marking it referenced.

So I think it's possible to alter `markExportAsReferenced` instead of `checkExportSpecifier`, though it may be a bit more awkward since `markExportAsReferenced` takes a couple different kinds of nodes.

And then we do still need to handle the other code path too. For that, nothing stands out as a great option. It feels like an `export type` ancestor check is possible, and similar to other checks that `markAliasReferenced` does already for example (`isInTypeQuery`), but depending on where we try to check, it could be an arbitrarily long ancestor walk.

I guess the choice I'm leaning towards for this other code path would be a check in `checkIdentifier` for the `node.parent.parent.parent` being a type only export declaration. This would be similar to the check for a property access expression and would go around the call to `markAliasReferenced`. Feels a bit gross, but we can know the exact ancestor to try to check from here."
"No, the feature is only set if an activity is created. (also there really should be comments about these different sections, maybe vs. sometimes, wtf?)"
"I don't think this is a terrible idea, but maybe one we do in another PR?"
"Downloaded the branch and tested it. Yeah, this works fine. And scenarios like ""opening the search box while the tab switcher is open"" would probably fall under the ""play stupid games"" category. Fixing this is probably more effort than it's worth right now, so good enough for me!"
"`_set_tcs_result_ref` does not propagate user's exception from whoever is awaiting the task.

It could only throw if runtime is in some terrible state already. In such case, I'm not sure what is the correct recovery.
As it is, the exception would bubble to main loop, as this is promise callback.

I at lest moved both `mono_wasm_release_cs_owned_object` and `teardown_managed_proxy` to `finally()`"
"I guess we have to account for the offline client here which is gross. Yet another reason to figure out #7805.  "
"_technically_ yes. But also technically, a caller could be stupid and set `FoundMatch(true)` _before_ calling this. Or you could be me in the tests, and reusing the same `args` across multiple calls, because you're too lazy to instantiate multiple. So I always think it's good form to have the handler manually set a result like this, so that _no matter what_, the result is initialized to a failure state, and only set to success when we know we're successful. "
"I actually split it up into two parts - one for unpacking the json (`GetGuidOrGenerateForJson`), and another for doing the source/name GUID generation. I had to split it up like that because the profile doesn't actually have a reference to its own JSON. i could have theoretically had the profile re-create a blob of json and call the json parsing function, but that seemed insane."
"Hmm

Would it make sense having _stream on Connection as private protected? (probably a terrible idea)
Or have you considered a different name here or the base type? _streamWrapper on the base type?
Or at least a comment explaining why this is different from the base type _stream.

Same for new Pipe below."
"That shouldn't be the case ... o_O the title should never be empty because it was getting set by `updateSettings`

oh crap i just realized i made you make a bad/annoying change"
"Ugh gross. OK, maybe don't put it in by default and let people override it for now and file a follow-on to make `file://` smarter."
"\<aside> Yea, this ""Capabilities"" section I've always hated. I think if you're outside MSFT, then you don't have any idea what to put here, and ""capabilities"" is a _terrible_ heading for it"
"> This PR fixes #127365
> 
> The added code follows the `IExplorerCommand + app identity` method recommended by [Windows Blog](https://blogs.windows.com/windowsdeveloper/2021/07/19/extending-the-context-menu-and-share-dialog-in-windows-11/), which is the minimal code necessary to implement this feature, and has _not been integrated into the Inno Setup script_. I hope that these codes can be used as an inspiration, and the VS Code developers would find out a sensible way to achieve this feature.
> 
> ![Screenshot 2021-12-22 230721](https://user-images.githubusercontent.com/26765742/147120434-0c54a018-ea84-471b-9498-cf904baa7117.png)
> 
> ![Screenshot 2021-12-22 230859](https://user-images.githubusercontent.com/26765742/147120449-c6eeb092-9678-4ade-a317-9f18f267a94c.png)
> 
> The added codes are located at `/build/win32/shell-extension-win11`, including an action handler, a minimal sparse package manifest, build script and setup script.
> 
> Because these are not integrated into Inno Setup, a manual build process is needed:
> 
> Assume that VS2019 with desktop development workload is installed in the working environment. `build.cmd` can make the sparse package and `.dll` library file for handling menu actions, which are needed by Windows. It also self-issues a test certificate to sign the sparse package. (This maybe needs to be implemented in a more formal way.)
> 
> By executing `build.cmd` 3 files will be put in the `/build/...-win11/Release` directory, namely `menuhandler.dll`, `Key.cer` and `code-sparse.appx`. The certificate issuance and signature process will prompt to enter a password for 3 times, just enter the same password.
> 
> Copy these 3 files with `setup.ps1` to anywhere inside an VS Code installation, and execute `setup.ps1` with administrator privileges. After restarting explorer.exe, you can see the option of ""Open by Code"" in context menus of files and directories.
> 
> The menu action is handled by C++ code implementing the COM interface, while currently for older versions of Windows this is achieved by the installer to directly write into registry. So the COM implemention directly reads the keys from registry to present the icon and determine the executable file path, to keep it simple and stupid. Perhaps this approach needs further improvement.
> 
> Localization has not been implemented yet, but by reading the registry, it should be easy.

Can you record short video?"
Just me being stupid... :-P
"One option is to pass the string and a variable number of arguments, and only smash them together in a string if we're called to walk the stack.

I discarded it due to complexity for now. I could write up a performance benchmark and see how much it helps, but went with the simple and stupid thing for a RFC PR."
"Is a result task, it would allocate a `Task<FlushResult>`. 

Thought about adding an extension method called `.AsNonGenericTask`; but that seemed a terrible name."
"wtf.

```suggestion
            => new AbstractFormattingRule[] { new ChangeSignatureFormattingRule(),  Formatter.GetDefaultFormattingRules(document) };
```

i.e. why on earth are we making a singleton enumerable, just to concat a single known value onto it.  it's an array with two elements.  just have it be that."
"> I guess if it was OK for BindableLayout, it should be OK for Map too?

Either that, or we made a terrible mistake merging 5582. That implementation of Replace in `Apply` is very suspect.

It looks like Map.Pins is an `ObservableCollection<Pin>`, so while I don't like this implementation of `Apply`, it should be fine for this purpose. It looks like the implementation of `ObservableCollection` only uses `NotifyCollectionChangedAction.Replace` for a single item being set. So at least for this specific application, it shouldn't cause any immediate problems.

"
"Possibly this is an example of me trying to outsmart the compiler and in the end doing something stupid ðŸ˜„ Was trying to achieve inlining this method in its usages, given that it's just a simple expression, to avoid unnecessary calls to this method. The compiler will be smart enough to inline it without the attributes?"
"As a side note, the reason fixing this is important even given the obvious uselessness of the construct `const {} = anything` is that we ought to be able to deliver accurate completions inside the `{}`. Prior to this fix, you got both `a` and `b` since thatâ€™s what `T` had in its domain, but as soon as you accept the `a` completion, the contextual type changes and therefore the inference changes and it becomes an error, which is a terrible experience."
"It's sad to see that the work on this seems to have come to a halt.
Implementing would-be-convenient functionality now requires insane workarounds.

Bumping this again, in hope to see this released â™¥ï¸"
"This is where we call into the action constraints. 

The reasons that I went this way instead of using something new to solve the problem:
- This is the simplest thing to do for now
- I'm not sure how common this requirement is outside of MVC.

The thing that this solves is selecting between a GET endpoint and a POST endpoint, etc. It seems obvious someone layering a CMS on top of MVC needs this functionality. Maybe I am just being stupid and this needs to be *built-in*."
"> Shouldn't this be done in the other ctor?

Yes, absolutely right! I knew to do that earlier then for some reason started working on something else and forgot about it. Thanks for catching that.

> Also how do you feel about passing in an ILogger \ ILoggerFactory instead to the ctor? This feels a little gross. This feels a little gross.

I did this because we already take a `serviceProvider`, so why complicate things for the consumer? Under what circumstances would someone have reason to supply a different `ILogger` than the one the service provider would offer? I'm not absolutely set against it, but would like to make a choice based on practical reasoning.

In the long term, we may need to consume other services too. If we keep adding them as extra constructor overloads one-by-one, it will not be a nice experience for consumers."
I flipped this because _calling the destructor manually is terrible._
"holy shit this whole function is magic

"
Gross. OK.
"@github could this be something as stupid as not giving mlaunch enough time to finish?

Here's a good run:

```
[05:25:47] dbug: test[0]
      05:25:47.1394590 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmpmlrVXC.tmp --output-format=XML
[05:26:08] dbug: test[0]
      05:26:08.8570810 Simulator configuration written to /tmp/tmpmlrVXC.tmp
[05:26:08] dbug: test[0]
      05:26:08.9515020 Process exited with 0
[05:26:09] dbug: test[0]
      05:26:08.9536870 Simulator listing returned:
```

That took 22 seconds to return any results

Here's a bad one:

```
[02:06:49] dbug: test[0]
      02:06:49.7723290 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmp3dqcCa.tmp --output-format=XML
[02:07:19] dbug: test[0]
      02:07:19.8645850 Process 4094 didn't exit within 00:00:30 and will be killed
```

Timeout is 30 seconds

How close to the wire is it getting?"
python3 wtf. Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?
