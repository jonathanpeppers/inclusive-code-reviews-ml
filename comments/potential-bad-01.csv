Body
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"These relations are insane! Everything looks good to me though! Perhaps remove the newline before the curly braces when starting interfaces though for style, but your call!"
"> wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
> [sceen](http://joxi.ru/EA4Rw3xHXyZbWm)

sorry, wrong autocomplete from github."
"@github Sure enough if there's people enthusiastic about it! It's not trivial to rebase it, but it's not completely terrible either. I might be a bit busy during the start of this week but might have time in latter half. Feel free to message me here and push me forward again If I don't write an update here during this week. :-)"
"This is kinda gross. This namespace doesn't exist in Ignitor, but I could make an empty one if that's cleaner?"
Oh crap! I thought about that when I started to write the tests and then I forgot about it!
"@github 
Yea stupid me, forgot to check in the added file.  Its up now.  I moved it because it is now used in three places TimePicker, DatePicker, & Entry.  The reality is, it will most likely need to be used in more places.  Check that out again and if you want to move the BoolEventArgs somewhere else, like a separate file then we can do that."
"## TODO for this PR
- [x] Update IDL with `Has...` functions
- [x] Runtime error when `_globals->CreateChild()` is being assigned (only when loading settings.json, fine otherwise)
- [x] Update spec and propagate changes from spec
- [x] Profile has a few settings we handle manually (i.e. BI alignment). I need to hook those up properly too
- [x] ~(Bonus Points) _maybe_ make these settings observable (we'll need that soon anyways)~ Nope

(new items!)
- [x] Fix `startingDirectory` being null
- [x] Fix tests
- [x] merge master (new Profile setting)
- [x] (after #7877 merges) address ""TODO CARLOS"", copy commands/keybindings/schemes in globals 

(new items 2!)

- [x] fix/add tests
- [x] remove IInspectable crap
- [x] fix/test Copy

(new items 3!)

- [x] really do get rid of `IReference` internally"
"Tagging subscribers to this area: @github/ncl
See info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

Note, the old Begin/EndAccept methods support doing an accept and receive in a single operation. Unfortunately the API for this is terrible and forces allocation. It's also not currently supported on non-Windows platforms. So, replace this with a helper routine that performs an accept followed by a receive, and works across all platforms.

Contributes to #43845

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>geoffkizer</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`area-System.Net.Sockets`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
@github how gross is this? Having this here avoids a second dictionary lookup per page invocation.
"I'm not sure that's necessarily an improvement?

If there should *never* be more than one License file, should we `<Error/>` on it?

If there *should* be more than one…but we only ever use one…wtf should happen?

This just ""feels weird""."
"Okay going to show my C++ noob here, what's the proper pattern to do this call then, do I need to explicitly copy the string into another variable, like hostFxrPath for it not to get destroyed?"
"Kinda nasty, but I think I did it correctly within the locks, and added a gross test that adds/removes a bunch of schemes for correctness"
"Verified, insane. "
"See, I wanted to ensure that whatever set of args the user provided always generated a unique string. Yea, if the user puts all the args into a keybinding/command, this will be stupid long like this. At that point, the user should probably have a better name they could give the command."
"Yeah, I'm not a fan of any of these extension methods that all take lambdas that call each other. I only looked at cleaning up the solution provider ones, but I can have a pass at the rest. I think this is part of an existing one that I pulled the filtering code out of, but the diff of this file looks pretty terrible in general."
"yeah, no problem, as I said, I'm terrible at naming :) "
"Are there any custom triggers being used to represent other types of triggering, or is it really being used as ""here's a way to pass ambient state along for the ride""? I recognize this might churn stuff, but it very much feels like this CustomTags exists on trigger just because it was the convenient type that happens to be there.

Three interesting, potentially controversial, and likely terrible ideas came to mind while writing that previous sentence:
1. I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.
2. Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then _perhaps_ we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could _imagine_ people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am _not_ saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that _also_ might fix this problem too, I can't help but notice the coincidence.
3. Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.
"
"If we allow `checkExpressionCached` to continue, the relevant symbol still ends up marked referenced via `checkExpressionCached` -> `checkIdentifier` -> `markAliasReferenced` -> `markAliasSymbolAsReferenced`. In other words, it's not only `markExportAsReferenced` that will end up marking it referenced.

So I think it's possible to alter `markExportAsReferenced` instead of `checkExportSpecifier`, though it may be a bit more awkward since `markExportAsReferenced` takes a couple different kinds of nodes.

And then we do still need to handle the other code path too. For that, nothing stands out as a great option. It feels like an `export type` ancestor check is possible, and similar to other checks that `markAliasReferenced` does already for example (`isInTypeQuery`), but depending on where we try to check, it could be an arbitrarily long ancestor walk.

I guess the choice I'm leaning towards for this other code path would be a check in `checkIdentifier` for the `node.parent.parent.parent` being a type only export declaration. This would be similar to the check for a property access expression and would go around the call to `markAliasReferenced`. Feels a bit gross, but we can know the exact ancestor to try to check from here."
"No, the feature is only set if an activity is created. (also there really should be comments about these different sections, maybe vs. sometimes, wtf?)"
"I don't think this is a terrible idea, but maybe one we do in another PR?"
"Downloaded the branch and tested it. Yeah, this works fine. And scenarios like ""opening the search box while the tab switcher is open"" would probably fall under the ""play stupid games"" category. Fixing this is probably more effort than it's worth right now, so good enough for me!"
"`_set_tcs_result_ref` does not propagate user's exception from whoever is awaiting the task.

It could only throw if runtime is in some terrible state already. In such case, I'm not sure what is the correct recovery.
As it is, the exception would bubble to main loop, as this is promise callback.

I at lest moved both `mono_wasm_release_cs_owned_object` and `teardown_managed_proxy` to `finally()`"
"I guess we have to account for the offline client here which is gross. Yet another reason to figure out #7805.  "
"_technically_ yes. But also technically, a caller could be stupid and set `FoundMatch(true)` _before_ calling this. Or you could be me in the tests, and reusing the same `args` across multiple calls, because you're too lazy to instantiate multiple. So I always think it's good form to have the handler manually set a result like this, so that _no matter what_, the result is initialized to a failure state, and only set to success when we know we're successful. "
"I actually split it up into two parts - one for unpacking the json (`GetGuidOrGenerateForJson`), and another for doing the source/name GUID generation. I had to split it up like that because the profile doesn't actually have a reference to its own JSON. i could have theoretically had the profile re-create a blob of json and call the json parsing function, but that seemed insane."
"Hmm

Would it make sense having _stream on Connection as private protected? (probably a terrible idea)
Or have you considered a different name here or the base type? _streamWrapper on the base type?
Or at least a comment explaining why this is different from the base type _stream.

Same for new Pipe below."
"That shouldn't be the case ... o_O the title should never be empty because it was getting set by `updateSettings`

oh crap i just realized i made you make a bad/annoying change"
"Ugh gross. OK, maybe don't put it in by default and let people override it for now and file a follow-on to make `file://` smarter."
"\<aside> Yea, this ""Capabilities"" section I've always hated. I think if you're outside MSFT, then you don't have any idea what to put here, and ""capabilities"" is a _terrible_ heading for it"
"> This PR fixes #127365
> 
> The added code follows the `IExplorerCommand + app identity` method recommended by [Windows Blog](https://blogs.windows.com/windowsdeveloper/2021/07/19/extending-the-context-menu-and-share-dialog-in-windows-11/), which is the minimal code necessary to implement this feature, and has _not been integrated into the Inno Setup script_. I hope that these codes can be used as an inspiration, and the VS Code developers would find out a sensible way to achieve this feature.
> 
> ![Screenshot 2021-12-22 230721](https://user-images.githubusercontent.com/26765742/147120434-0c54a018-ea84-471b-9498-cf904baa7117.png)
> 
> ![Screenshot 2021-12-22 230859](https://user-images.githubusercontent.com/26765742/147120449-c6eeb092-9678-4ade-a317-9f18f267a94c.png)
> 
> The added codes are located at `/build/win32/shell-extension-win11`, including an action handler, a minimal sparse package manifest, build script and setup script.
> 
> Because these are not integrated into Inno Setup, a manual build process is needed:
> 
> Assume that VS2019 with desktop development workload is installed in the working environment. `build.cmd` can make the sparse package and `.dll` library file for handling menu actions, which are needed by Windows. It also self-issues a test certificate to sign the sparse package. (This maybe needs to be implemented in a more formal way.)
> 
> By executing `build.cmd` 3 files will be put in the `/build/...-win11/Release` directory, namely `menuhandler.dll`, `Key.cer` and `code-sparse.appx`. The certificate issuance and signature process will prompt to enter a password for 3 times, just enter the same password.
> 
> Copy these 3 files with `setup.ps1` to anywhere inside an VS Code installation, and execute `setup.ps1` with administrator privileges. After restarting explorer.exe, you can see the option of ""Open by Code"" in context menus of files and directories.
> 
> The menu action is handled by C++ code implementing the COM interface, while currently for older versions of Windows this is achieved by the installer to directly write into registry. So the COM implemention directly reads the keys from registry to present the icon and determine the executable file path, to keep it simple and stupid. Perhaps this approach needs further improvement.
> 
> Localization has not been implemented yet, but by reading the registry, it should be easy.

Can you record short video?"
Just me being stupid... :-P
"One option is to pass the string and a variable number of arguments, and only smash them together in a string if we're called to walk the stack.

I discarded it due to complexity for now. I could write up a performance benchmark and see how much it helps, but went with the simple and stupid thing for a RFC PR."
"Is a result task, it would allocate a `Task<FlushResult>`. 

Thought about adding an extension method called `.AsNonGenericTask`; but that seemed a terrible name."
"wtf.

```suggestion
            => new AbstractFormattingRule[] { new ChangeSignatureFormattingRule(),  Formatter.GetDefaultFormattingRules(document) };
```

i.e. why on earth are we making a singleton enumerable, just to concat a single known value onto it.  it's an array with two elements.  just have it be that."
"> I guess if it was OK for BindableLayout, it should be OK for Map too?

Either that, or we made a terrible mistake merging 5582. That implementation of Replace in `Apply` is very suspect.

It looks like Map.Pins is an `ObservableCollection<Pin>`, so while I don't like this implementation of `Apply`, it should be fine for this purpose. It looks like the implementation of `ObservableCollection` only uses `NotifyCollectionChangedAction.Replace` for a single item being set. So at least for this specific application, it shouldn't cause any immediate problems.

"
"Possibly this is an example of me trying to outsmart the compiler and in the end doing something stupid 😄 Was trying to achieve inlining this method in its usages, given that it's just a simple expression, to avoid unnecessary calls to this method. The compiler will be smart enough to inline it without the attributes?"
"As a side note, the reason fixing this is important even given the obvious uselessness of the construct `const {} = anything` is that we ought to be able to deliver accurate completions inside the `{}`. Prior to this fix, you got both `a` and `b` since that’s what `T` had in its domain, but as soon as you accept the `a` completion, the contextual type changes and therefore the inference changes and it becomes an error, which is a terrible experience."
"It's sad to see that the work on this seems to have come to a halt.
Implementing would-be-convenient functionality now requires insane workarounds.

Bumping this again, in hope to see this released ♥️"
"This is where we call into the action constraints. 

The reasons that I went this way instead of using something new to solve the problem:
- This is the simplest thing to do for now
- I'm not sure how common this requirement is outside of MVC.

The thing that this solves is selecting between a GET endpoint and a POST endpoint, etc. It seems obvious someone layering a CMS on top of MVC needs this functionality. Maybe I am just being stupid and this needs to be *built-in*."
"> Shouldn't this be done in the other ctor?

Yes, absolutely right! I knew to do that earlier then for some reason started working on something else and forgot about it. Thanks for catching that.

> Also how do you feel about passing in an ILogger \ ILoggerFactory instead to the ctor? This feels a little gross. This feels a little gross.

I did this because we already take a `serviceProvider`, so why complicate things for the consumer? Under what circumstances would someone have reason to supply a different `ILogger` than the one the service provider would offer? I'm not absolutely set against it, but would like to make a choice based on practical reasoning.

In the long term, we may need to consume other services too. If we keep adding them as extra constructor overloads one-by-one, it will not be a nice experience for consumers."
I flipped this because _calling the destructor manually is terrible._
"holy shit this whole function is magic

"
Gross. OK.
"@github could this be something as stupid as not giving mlaunch enough time to finish?

Here's a good run:

```
[05:25:47] dbug: test[0]
      05:25:47.1394590 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmpmlrVXC.tmp --output-format=XML
[05:26:08] dbug: test[0]
      05:26:08.8570810 Simulator configuration written to /tmp/tmpmlrVXC.tmp
[05:26:08] dbug: test[0]
      05:26:08.9515020 Process exited with 0
[05:26:09] dbug: test[0]
      05:26:08.9536870 Simulator listing returned:
```

That took 22 seconds to return any results

Here's a bad one:

```
[02:06:49] dbug: test[0]
      02:06:49.7723290 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmp3dqcCa.tmp --output-format=XML
[02:07:19] dbug: test[0]
      02:07:19.8645850 Process 4094 didn't exit within 00:00:30 and will be killed
```

Timeout is 30 seconds

How close to the wire is it getting?"
python3 wtf. Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?
