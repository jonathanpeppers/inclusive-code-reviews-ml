FileBufferingReadStream  is pretty terrible for performance. We need to fix the block size problems.
"`Shutdown` is ""shutdown writes, send EOF to peer"".

`ShutdownWriteCompleted` was ""wait for peer to acknowledge that shutdown"" which we found to be mostly useless so I believe we changed it to mean ""wait for peer to acknowledge that shutdown AND to shutdown their side too"". It has a terrible name. This is what I'd like to see changed to a `Task Completed { get; }`."
"Mel was a bit stupid here, remove 2 of these comments copies."
fuck them alll
"Crap, before this will work we need to update the spa-templates submodule to reference the dotnet7 feed & ingest it. I'll update that repo now."
"This is really gross and is screaming ""IDL"" and/or ""COM"" at me. Maybe `TerminalCore` just needs to become a CppWinRT module and be activated that way?

Or can we not do that because you're trying to make this work back to Windows 7? In which case, can it just be a classic COM interface definition or something?"
This confused the crap out of me until I saw the other code. Again wondering if a base type w/ derived type that doesn't really do anything at least keeps the hack isolated.
"> if an option is 0 (All), it will now just be ignored.

Fuck. 😄 I need to learn to read. 😄"
"@github I'm stupid, wanted to do this on d16-8, looks like changing the target branch is a bad idea. I'll close and recreate."
"Problem is that we don't know what the user will use as a type. Suppose the following situation:
```

@foreach (SomeClass item in items)
{
	object myDelegate = (SomeClass sc, MouseEventArgs args) => sc.DoSomething(args);
	<button @onclick=""(args => ((Action<SomeClass, MouseEventArgs>)myDelegate(item, args))"" />
}

```

Of course, this is insane and not code that anyone would write, but it does indicate that the declared type of a field on the closure does not necessarily have to match the runtime type. So `is` seems appropriate to me.
"
I'm terrible at spelling 😦 
"stupid me
"
"_holy crap you actually did it_

I'm gonna throw this out here right now - the team is absolutely stoked that you were able to throw together a PR for this feature in _just three days_. That's really impressive. 

I'm going to be the pre-emptive bearer of badish news - we're starting to make harder cuts about what is and isn't making it into the 1.0 release of the Terminal. As _awesome_ as this feature is, I'm going to go with my gut here and guess that this isn't going to make that cut unfortunately. That being said, we're still going to review this now and get feedback to you. Once this gets approved, we'll probably just hold in until we make an official 1.0 release branch, and then we'll get it merged immediately after that."
There is no such thing as a stupid question :)
"Don't be fooled by the terrible diff - that's in install_mono_toolset()
"
Holy crap this helper is awesome.
"```suggestion
                   if (currentScreenInfoRow == static_cast<ScreenInfoRow>(_end.Y))
```
This is why `GetText()` has been acting so stupid."
What the heck is going on here? I'd love to have some inline documentation for when we do insane winrt things like this
I didn't look into this in great detail. Any suggestions on how this could be done without making the new Stream gross? 
"Yes. It's just a terrible sentence. Fixed to say ""container"".

---
In reply to: [245379071](https://github.com/dotnet/roslyn/pull/31986#discussion_r245379071) [](ancestors = 245379071)"
"I believe using explicit linked files is actually super terrible to maintain and port future analyzers/fixer/tests. After having attempted this both ways (using the existing add of linked files and then with shared projects), I think using shared projects is way easier for porting more analyzers/fixers as well as viewing the existing ported shared analyzers and fixers. Lets discuss both these approaches in the meeting today, I can open up the solution from this branch.

Regardless, as mentioned in https://github.com/dotnet/roslyn/issues/38480#issuecomment-578903218, I think neither of these are really good long term solutions and we should eventually just move these analyzers/fixers completely into CodeStyle layer and ship CodeStyle NuGet with the SDK."
"Sorry if I'm being stupid here, but I don't understand why the markdown renderer needs to be modifiered. Can the review widget add the required css / classes instead of having the markdown renderer do it?"
"@github We actually have two sanitization passes currently, one from `marked` and one from `insane`. The `insane` is the more complete sanitizer so we probably don't need the marked one.

What worries me though is that by allowing markdown strings to use `style`, we open up the surface area both in terms of security and presentation. Now an extension can use arbitrary css in hovers, including loading images or positioning content outside of the hover itself. 

Github's sanitizer for markdown previews strips out `style` attributes for these reasons (and also I believe because `style` could at one point be used in very old browsers to run scripts and do other super unsafe things)

"
yeah.  wtf.  i'm not sure what i was thinking.  we shoudl handle the disparate forms.  
"noob cpp incoming question, it looks like these things are used in debugutil.cpp why are the includes here instead of in debugutil.cpp? "
"I do like keeping the main logic in CreateResponseHeaders. I think the current implementations of HasInvalidH2H3Headers and ClearInvalidH2H3Headers() are plenty efficient. You could even argue it creates less branching logic on the set-headers path compared to proactively avoiding setting them. We could microbenchmark, but I'm not too concerned about optimizing the case where invalid headers are being set as long as it isn't terrible."
"Because I'm a terrible person and didn't review this soon enough, language version 8.0 is now the default so you should be able to drop this project reference and also remove the ""Regular8WithNullableAnalysis"" uses, because that doesn't exist anymore..."
"that looks insane, does that just set to `initialized` to true the first time it's called then we just check `if(initialized)`
"
Great! Just idiot thoughts
"Crap, I meant the slash direction. I'll fix that."
I begrudgingly accept this until quirking our APIs becomes widespread enough that we should pass a quirk struct into all of them uniformly so it's less gross.
"I'd really really love for this to not be totally insane.

`IconSource`? idk. When I get more time, I'm gonna set up a simple repro for the WinUI team to tell me exactly wtf is going on here."
"this is the meat of where things changed.  unfortunately, the diff is terrible.  effectively teh logic is pretty simple:

1. determine the expression we want to inline.
2. find the reference locations to inline and inline there.
3. if we had no conflicts, remove the declaration
4. add warning annotations for things like side-effects or moving code into conditionally compiled methods"
hm... `g__EqualsUnrolled_9_to_16` was not inlined and it's terrible if executed without it... 😢 
"I'm not sure if MSVC couldn't ""manage"" to recognize and change it to memset, or it chose not to. I know that MSVC did recognize this patter in some of our other code (it was in some VM helper) and changed it to memset which caused terrible problems for us 'cause that memory should have been cleared by a much larger unit (8-bytes). personally I'd really rather compiler not do this kind of ""optimization"" which could totally introduce bugs."
"Okay, so, need help from someone who understands the libraries build a little better here (@github?)

* The build doesn't really support OS subgroups (i.e. `linux-musl`, `linux-bionic`), it's a gross hack where the system thinks it's actually the OSGroup OS (Linux for musl), some magic autodetection code in a few shell scripts tells it otherwise and causes changes in build behaviour, and the RID gets overridden post-hoc via `/p:OutputRID`. I've removed this assumption in a few places and parsed `/p:RuntimeOS`, because it's not possible to autodetect the difference between Android and linux-bionic based on anything in the rootfs.
* We still need a TargetOS (`--os`). The `linux-musl` build defaults to `linux`; in our case there's a case to be made for both `linux` and `android`. And we kinda need to be both, in a few places - System.Net.Security and System.Security.Cryptography we need the Linux version NOT the Android version, whereas System.Console we want the Android version. Do we want to add a separate TFM for linux-bionic? Use RuntimeOS conditionals in the relevant csproj? What's the least painful way to do this?"
"Sorry I was missing full context on the previous conversation: should this just be GetTextAsync? In theory still instant, but if we're wrong it's less terrible?

(still OK with this more than TryGetText)"
Removed. This was a sleepy me being stupid last night and just testing a variable named discard. 
Is it a terrible bother if I request @github as a reviewer for this one? He probably knows more than we do 😝 
"@github glad you asked

well, at least we shouldn't have multiple caches... TypeConversionExtensions.KnownConverters, TCE.KnownConverterFactories, BindableProperty.KnownTypeConverter; and then we have NodeILExtensions.KnonwnCompiledTypeConverters

Type Conversion happens at multiple places:
- when setting a value from xaml
- when applying a binding (this includes AppThemeBinding, DynamicResource, ...)
- when applying a style

ColorTypeConverter and ThicknessTypeConverter do _not_ need to be cached in a known list, as they are attributed with a TypeConverterAttribute, they need to be in the KnownCOMPILEDTypeConverter as they're not attributed with the ProvideCompiledAttibute.

The only converter that can not be retrieved using reflection is UriTypeConverter as System.Uri is NOT attributed on .NET core 6 (even though System provides a UriTypeConverter that we should use now that we replaced our own base TypeConverter type by System.ComponentModel.TypeConverter. Side note, System.Uri is attributed in the net framework profile, go figure). so why do we whitelist ColorTypeConverter and EasingTypeConverter in BindableProperty.cs is something that need clarification.

I don't recall the details of why FontTypeConverter need to be whitelisted, but I recall that we almost got rid of Font as a property type in most (all?) of our controls (because compound properties are a mess and produce too many propertychange events, and redraw).

We could/should cache the TypeConverters:
- at runtime when we encounter them
- at startup time using reflection (fuck no)
- or at compile time using a sourcegen
Our own TypeConverters are known beforehand, but I'm not keen on maintaining a list of those (I'd prefer a sourcegen), but there's also the TypeConverters defined in 3rd party assemblies. Oh, and caching type converters isn't a solution for avoiding reflection, as TypeConverterAttributes on properties take priority over the ones defined on Type, but we could cache that too (using the PropertyInfo as key e.g.)

To summarise this digression on TypeConverters, here's a list of action points:
- [ ] Investigate the usage of `Font` in Controls. It's probably unused, in that case `FontTypeConverter` and the 2 caches in TypeConversionExtension could go away
- [ ] Investigate `Font` usage in Core, and the reason it was ported there, and not deprecated
- [ ] Investigate why ColorTypeConverter and EasingTypeConverter are whitelisted
- [ ] Investigate caching TypeConverters for properties and types. I'd recommend going for a sourcegen solution and generate a switch instead of a dictionary to avoid allocation bump
- [ ] None of our TypeConverters have any side effect, and instances could be reused (we can speak for 3rd party converters, unfortunately...)"
LMK if there's a more idiomatic way to do this. i is noob
"> Ack. That feeling when you realize you're an idiot :D

That's how I felt on Friday. In my case, I made the reverse mistake: I was correctly adding both C and D to B's transitive references, but forgot to update A too."
"Stupid linker. Fixed.
"
"@github I haven't tried this yet, but I'm wondering what it looks like after I have a new descriptor. Still, I need to destroy the old grid, right? Which will disconnect the whole workbench from the dom and reattach. Is that what you have in mind?

Also, today, I don't really have call layout on the whole grid when moving things around. The code is a bit gross, but the grid seems to handle calling layout on the appropriate things so there are no issues. However it seems like I would have to call a top-level layout every time a part moves with this approach. Is that not more expensive?"
"Isn't the solution file at this point known to exist? (Aren't we already loading it?) Can this ever fail?

(yes, I know this logic was there, but if we're deleting stupid code we mind as well delete more stupid code)
"
"Ah, crap - you need to build this locally to update all the xlf files and include those changes."
"> ProjectIds returns an IReadOnlyCollection<T>, which generally isn't safe for iteration during mutating operations

It shoudl def be safe though as per the roslyn Worspace invariants.  The ProjectIds of a Solution cannot change out from underneath you.  That would be a gross violation of the contract of Solution :)"
"> @github no i don't want it to move down to `IRenderEngine`, either. Check out my edit. I want it to be DX only, which helps all of us.

1 vote new API.

> Oh, shit. I don't hate that. @github what do you think?

2 votes new API.

> That said I don't have any strong opinions about it. Code can always be modified. 🙂

2 votes new API. 1 vote ""whatevs man, it's just code.""

> > // Create a new `UpdateFont` method with more parameters only in DxEngine.
> > _renderEngine->UpdateFone(newDpi, _desiredFont, _actualFont, whatever we want to add);
> 
> I like this. Would like to hear from @github before proceeding though

3 votes new API. 1 vote ""whatevs man, it's just code.""

I'm fine also with adding a DXEngine only method with additional parameters and calling it directly until such later date that @github and @github make their thin-API data-driven renderer dreams come true.

So I think that's 4 votes new API. 1 vote ""whatevs man, it's just code."" Sold."
"same, I'm an idiot."
"> It should be. I cherry picked the commit.

👍 

> I didn't know about the forking and bots... I'm a noob with all this. Next time or should I create now?

We typically prefer work (and pull requests) to be done in forks. It's fine for this PR, but if you could create the d16-7 PR using your fork that would be great! And we've branched d16-8 as well, so this fix needs to go there too."
"We found a similar bug in other extensions libraries #33998.  Since its just extension methods that folks aren't going to directly reference it's not a terrible type conflict.  I'd just suppress the error for now and file a bug.  If folks have a scenario for using the two types and notice the clash we can address it.
https://github.com/dotnet/runtime/blob/562232c2f7ac24551abdfab04c1186740fcb4e50/src/libraries/pkg/test/packageTest.targets#L24-L25

> HashCodeCombiner

What do you suggest?  Removing is breaking, we could obsolete it and/or implement on top of System.HashCode?


"
"Hey @github, I guess I can answer to that 😄

There are a couple places where I'm using that API in the MVVM Toolkit, and they're indeed in a performance oriented type.
They're only being used on values being of private types, coming from private fields, and guaranteed to be correct due to the implementation of the type itself, so the only way this could break is if a dev actually tried to mess up with the internal fields using reflection, which is something that not even types from the BCL guard against, as far as I can tell (eg. `Memory<T>` will break the type safety too in the `Span` property getter if a dev used private reflection to store some arbitrary object there).

In particular, there's a usage of the `Unsage.As<T>(object)` API in the MVVM Toolkit that just can't be worked around without having to sacrifice quite a fair bit of performance and more memory usage, which is this line [here](https://github.com/windows-toolkit/WindowsCommunityToolkit/blob/79127cf6a76ea1b0673c0376e43d41f91b2df509/Microsoft.Toolkit.Mvvm/Messaging/StrongReferenceMessenger.cs#L400-L404):

```csharp
// Assume we have these locals
object handler;
object recipient;
TMessage message;

// Here we perform an unsafe cast to enable covariance for delegate types.
// We know that the input recipient will always respect the type constraints
// of each original input delegate, and doing so allows us to still invoke
// them all from here without worrying about specific generic type arguments.
Unsafe.As<MessageHandler<object, TMessage>>(handler)(recipient, message);
```

Basically I have the following situation:

- I have this delegate type, which is used to register message recipients with the ability to specify both the recipient type (so the input to the lambda expression is already of the right type and they don't need to cast), and the message type:

```csharp
public delegate void MessageHandler<in TRecipient, in TMessage>(TRecipient recipient, TMessage message)
    where TRecipient : class
    where TMessage : class;
```

- As you can see from the delegate, `TRecipient` is always a reference type
- The messenger class will guarantee that always the right recipients are passed

So doing that unsafe cast basically tricks the runtime into just calling the `Invoke` method of each actual handler just with an input `object` type (as we don't know the type used in each handler here) - we're essentially invoking a contravariant delegate as if it was covariant in that input argument. Again this is always guaranteed to be a valid type cast due to how the messenger itself works - each recipient will always match the original `TRecipient` constraint in each delegate being invoked. This way we get identical codegen to just invoking those handlers directly, even if we lack knowledge on each type in use.

The alternatives I've considered here would've been:
- Use `Delegate.DynamicInvoke`, which is just terrible for performance/memory usage. We wanted to have the broadcast method have an amortized allocation cost equal to 0, and also to avoid using reflection completely in this implementation.
- Wrap each input handler in another one with just an `object` parameter. This would've meant to completely defeat the whole point of structuring delegates this way to allow the C# compiler to cache them (as they're static), as we would've had to allocate a new display class capturing the input delegate every single time one was registered. Also each broadcast would've had twice the number of virtual calls, as each handler would've had to go through its proxy one doing the recipient cast first.

This is something I've actually talked about quite a bit with @github and @github too in the C# Discord server. Given the exact specifications of this type and the way it's implemented, using this trick should be perfectly valid, as all the various constraints and unsafe casts will always be guaranteed to be valid, so there will never be a type violation in doing so. This is really just a workaround for a lack of proper support for basically doing the equivalent of ""try to invoke this delegate with these inputs, and just throw if they are not valid"". With the exception that here we already know the inputs are valid, so we don't even check.

In an ideal world (as in, with you guys having unlimited time and budget to implement all sorts of proposals even for less requested features), my idea was that `DynamicInvoke` could be implemented as a JIT intrinsic, with the EE engine emitting the code there to just do safe casts of the inputs and throw otherwise - that way all the reflection would be avoided and the resulting codegen would be almost the same as just `Invoke`, with the only difference being the checks for the input parameters and boxing of value type parameters, if any, but that'd be perfectly acceptable. This is just a way to achieve that with the current runtime 🚀

On the other hand, as a result of this and a number of other (less unsafe) optimizations this new implementation is both much faster than all other competitor types from other common libraries, and using virtually no memory at all for broadcasts:

|       Method |        Mean |    Error |   StdDev | Ratio |       Gen 0 |       Gen 1 | Gen 2 |    Allocated |
|------------- |------------:|---------:|---------:|------:|------------:|------------:|------:|-------------:|
|    MvvmLight |   600.35 ms | 2.121 ms | 1.771 ms |  1.00 | 164000.0000 |  53000.0000 |     - |  696481352 B |
|     Caliburn |   354.25 ms | 2.090 ms | 1.853 ms |  0.59 |  14000.0000 |           - |     - |   58976000 B |
|      Calcium |    18.94 ms | 0.028 ms | 0.026 ms |  0.03 |   1843.7500 |           - |     - |    7744042 B |
| **MVVM Toolkit** |    **12.47 ms** | 0.072 ms | 0.056 ms |  0.02 |           - |           - |     - |             - |

Hope this helps to clarify why the usage of that arguably very niche API in that library in particular 😊"
"This mildly concerns me - we've ran into insane bugs in the past where not zero-initializing something has resulted in bugs. 
```suggestion
    PROCESS_BASIC_INFORMATION BasicInfo = { 0 };
```"
"That first parameter being `thisAgrg` hits me 90% time when I use it, because I forget to pass `null` here and then get stupid behavior a I have args shifted. This helps me a little bit, but I'm ok to revert it or to do something else, if you have an idea."
"> Consider a method that does 100 string comparisons against constant strings. Are all these 100 string comparisons going to be optimized, without hitting inliner's budget?

@github So the budget is common for all the callees for a specific root and it gets eaten very quickly with string.Equals, e.g.:
```csharp
static bool Foo(string s)
{
    if (s == ""11111111"" || 
        s == ""22222222"" || 
        s == ""33333333"" || 
        s == ""44444444"" || 
        s == ""55555555"")
    {
        return true;
    }
    return false;
}
```
codegen:
```asm
; Method UnrolledStringEquals:Foo(System.String):bool
G_M33664_IG01:              ;; offset=0000H
       56                   push     rsi
       4883EC20             sub      rsp, 32
       C5F877               vzeroupper 
       488BF1               mov      rsi, rcx
						;; bbWeight=1    PerfScore 2.50

G_M33664_IG02:              ;; offset=000BH
       4885F6               test     rsi, rsi
       7436                 je       SHORT G_M33664_IG04
						;; bbWeight=1    PerfScore 1.25

G_M33664_IG03:              ;; offset=0010H
       837E0808             cmp      dword ptr [rsi+8], 8
       7530                 jne      SHORT G_M33664_IG04
       C5FA6F460C           vmovdqu  xmm0, xmmword ptr [rsi+12]
       C5FA6F4E0C           vmovdqu  xmm1, xmmword ptr [rsi+12]
       C5F1EF0DF8000000     vpxor    xmm1, xmm1, xmmword ptr [reloc @github]
       C5F9EF05F0000000     vpxor    xmm0, xmm0, xmmword ptr [reloc @github]
       C5F1EBC0             vpor     xmm0, xmm1, xmm0
       C4E27917C0           vptest   xmm0, xmm0
       0F94C2               sete     dl
       0FB6D2               movzx    rdx, dl
       EB02                 jmp      SHORT G_M33664_IG05
						;; bbWeight=0.50 PerfScore 11.29

G_M33664_IG04:              ;; offset=0041H
       33D2                 xor      edx, edx
						;; bbWeight=0.50 PerfScore 0.12

G_M33664_IG05:              ;; offset=0043H
       85D2                 test     edx, edx
       0F85B4000000         jne      G_M33664_IG11
						;; bbWeight=1    PerfScore 1.25

G_M33664_IG06:              ;; offset=004BH
       4885F6               test     rsi, rsi
       7436                 je       SHORT G_M33664_IG07
       837E0808             cmp      dword ptr [rsi+8], 8
       7530                 jne      SHORT G_M33664_IG07
       C5FA6F460C           vmovdqu  xmm0, xmmword ptr [rsi+12]
       C5FA6F4E0C           vmovdqu  xmm1, xmmword ptr [rsi+12]
       C5F1EF0DC8000000     vpxor    xmm1, xmm1, xmmword ptr [reloc @github]
       C5F9EF05C0000000     vpxor    xmm0, xmm0, xmmword ptr [reloc @github]
       C5F1EBC0             vpor     xmm0, xmm1, xmm0
       C4E27917C0           vptest   xmm0, xmm0
       0F94C2               sete     dl
       0FB6D2               movzx    rdx, dl
       EB02                 jmp      SHORT G_M33664_IG08
						;; bbWeight=0.50 PerfScore 11.92

G_M33664_IG07:              ;; offset=0081H
       33D2                 xor      edx, edx
						;; bbWeight=0.50 PerfScore 0.12

G_M33664_IG08:              ;; offset=0083H
       85D2                 test     edx, edx
       7573                 jne      SHORT G_M33664_IG11
       4885F6               test     rsi, rsi
       7436                 je       SHORT G_M33664_IG09
       837E0808             cmp      dword ptr [rsi+8], 8
       7530                 jne      SHORT G_M33664_IG09
       C5FA6F460C           vmovdqu  xmm0, xmmword ptr [rsi+12]
       C5FA6F4E0C           vmovdqu  xmm1, xmmword ptr [rsi+12]
       C5F1EF0D9C000000     vpxor    xmm1, xmm1, xmmword ptr [reloc @github]
       C5F9EF0594000000     vpxor    xmm0, xmm0, xmmword ptr [reloc @github]
       C5F1EBC0             vpor     xmm0, xmm1, xmm0
       C4E27917C0           vptest   xmm0, xmm0
       0F94C2               sete     dl
       0FB6D2               movzx    rdx, dl
       EB02                 jmp      SHORT G_M33664_IG10
						;; bbWeight=0.50 PerfScore 12.54

G_M33664_IG09:              ;; offset=00BDH
       33D2                 xor      edx, edx
						;; bbWeight=0.50 PerfScore 0.12

G_M33664_IG10:              ;; offset=00BFH
       85D2                 test     edx, edx
       7532                 jne      SHORT G_M33664_IG11
       48BA805565D474010000 mov      rdx, 0x174D4655580      ; ""44444444""
       488B12               mov      rdx, gword ptr [rdx]
       488BCE               mov      rcx, rsi
       E8503EFEFF           call     System.String:<Equals>g__EqualsUnrolled_9_to_16|38_1(System.String,System.String):bool
       85C0                 test     eax, eax
       7519                 jne      SHORT G_M33664_IG11
       48BA885565D474010000 mov      rdx, 0x174D4655588      ; ""55555555""
       488B12               mov      rdx, gword ptr [rdx]
       488BCE               mov      rcx, rsi
       E8BF43FEFF           call     System.String:Equals(System.String,System.String):bool
       85C0                 test     eax, eax
       740B                 je       SHORT G_M33664_IG13
						;; bbWeight=0.50 PerfScore 5.38

G_M33664_IG11:              ;; offset=00F5H
       B801000000           mov      eax, 1
						;; bbWeight=0.50 PerfScore 0.12

G_M33664_IG12:              ;; offset=00FAH
       4883C420             add      rsp, 32
       5E                   pop      rsi
       C3                   ret      
						;; bbWeight=0.50 PerfScore 0.88

G_M33664_IG13:              ;; offset=0100H
       33C0                 xor      eax, eax
						;; bbWeight=0.50 PerfScore 0.12

G_M33664_IG14:              ;; offset=0102H
       4883C420             add      rsp, 32
       5E                   pop      rsi
       C3                   ret      
						;; bbWeight=0.50 PerfScore 0.88
RWD00  	dq	0031003100310031h, 0031003100310031h
RWD16  	dq	0032003200320032h, 0032003200320032h
RWD32  	dq	0033003300330033h, 0033003300330033h
; Total bytes of code: 264
```
so no budget for `s == ""55555555""

> Also, it would be interesting to measure JIT time of a method like this (before/after).

since it can't do 100 Equals I don't see anything terrible and in general I guess there are not so many, I also tested the test I added - no visible effects.

What is nice is that for non-unrollable cases jit ignores those calls as it is able to remove simple dead branches during import.

Any opinion on this? It feels great to be able to declare rules to unroll stuff in pure C# but yeah, several long equals can eat inliner's budget and we won't be able to inline other stuff in the current root.
"
"Suggestion: Could we make all these offsets consts into an internal shared class that everybody links so that we can see the ordering in one place? It might sounds stupid, but it's really hard to think about the ordering of the system when it's distributed across classes. I also understand that this is kind of unrelated and a nit."
Wow this is kinda gross 😄 
"Noob question, the server and client OS share the same version prefix, so is it possible that windows 10/11 catch up with server? Or are these number incremented verry rarely. Like not on every windows update, but as a product version."
Because I'm terrible at all the WPF stuff and didn't even realize I can do  `IsThreeState = false`? :)
Thanks for the remind. This one is about allowing the core markdown renderer to display `checkbox` which is sanitized by `insane`. I'll revert the change for now and see ppl's feedback.
wtf...
"## Friday Spec Brownbag Quick Summary
Today we had a meeting about this spec. Here's some quick notes of how the discussion went.
Attended: @github, @github, @github, @github, @github, @github    

### Launch Methods
- Unanimous ""launch inside the tab"", not a new window
- Matches other tabbed things like browsers
- New window will naturally come when we solve tab tear-off
- Launching settings another time will just activate the existing tab

### Preview Window in Appearance Page
- Unanimous yes. Do this. TermControl with a new connection that isn't real, just filled with some dummy sample text like what people might use (emojis, powerline fun, text tables, colors, etc.)

### Editing/Saving
- Automatic saving: No. We don't want to thrash the JSON file. If we had an in-memory model struct... maybe. Or if we were using a tear-off window, maybe.
- OK, Cancel, Apply and/or a ""Save"" button and a ""Preview Now"" button. No. Gross. Old. Maybe temporarily during the prototype so the person doing the prototype only has to write two event handlers. But no. The preview window should be automagic on changes. The actual JSON should be written on Save button
- Save button. Yes. Do this. Prevents JSON thrashing. We will have a little preview window anyway.

### Navigation
- Align with JSON: Ehhhhh. We could be more robust.
- More description navigation: Yes, do this. Unanimous.
    - ""General General"" is weird. We should find something else for that. General > Basic, General > (categories, like ""Launch"", ""Rendering"", ""Interactivity"", etc.)
		- We need a rocket ship icon for ""Launch""
    - It's ok to have few items on a page/category. Looked at some other ideas like how Visual Studio and some other Terminals like iTerm, xterm, etc. do it.


### Keyboard Bindings
- A listview sort of thing - Carlos and Kayla seemed more on board with this one up front.
- A grid sort of thing - Michael, Mike, Dustin seemed more on board with this one up front.

(I didn't catch which one Leon was up with)

- We don't think we have a readily available grid control
- Lots of comparison to iTerm, xterm, and other terminals to see what they do
- Examples given of other software that tends to do keybindings in a grid style
- Discussion on whether we should have some sort of modal dialog when adding a binding that lets people press a key-combo to make it instead of typing it out
- Discussion on combo/text boxes for the commands to be mapped
- Discussion on what to do with commands that have arguments
	- Commands with arguments that are already stringable by the command palette (e.g. new tab 1, new tab 2) are offered as drop down items
	- Commands with arguments that are complex could be presented with a ... in the grid on the edge that launches a modal with the raw JSON to be edited
		- Perhaps place the schema describing how to write conforming arguments/bindings on the left and have a text editor or JSON editor on the right
		- Validate schema on close, stitch the JSON fragment back in
		- In the future, can migrate some of the ...s to launch a more robust editor based on the situation of the type of command, but default will allow raw editing if there is no specialty editor

- For the listview, specifically discussing how we can show the arguments or have some sort of embedded arguments editing below it

- Concern with both of them about amount of whitespace/compactness and good use

- Concern with how to display/present the commands that people might not know about (easily buried in a dropdown/combo)

- Any way to tree/hierarchy/group the similar commands together? 
"
"OK, so after talking this one out with other ppl on the team, I believe this was a stupid suggestion on my side. 

IDEs ask for errors on files in no specific order. with this in place the error will keep appearing and disappearing randomly. i think we are better off having the error on every use. We already report errors on every use for decorators. so this should just be the same. I think we can just remove this check, and keep the error.

Sorry for the bad suggestion. "
"Maybe separately, we should do better on tuples since this is so stupid."
"I deleted the comment because we discussed it offline. To make you look less insane, I was asking why it wasn't called `getReferenceHighlights`.
"
"Tagging this ""needs design review"" for one concern about whether we want to be overloading go to _definition_ for this particular feature, since I don't think I would imagine this really correlates to a ""definition"" at all. We might be able to make some UI affordances to the user to help out what is going on (change the text of the right click menu to say ""go to control flow destination"" or something to that effect when you're actually on one of these tokens).

Also a few things that might be helpful:

1. Should invoking on return in a method jump to the invocation of that method if there's one, or show the selection if there's multiple? The local function case at least might be handy.
2. Should invoking throw jump to a catch block, at least if there's a matching one in the method? (The control flow analysis can of course get insane here but maybe the same-method case could still be useful....?) #Closed"
"~The GitHub app is terrible so I can't review properly, but test 5 uses a function type returning `void | undefined`. That's probably a mistake.~

Resolved"
"Yea, you could(should) definitely expose that method on AppKeyBindings. Parsing them again would be insane :P

I'd rather you do it in this PR, rather than blocking your PR on mine getting in"
"Thanks, @github 

I've just tried the sequence of [the above GIF](https://github.com/microsoft/terminal/pull/8215#issuecomment-729949956) in a PowerShell:

```ps
sleep 3;""^G""
```

Then quickly minimized the window and nothing happens. I.e. nothing flashing.

I'm using:

- German Windows 11, 64-bit
- PowerShell-Tab, run as Administrator
- Terminal Preview version 1.13.10984.0

Probably I'm just doing something stupid and/or missing some plain obvious things.

----------

Trying it from a [.NET console application](https://github.com/microsoft/terminal/issues/8713#issuecomment-756181568) with:

```c#
Console.Write(""\u001b[G"");
```

also does not flash the task bar icon.

-----------

OK, I think I get it now:

The [""BellStyle"" setting](https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-advanced#bell-notification-style) was not set explicitly, thus resulting in only a sound (which was not hearable since I turned of all system sounds).

After configuring the CMD type to this:

![image](https://user-images.githubusercontent.com/415439/169705439-7f6f2d25-f58a-4bbc-8814-22250398daa6.png)

My C# console application was able to make the task bar flash/be lightened when using this:

```c#
Console.Write(""\a"");
```

Resulting in this effect:

![image](https://user-images.githubusercontent.com/415439/169705615-949aeaff-d3fa-4f2f-8037-ced5fe4ecdca.png)


I'm still unable to do the same for PowerShell and `sleep3;""^G""` but since I do need it for CMD only, not PowerShell, this is sufficient for me.

----------------

### Update:

After reading [Dustin's reply](https://github.com/microsoft/terminal/pull/8215#issuecomment-1133933312), this one worked correctly in PowerShell:

```ps
sleep 3;[char]0x7
```"
"This is a really gross pattern.  Can we rename this to something like EnsureInitialized and not do the ref to a field thing?
"
"There is one ***huge*** issue with BigInteger as it stands currently, its default constructors.

The BigInt Class' constructors are all conversions to other datatypes making it inefficient and limited while BigInt *already* has a method coded in which uses *string* input **and is really what you should use when actually utilizing BigInt** called the `Parse()` method. The issue of the type conversion is *especially* magnetized for BigInt because of how it was intended for and why it was made, as the official microsoft documentation of BigInteger states (https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger?view=netcore-3.1)

> The BigInteger type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds. 

which is unlike every other type in the default constructor which means simply writing `System.numerics.BigInteger.new(10000000000000000000000000000);` **will not** work because you aren't explicitly trying to convert the number to the `double` datatype which also still has a max value, 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368, but it is large enough to handle most things, however, numbers will not get automatically converted to double type, they need to be explicitly defined with the ""d"" suffix like `10000000000000000000000000000d` but as double still has it's limits, this still goes against the purpose of Bignteger since as soon as you do `179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858369d` the double datatype will stop working. The biggest ""*inexplicitly defined type*"" would be the uLong type which has the highest value of a measly `18446744073709551615`. Since the constructor will always attempt to convert the number to a different type, as it stands it is 

1. Inefficient; tries to convert the arguments to another datatype and go through their constructors which also will cause longer computation times and    

2. Has limitations; it will not work when trying to define an actual ""arbitrarily large integer"" like tested  by multiple people in this Stack Overflow question (https://stackoverflow.com/questions/62974138/bigint-inconsistencies-in-powershell-and-c-sharp)

So these constructors go against how BigInt is supposed to be by design, a datatype for *arbitrarily large integers* and having numbers too big for the base constructor goes against what BigInt is supposed to be. However, BigInt *can* handle these ""arbitrarily large integers"" and *can* handle infinitely large things with the parse method. The `Parse()` method takes string arguments so it is theoretically infinite there and works properly. So why have that as just a method? Why not turn that into a constructor? Isn't that just stupid to not have it as a constructor if it literally satisfies what BigInt is supposed to be when as it currently stands does not? You already have all of the code for the `Parse()` method so why not just use it? Just copy + paste, anyone can do this! If the `Parse()` method *does* work as intended and how BigInt is supposed to be but the constructors can't, why wouldn't you just add the `Parse()` method as a constructor for string overloads?"
When can this fix be expected or is there a temporary workaround? Android user experience is terrible without this feature.
"We are now ignoring ""unknown"" errors. There are no tests for this, because these errors are unknown and therefor we don't know how to reproduce it, but we definitely should not be swallowing these.

Assuming `result.BytesTransferred` is 0 given an unkown error (which seems like a safe bet), then the error will get logged as a FIN which is terrible for debugging.

```suggestion
                    // This is unexpected.
                    error = result.SocketError;
                    SocketsLog.ConnectionError(_logger, this, error);
```"
"> This doesn't work in the case of refactorings at the start of a fiel :) (which do exist) :)

I don't follow.

> Can you point to what you mean?

Imagine [this](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-a2c30b83123c3cb46ac84dae8175bc4bR24) accepts null and we want to pass `null` [here](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-4b18194545a98c011598321cbfa1dd9fR68) (carries info ""didn't register specific TextSpan"") .  The `RegisterRefactoring` [just calls](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-4b18194545a98c011598321cbfa1dd9fL86) `_registerRefactoring` lambda with given parameters and so if we want to call it with `null` the [lambda](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-4b18194545a98c011598321cbfa1dd9fR30) needs to be of type `Action<CodeAction, TextSpan?>` (has to accept nullable `TextSpan`).

The lambda, however, isn't an implementation detail. It gets set in [*public* constructor](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-4b18194545a98c011598321cbfa1dd9fR52). And that leaks the information that the registration should somehow work with Nullable `applicableToSpan` 🤷‍♂️.

It's not terrible, nobody outside probably uses the constructor. But it _just feels weird_. Either have it nullable explicitly in `RegisterRefactoring` (but that communicates wrong idea about it being optional) or have it nowhere.

> Note: we [still support](https://github.com/dotnet/roslyn/pull/37777/commits/b82e2c2baa57fe50af62353e3a1470ca915dba2b#diff-4b18194545a98c011598321cbfa1dd9fR45) the original constructor without `TextSpan applicableToSpan` parameter 

"
">  There should be no need for shift. Ideally, we could just ""subtract"" the modifier key from the keybinding. But would that be a difficult behavior to explain/understand?

I'm worried that might not totally work. Think of an insane person, who definitely wants to be able to select text with WASD, and an _interesting_ set of modifiers:
```jsonc
// Cell Selection
{ ""keys"": [""shift+w""], ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""up"" } },
{ ""keys"": [""ctrl+a""],  ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""left"" } },
{ ""keys"": [""alt+s""],   ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""down"" } },
{ ""keys"": [""d""],       ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""right"" } },
```

You can't really ""subtract shift"" from those modifiers 😕 "
"**edit:** everything is working now, see https://github.com/microsoft/terminal/pull/10972#issuecomment-907345963

I took a pass at trying to get multi window saving working (didn't start on loading yet, which seems easier all things considered). The initial behavior that I started to implement was to just save the layout of all windows every `x` seconds and/or when the last window closes. 

Roughly the architecture/call stack as currently implemented is

monarch app host calls GetAllWindowLayouts -> propagate to monarch -> for each peasant call GetWindowLayout -> peasant triggers GetWindowLayoutRequested -> window manager -> app host handles event -> calls logic/page -> back up to peasant -> monarch returns back down to app host -> call logic to save in ApplicationState.

The WIP commit is https://github.com/microsoft/terminal/commit/fa54b144acd94e224535d671240d37f4bde8564c

I spend an excessive amount of time trying to get a stupid `hstring` returned up the chain to the peasant, before  finally giving in and making a managed class that just wraps a string.

Unfortunately, I hit a wall as soon as I got the monarch window working because I needed to make the event async to handle switching to/from the ui thread since peasants on everyone except the monarch have different threads. This comment sums up my current thoughts and tribulations
https://github.com/microsoft/terminal/commit/fa54b144acd94e224535d671240d37f4bde8564c#diff-d9af234d6dd21db9240dc3733d69471898a79f1c4386cb3c48ac45ab7158cd07R638

It is possible that after having looked at this for the last 8 hours I am getting tunnel vision and missing an easy answer, in which case I would love to hear it. Definitely open to ideas of other approaches."
"ok, I'm stupid, is a key, I can't parse english: 'The **value** of this **key**'. To the value if a double."
"It should be. I cherry picked the commit.

I didn't know about the forking and bots... I'm a noob with all this. Next time or should I create now?

https://github.com/xamarin/xamarin-macios/compare/d16-7...mattleibow/uri-fix"
"> python3 wtf.

+💯 

> Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?

cc @github @github "
"Would like a comment that this is test-only. I can imagine people doing really terrible things with this thinking this is a ""feature""."
(but then I apparently ignored the rest of your comment because I'm stupid)
"Yeah if it's a directory, I'd have like
`whitelist\everythingelse.txt`
`whitelist\names.txt`
`whitelist\t.txt`
`whitelist\n.txt`
`whitelist\r.txt`
`whitelist\README.md` <-- to explain WTF the files mean
or whatnot."
">uint options seems correct since a C# int is a C long, so a C# uint is a C unsigned long:

That is only true on Windows (i.e. C `long` is always 32-bits). On non-Windows the `long` is typically 32-bits on a 32-bit CPU and 64-bits on a 64-bit CPU. This is a terrible thing to discover so in .NET 6 we introduced [`CULong`](https://github.com/dotnet/runtime/pull/46401). A big thanks to @github for pushing on it.

The `string path` is correct."
"> Okay so
> 
> 1. this is insane
> 2. it adds 90 test cases, so that makes me 😄

255 now that I went through all of the positions 😉. AND I still need to add some for word navigation.

> 3. I don't really know powershell all that well, but the code seemed easy enough to follow, and was documented well enough that I wouldn't totally hate myself if I needed to add another case
> 4. this doesn't run automatically as part of the build, this has to be run manually. That definitely cuts down on some of the complexity, which is good. IMO generating the tests automagically as part of the build just ain't worth it.

Yeah, and we're not really changing these tests all the time. I did just add a ""nice to have"" where it all goes to a .g.cpp file though. So this process is now so much easier!

> 5. I'm not really going to inspect the veracity of the tests themselves. I'm gonna trust that you've done your diligence here. Manually inspecting 90 test cases probably isn't worth the time. Skimming them, they seem like they make sense.
> 6. There's a _lot_ of skipped tests, so helpfully we can fix those soon. Presumably, those are the ones that are failing currently. How did we come up with the test cases that are failing currently but shouldn't be? Just logically working out what they _should_ be doing? Was there some sort of reference app that you used to construct these cases? (this is merely a curiosity)

Updated the README to talk a bit more about this, actually. There's kinda two types of tests that we're skipping for now:
1. we're wrong: I used MS Word to test what the behavior should be and added them to the CSV file as `skip=false`. Then, when they fail in TAEF, I double check that I translated MS Word correctly.
2. for #6986: we'll need _a lot_ of tests to make sure this works correctly. The idea here is that anything past the ""document end"" will be treated as a degenerate range at document end. So this is gonna be a really nice transition where I'll just update the CSV appropriately and generate/run the tests."
"Oh, because I ran `git merge` without actually telling it what ref to merge. WTF?"
"diff is terrible, but this code is almsot the same.  Generally the logic is similar to: if we have an initializer like `var = new X()` leave it alone (we know the type of it). If we have `X x = new()` change that to `new X()`.  Otherwise, insert an explicit cast from the expression to the final local type.  This ensures the expr keeps the same meaning and affects code the same way in all the places it is inlined to."
"aaaa I've not noticed that it was a `ref` project, sorry for stupid question"
"OK, I found the problem -- I'm stupid, I forgot that the pull request that referenced this package hasn't been merged yet.
"
"@github Comments from @github were only some renaming of tests and spacing, and discussion on certain doc comments. I tried to edit them from mobile, but hit the wrong buttons (it's really quite tricky to delete one line in a file).

He has some other concerns about the api, but I'd think we shouldn't revisit the api right now. Could you resolve any open stuff please? It's terrible to do from mobile ;). "
Shit. I guess I cannot pick this up...
"Ah, crap, I forgot to fix this in the regular job. Will go do that now"
"This doesn't seem like a terrible idea, though are you cool if we punt that for the v1 at least? That seems like refactoring we could come back through on a second pass and do 🤔 "
"Better than what we have now I suppose. Kinda gross to have 4, but it is what it is."
"Main's corelib is 9.63 Mb (R2R'd)

- `ExtendedDefaultPolicy` without taking PGO into account: 9.83 Mb
- `ExtendedDefaultPolicy` with PGO `JitExtDefaultPolicyProfTrust=10`: 10.10 Mb
- `ExtendedDefaultPolicy` with PGO `JitExtDefaultPolicyProfTrust=0`: 10.17 Mb

`JitExtDefaultPolicyProfTrust=10` means we're fine that inliner won't inline anything in cold blocks (call-sites with real profiles)
`JitExtDefaultPolicyProfTrust=0` means it doesn't affect the BenefitMultiplier anyhow for cold blocks (so we still can inline calls in them). By default, I use `5` as a balance.

Here is the jit-diff (PMI mode) without taking PGO into account: https://gist.github.com/EgorBo/8e44063324ec21ba29c636a79d7e871c

### Improvements
Most of the size improvements come from ""don't inline anything in BBJ_THROW blocks"", e.g.:
```csharp
if (x == null)
    throw new ArgumentNullException(SR.InvalidArgument); // get_InvalidArgument() is inlined here
```
both `ArgumentNullException.ctor` and `get_InvalidArgument` aren't inlined anymore. A good example is  `LowLevelLifoSemaphore:ReleaseCore(int):this` diff: https://www.diffchecker.com/Wlfl2Lde
***
There are some interesting examples where inlining leads to smaller size, e.g. 
```csharp
static GCHandle Test(object? value) => GCHandle.Alloc(value);
```
Diff: https://www.diffchecker.com/kCYnyUge
^ Inliner managed to detect foldable branches in the `GCHandle`'s constructor and inlined it, see [here](https://github.com/dotnet/runtime/blob/fc4a42746d9cf65ad3db4074207069ab9c168bc9/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/GCHandle.cs#L62) and its [ctor](https://github.com/dotnet/runtime/blob/fc4a42746d9cf65ad3db4074207069ab9c168bc9/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/GCHandle.cs#L32-L54).
***
Another example - it's now able to inline `string.Equals` when we compare literals, e.g. `if (strArg.Length == 0)` is recognized as a foldable branch due to the fact we can now recognize 'get_Length' call, example:
```csharp
bool foo(string str) => str == ""hello"";

bool test() => foo(""hello"");
```
Diff for `test`: https://www.diffchecker.com/vPVxpDl1
***
There are some diffs due to PMI trying to instantiate `Vector<T>` with unsupported T (e.g. char) and inliner helpes here too, e.g. https://www.diffchecker.com/ElRZpnyh
***
`GC:AllocateArray(int,bool):ref` is smaller after inlining: https://www.diffchecker.com/AZKH3aiG
***
Same for `ASCIIUtility:NarrowUtf16ToAscii(long,long,long):long`: https://www.diffchecker.com/yS7ttpfS
***
Same for `HillClimbing:GetWaveComponent` https://www.diffchecker.com/iXaeRtBj
***
Same for `DiyFp:GetBoundaries(int,byref,byref):this` https://www.diffchecker.com/jkjH7mRo
***
Same for `Task:GetActiveTaskFromId(int):Task` https://www.diffchecker.com/7o91kyyE
***
Misc: https://www.diffchecker.com/olDdSxqM, https://www.diffchecker.com/XddHJSrd, https://www.diffchecker.com/3I81EWAo
***
There are cases where ExtendedDefaultPolicy doesn't inline what was inlined by the previous inliner - I tried to avoid it, but there were cases where I'm not sure we should inline, e.g this call https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/IO/Directory.cs#L63 is inlined despite being quite complex: https://github.com/dotnet/runtime/blob/main/src/libraries/Common/src/System/IO/FileSystem.Attributes.Windows.cs#L25-L35
Old inliner detected here ""arg feeds const test"" and added a big multiplier. It did so because IL scan was not quite accurate and had many false positives. However, this method will still be inlined with PGO (and I am sure we have one for this in the static profile we ship). **UPD** I slightly added some boost in https://github.com/dotnet/runtime/pull/52708/commits/05a19e57d879bf9ba9d271a7bfb8efeb2b97c58c.

## Size regressions
These are the cases where inlining increases the size but hopefully for better performance.
```
        2846 (357.54% of base) : System.Private.CoreLib.dasm - Array:Sort(Array,Array,int,int,IComparer)
```
InlineTree diff: https://www.diffchecker.com/nEAcbTWc It decided to inline `ArraySortHelper.IntrospectiveSort` here (e.g. because of ""non-generic code calls generic"").
***
```
1483 (131.71% of base) : System.Private.CoreLib.dasm - Guid:TryFormat(Span`1,byref,ReadOnlySpan`1):bool:this
```
Diff https://www.diffchecker.com/KgWTWBug - it inlined all `HexToChars` calls.
***
```
        1248 (56.12% of base) : System.Private.CoreLib.dasm - Task`1:ContinueWith(Func`2,TaskScheduler,CancellationToken,int):Task`1:this (8 methods)
```
Diff https://www.diffchecker.com/Y26QhTNV, explanation: [sharplab.io](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwFgAoAAQAYACUgRgFYBuEk0gZmoCZKBhSgbxKUhlQcLbUk3CADsM2aQFcAhnJkB5AA6rpAZ0oBZGgApSkmXMUrs6rdd2UIASn7Niw95QD0nygCUIOrgAntKUACYQMDrSAOQYlABmELhhlBgAFlEwabDZCbhKAOY6oh5ePjoQaZmUAJLSuPIwUJQ6MFGUAERJKUrAuNkwCBqwOjp2Op2lHt51lNLtqRhVCdgIdQ1NLcuUsJCF0tgAXtndyWF9A5RDI1HjMpMODUHT7rMA7pmhkLoYcEpQQqUAHZeQAN2SYJgYQAdK8xAB2ByUfAiNxlDFCUxSWTyZTaTTaHQwgByEAwamk3CU0jAMAGqSI6MxZWx5jxVhsRNJ5MpADElApcBhoSj4SyJDiLPi7ISJjyKdJfDSACoQKQAWw0A20TGZlAAvtNjfrxGzcZYCbYHgYOCYzBaZVyJg5nAJiOLyn4AsFQhEOj0lpk2jl2okCsVPaQkZ7MebpZzpHKHgrKdTafTRUyJayHQmrdyyYqBUKRYzYxj4xyC/Ki5TldI1ZrtTBtCiHHr3EbiAagA==)
***
Overall I don't see anything terribly wrong so far (e.g. terrible spills because of too-many-locals), I spent the whole week on fixing the regressions and now it's more or less fine.
Performance benefits aren't as good as they used to be with a way more aggressive inliner but I'm going to investigate what exactly led to such improvements and send separate PRs. At least currently I don't see any impact on ""time to first request"", I'll publish the first results once my [script](https://gist.github.com/EgorBo/a1ab453bf41a5369aa54b4c4fba6bea5) finishes.

@github you can pick any method from the jit-diff and I'll explain with the diffs what exactly happened."
gross. Can we think of better ways to organise and name this functionality?
this seems like pretty gross overkill :D
"> Time: 33.520s
> Time: 40.564s

> I would consider keeping this test as `OuterLoop` considering that the test above, `VeryLargeAmountOfEnumsToSerialize`, which uses a similar code minus the insane amount of dictionary instances, is already signaled to run on `OuterLoop`.

Agreed. That sounds good.
"
"> Still, I need to destroy the old grid, right?

Correct, though all the views' DOM nodes would be reused: they would just be reparented.

> Also, today, I don't really have call layout on the whole grid when moving things around. The code is a bit gross, but the grid seems to handle calling layout on the appropriate things so there are no issues. However it seems like I would have to call a top-level layout every time a part moves with this approach. Is that not more expensive?

No need to call layout when the inside of the grid changes. The contract with layout is: you call it when the size (or position) of the entire grid box changes."
"this was to appease github, which shows a terrible diff otherwise :'("
"Yeah, just the first time. I was mirroring the existing ""Enter outlining mode when files open"", though granted I think thats terrible wording too :)"
"> The first change adds CNS_INT long 0 Fseq[_00] for source field in the field by field assignments even when offset is 0.

Hmm, I suspect that the ""proper"" way to do this is to add the address to the ""zero offset field map"". But then I happen to think that this kind of side maps are a terrible idea and that the it's best to keep this information in the IR, in special nodes - `PTR_FLD` and `PTR_IDX`. Basically `LEA`s with field sequences but without suffering from `LEA`s unary/binary split personality disorder. `ADD(x, 0)` should do, with some extra special cases. Haven't checked the actual changes yet but I suppose you may want to make such nodes non-CSE, 0-size/execution cost, 0-level in eval order etc.

> Optimize ADD(val, 0) in lower.

Maybe this will also fix 13548?"
"""Node"" is a pretty terrible name :)   i was very confused here :) #WontFix"
that's insane.. there should be a warning comment before every single local function?
"Yeah this is a terrible hack. I think I'll open another PR first where I rename `SetDefaultTextBackgroundOpacity` into something like ""UseAlphaForBackground(bool)"" or something. This change is needed, because this only works in `DxEngine` due to random chance and depends on the fact that DxEngine defaults to ClearType, which AtlasEngine can't yet."
"Urgh. Yeah, so there's 2 parts here:

## anchorMode: Toggle
I think where this spec stands, this is fine? You can just use your `moveSelectionAnchor` keybindings normally.

## anchorMode: Hold
The main idea behind ConHost CMD Mark Mode is basically that as long as <kbd>shift</kbd> is held, the 'start' endpoint is static/frozen/held.

> I'm worried that might not totally work. Think of an insane person, who definitely wants to be able to select text with WASD, and an _interesting_ set of modifiers:
> 
> ```js
> // Cell Selection
> { ""keys"": [""shift+w""], ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""up"" } },
> { ""keys"": [""ctrl+a""],  ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""left"" } },
> { ""keys"": [""alt+s""],   ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""down"" } },
> { ""keys"": [""d""],       ""command"": { ""action"": ""moveSelectionPoint"", ""direction"": ""right"" } },
> ```
> 
> You can't really ""subtract shift"" from those modifiers 😕

So, with the logic above, the scenario above might still be acceptable?

| Direction | Move 'start' | Move 'end' |
|--|--|--|
| Up | <kbd>w</kbd> | <kbd>shift+w</kbd> |
| Left | <kbd>ctrl+a</kbd> | <kbd>shift+ctrl+a</kbd> |
| Down | <kbd>alt+s</kbd> | <kbd>shift+alt+s</kbd> |
| Right | <kbd>d</kbd> | <kbd>shift+d</kbd> |

## Alternative Plan
Alternatively, I feel like the safest option would be to have users specifically define controls in Mark Mode vs keyboard selection. I think that might be the _clearest_ way to fix the problem above, but I feel like there's a lot of repeated keybindings set between mark mode and non-mark mode ones. :/

## Alternative Alternative Plan
We could remove the ""anchorMode: Hold"". But then there's no way to replicate a _similar_ behavior to that of ConHost CMD. :( I also think the concept of ""hold"" is still a good one, but the execution is the tough part ugh"
"ditto, stupid manuel"
"Sorry, didn't see this. GitHub mobile does a terrible job of notifications :)

The elastic annotation is added by `SyntaxFactory.Token` which is called from the separated list constructor, so avoiding that by preserving the existing comma tokens solves this, and is much easier to boot."
Unrelated to this PR but wtf. @github @github can we fix this?
"UI code depending on synchronous parsing makes me sad.   might not be terrible to do this async, and pop in the checkmark when we know... (but that would add a lot of async compexity to these codepaths)."
hello vs code wakeup and merge this. your stupid ctrl f behavior is so annoying
"*Draft release notes*

No terrible hurry on this while this PR is still under active revision, but if I understand correctly, I think once this PR is eventually merged it will enable OpenJDK 11 compatibility for user builds? If that's correct, then it might be appropriate to add release note to `Documentation/release-notes/4567.md` as part of this PR.

Here's a very rough first draft of one possible idea:

```
### OpenJDK 11 build compatibility

The Xamarin.Android build tasks are now compatible with OpenJDK 11.

The primary motivation for this change is that the current preview Android SDK
Build-Tools version 30 rc4 that aligns with the Android 11 Developer Preview
requires JDK 9 or higher to run.

Project authors who are not yet targeting the Android 11 Developer Preview can
continue to use OpenJDK 8.
```

On the other hand, this PR itself might not need a release note, if for example the Visual Studio installer will be updated to provide OpenJDK 11 by default in the same release where OpenJDK 11 compatibility ships. In that case, the main topic in the release notes can be the new default OpenJDK version.

In either case, there will likely be some docs to update, such as: <https://docs.microsoft.com/xamarin/android/troubleshooting/questions/jdk9-errors>"
"@github: How insane would it be to build `Mono.Android.dll` ""separately"" for the Android Designer, so that we can `#if` out this logic for on-device use but leave it in for the Designer?

Alternatively, What If™ we moved the logic into a new method, then *removed* that method via the linker when linking apps?"
Well at least I deterministically am terrible at spelling
"I'd disagree here: I think there's a beauty to the test classes being self contained. Otherwise we end up with insane inheritance hierarchies that only make what the code is doing _less_ clear. Duplicated code isn't bad; complexity is.

I am curious though why each test has to call .Initialize()...?
"
"@github stupid question, does it run the tree targets all the time? i.e. it would not considered passed until the test passed on the three targets? if so i would keep it to two if we can.
"
"I don't think the original issue was so terrible. You only ran into this case when you were contextually typed by a type with a string literal constituent to begin with. In practice, this is not frequently encountered.

However, @github, I think you'll like the the current implementation a lot better. We now only create a string literal type if the constituent types have a string literal type, not just if their content is equal.

Furthermore, the types are cached in a map of strings to string literal types. Whenever testing the assignability of two string literal types, reference equality kicks in (which is fast).

Additionally, error messages are slightly better because you have a specific literal type to report (i.e. `Type '""Foo""' is not assignable to '""Bar""'.` instead of `Type 'string' is not assignable to '""Bar""'.`).
"
"@github I saw this was done for ObservableItemTemplateCollection for Windows, so I copied that. Mainly just for the dispatcher, but if we pass the view in, then we never have to worry about reaching out into the Application. or Device. worlds.

Not sure if this is going to do terrible things with lifetime and/or memory. If so, we can change and find another way."
"this seems like a terrible idea.  why not just compare to ```== ""7.1""``` #Resolved"
"> Can we unify these codepaths?

~I tried, but I couldn't come up with a good solution. I tried:~

1. ~Take a SyntaxNode from the method to remove from the candidates~

```CS
RemoveConstructorWithDiagnosticFromCandidates(
            SyntaxNode nodeInMethodToRemoveFromCandidates,
            ImmutableArray<IMethodSymbol> candidates,
            CancellationToken cancellationToken)
```
~This does not work, because in VB you need go to the parent of the declaration and call `contains` on it:~
~`syntaxReference.GetSyntax(cancellationToken)?.Parent?.Contains(nodeInMethodToRemoveFromCandidates) == true)`~

~while in C# the method body is included (and calling `Parent` give you the whole type):~

~`syntaxReference.GetSyntax(cancellationToken)?.Contains(nodeInMethodToRemoveFromCandidates) == true)`~

2. ~Take the IMethodSymbol of the candidate to remove~
```CS
RemoveConstructorWithDiagnosticFromCandidates(
            IMethodSymbol methodToRemove,
            ImmutableArray<IMethodSymbol> candidates)
{
  return (methodToRemove.MethodKind == MethodKind.Constructor)
    ? candidates.Remove(methodToRemove)
    : candidates;
}
```

~Now the whole method has degenerated and also the `RegisterFixData` type needs a new property `MethodToRemove` (making the type somewhat stupid having the properties `MethodCandidates` and `MethodToRemove` :dizzy_face:).~

~Both attempts complicate things and that's why I would prefer to keep the two code paths separated. But maybe you have another idea on how to solve this problem.~

See 269a68c for how I solved it."
holy crap. since this gets called on destruction please write a huge comment in here to say **DO NOT INTERACT WITH THE CONTROLCORE AFTER THIS LINE** because it could have gone into the background after the destructor!
"It's not terrible; it's not great.  I have no suggestions.

Fortunately it isn't public API..."
"I'm stupid, went to fast :/ "
"Yeah there is an interesting push and pull in this sort of thing. You can make the syntax to disable things as gross as possible to disincentivize disabling, on the other hand you might accept that disabling things is a fact of life and it shouldn't look like an atrocity.

This is a good example of what I was mentioning to @github as far as how I only fixed the easy 80-90% cases as the rest that require non-trivial rewrites will generate some amount of discussion on whether we feel some particular situation warrants an exception. 

My opinion is just make the change to satisfy the linter. While I see the argument for the 'define as close to usage as possible' it's not hard to use GoToDef occasionally vs adding gross comments.
"
"> Your code is also missing one important point: you're only propagating the new direct references. If A -> B and C -> D, and I'm adding B -> C, then you need to get D added too. My first loop computes you need to include D, also accounting for the fact we might not know C's transitive references and thus instead need to propagate ""we don't know"".

Ack.  That feeling when you realize you're an idiot :D  "
item3 is a pretty terrible name.  it also seems incorrect given that Item3 looks to be a DeclarationExpressionSyntax.  Name tuple properties are a good thing :)
"Yeah, I need to figure out better wrapping. That said, they all look terrible."
"The above one, the lambda-ness of it is getting insane. There are so many ({{({()})}}}) that I think it will lead to mistakes and issues more than separating out the method. You should prescribe a separate method if possible at this point."
"Base time running `dotnet build /t:test`: 
```
=== TEST EXECUTION SUMMARY ===
    System.Text.Json.Tests  Total: 8715, Errors: 0, Failed: 0, Skipped: 0, Time: 33.520s
```

Time running after adding this new test:
```
=== TEST EXECUTION SUMMARY ===
    System.Text.Json.Tests  Total: 8716, Errors: 0, Failed: 0, Skipped: 0, Time: 40.564s
```

@github I would consider keeping this test as `OuterLoop` considering that the test above, `VeryLargeAmountOfEnumsToSerialize`, which uses a similar code minus the insane amount of dictionary instances, is 
 already signaled to run on `OuterLoop`."
"holy crap, this is what does the LRU magic"
"* [ ] How are we lanning on dealing with the numerous TabView quirks in v2? Just ship it as-is and fix in post? Or manually adjust the styling now?
  * [ ] EX the close button hover is weirdly wide
  * [ ] the tab text is bold
* [x] Icons throughout the app are still on the Segoe MDL2, not Segoe Fluent
* [x] Tab color picker looks fine
* [x] Tab renamer looks fine (if maybe needs a little padding...)
* [x] Window Renamer / ID toast looks fine
* [x] About looks... Fine? The links aren't underlined anymore, but that might just be how WinUI works these days
* [x] `InfoBar`s look totally ~~insane~~ transparent 
![image](https://user-images.githubusercontent.com/18356694/150855256-0a74ccc0-24b1-4125-9e10-589e31a03522.png)
"
"I'm stupid, that should have been and #endif but is better with the NoXYZ attrs"
"Please excuse me if this is a stupid question, but why can't you just call the `copy_file_range` method here?"
"Build what? Oh crap, I had built it from VS and it worked. I will take a look soon. 😥"
"That's fair, it could be made internal but it feels a little gross since users can new it up and use it in their own factory. Though that's gross as well."
"Crap - you're right... I didn't even think about that... yeah - that won't work. I'll try, but I'm pretty sure you're right."
gross
"Hi! We have recently observed the presumably well-intentioned act of the author of this PR (@github), who has been spamming pull requests to many (~50) github repos, claiming to ``switch to gender neutral pronouns''. In reality, the bot performs a dictionary replace of gendered nouns and pronouns, and the outcome is questionable at best, and literally harmful at worst. See:
- The bot did a terrible job at replacing these words - [EbookFoundation/free-programming-books#6801](https://github.com/EbookFoundation/free-programming-books/pull/6801/commits/5257301642c173e2dc4f034f8c0460ce7ea99de6)
- The code fails to compile at [rust-lang/rust#95508](https://github.com/rust-lang/rust/pull/95508)
- The bot ignores all context whatsoever at [moby/moby#43441](https://github.com/moby/moby/pull/43441)
- After initial PR being closed, the bot keeps sending PRs, effectly spamming the repos. For example, these 5 PRs were sent to the same repo within 2 days [#1](https://github.com/996icu/996.ICU/pull/26073) [#2](https://github.com/996icu/996.ICU/pull/26074) [#3](https://github.com/996icu/996.ICU/pull/26075) [#4](https://github.com/996icu/996.ICU/pull/26076) [#5](https://github.com/996icu/996.ICU/pull/26077)

To save more time for the open-source community, we recommend the maintainers of VSCode to close this PR and ban this bot from further spamming."
Ignore failure due to https://github.com/xamarin/maccore/issues/2440 (AKA I'm an idiot)
i am a stupid person. typescript is garbage. Bill should be fired.
Changed back for now and put all the gross casting code back
"> Applies the technique from dotnet/runtime#35330 to IOQueue.

I was thinking about it too :D

The other (and most probably a **very stupid**) idea I had was to try to have a scheduler that in the ctor would use reflection to access the internal field of ThreadPool that stores the work items in a `ConcurrentQueue`:

https://github.com/dotnet/runtime/blob/ec2209e7360cfae481c9f6df8540dccadb02dcb4/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L403

and implement the `Schedule` method as a simple call to enqueue of this CQ

Again, this is a very dirty idea ;)"
"> The logging is _insane_; is any of that detail useful❔

I turned it on hoping it would be useful, but either it contains nothing for us or I don't know how to find the useful information in it. We should probably turn it off at this point."
"> We discussed this with @github. It seems there it would be useful to have re-considering this parsing but not for now.

Pity.  That parsing is truly terrible :)   I'll put it on my backburner to see if there's a way to improve things."
"stupid me, again
"
"wait, we definitely can't put `.bat` or `.cmd`'s in here directly - 

holy shit _what_, you can `CreateProcess(foo.bat)` and it works? That's insane.

"
"I agree on [Sealed].

I was tempted to make a less terrible version, but there are two other ""copies"" of PresentError in appkit.cs and I wasn't sure what's worse:
- Three identical (on different classes) versions of the same bad API.
- Two bad versions of the same API and one good one.

In either case, I can work on a XAMCORE_4_0 version for at least two, and do something (either match or be different) w\ this new one.
"
"@github - This is intended to optimize lab runs where we need to run build-test several times with limited sets of steps (e.g. native component build takes place on a different machine than managed component build and the layout gets generated on yet another machine in the lab pipeline) and Bruce noticed that we're unnecessarily duplicating some steps in such scenario. You're right that removing crossgenning of framework from ""generatelayoutonly"" is a breaking change, I'll fix that. Frankly speaking, the command-line syntax of build-test is a terrible mess with its arbitrary combination of exclusive (skip***) and inclusive (***only) commands."
"> Mono should change their formatter configuration if they don't want the includes sorted. Otherwise there's no way to enforce formatting.

How do I do that?  I'm an .editorconfig noob"
Gross 
"No, because everything is terrible and on fire and also very very sad.

The comment at `ManagedCompiler.HasToolBeenOverridden` explains a bit of it - msbuild calls into these members really randomly, and one has to be extremely careful to not accidentally hit a recursion loop.

(I documented this a bit more, too)"
"omg, this order is terrible."
Noob question - why is this task returning (vs ValueTask returning)?
"`marked`'s `sanitize` is also deprecated, so not sure if it makes sense to rely on it (especially since we have the non-deprecated `insane`. 

I'm also very curious about why we're already letting `iframe` through `insane`

Makes sense to be worried about `style` if it can be used to execute. What about being super restrictive like this? Allowing colors is really the only goal here.
```typescript
	markedOptions.sanitizer = (html: string): string => {
		const permitted = /^<span style=\""(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?\"">[^<>]+<\/\s*span>$/;
		const match = html.match(permitted);
		return match ? html : '';
	};
```"
"> Hmm, I suspect that the ""proper"" way to do this is to add the address to the ""zero offset field map"". But then I happen to think that this kind of side maps are a terrible idea and that the it's best to keep this information in the IR, in special nodes - PTR_FLD and PTR_IDX.

I have checked how it works with ""zero offset field map"" and you are right, overall results are better.
`fgAddFieldSeqForZeroOffset(tlsRef, fieldSeq);` has almost all logic that we need, we just not calling it sometimes.

The only downside is that `optAssertionIsNonNull` now cannot understand that it doesn't need a null check in cases like:
```
-A-X----R---              |  \--*  ASG       ref    <l:$22a, c:$229>
D------N----              |     +--*  LCL_VAR   ref    V20 tmp15        d:2 <l:$227, c:$155>
---X--------              |     \--*  IND       ref    <l:$22a, c:$229>
------------              |        \--*  LCL_VAR   byref  V25 tmp20        u:2 Zero Fseq[Syntax] $441
---X--------              \--*  COMMA     void   $580
---X--------                 +--*  IND       int    <l:$34b, c:$34a>
-------N----                 |  \--*  ADD       byref  $442
------------                 |     +--*  LCL_VAR   byref  V25 tmp20        u:2 $440
------------                 |     \--*  CNS_INT   long   8 
```
The first indirection is done on `LCL_VAR   byref  V25 tmp20        u:2 Zero Fseq[Syntax] $441`, the second on ` LCL_VAR   byref  V25 tmp20        u:2 $440` and after the change they have different VNs, so too hard for `optAssertionIsNonNull`. Probably that behaviour is responsible for other uneccessary null checks, I will look for an exisitng issue tomorrow.
When we had add we skipped it in `optAssertionProp_Ind`:
```
    // Check for add of a constant.
    GenTree* op1 = tree->AsIndir()->Addr();
    while ((op1->gtOper == GT_ADD) && (op1->AsOp()->gtOp2->gtOper == GT_CNS_INT))
    {
        op1 = op1->AsOp()->gtOp1;
    }
```

It is almost 3am, but my brain says that `Fseq` should not affect VN of `LCL_VAR ` (because it is a pointer type, not a real value), but should affect `IND` node on top of it. Does it make sense?"
"Oh, I'm too stupid to read IL properly :wink: (realized that this was wrong when I come back in the office -- too late).
Thanks. I'd liked the explicit version better anyway."
"> @github, do you recall whether we still use these for anything or can they be safely removed? Context [here](https://github.com/dotnet/aspnetcore/blob/master/src/Razor/Microsoft.AspNetCore.Razor.Language/src/RazorProjectEngine.cs#L160)

Hmmm you can validate to see if they're consumed at all in the Mvc 1_x / 2_x projects: https://github.com/dotnet/aspnetcore/tree/master/src/Razor/Microsoft.AspNetCore.Mvc.Razor.Extensions.Version1_X



> @github, this was obsoleted around April 2019. Can we safely remove it now but do you think we should wait for another release? I'm not sure if this is something customers will be depending on.

Actually I think I was stupid for obsoleting this at all. I'd actually say it's probably worth ""unobsoleting"" it. There's still value."
Cause I'm still a noob with Visual Studio code. 
"> I'm not the most qualified to review this PR, but it does make sorta sense to me.
> I hope others find time to review it as well.
> 
> Finally I'm not entirely happy with `_getAttrVerificationFn`. The `std::function` will always allocate on the heap which is slow in a non-GC language like C++.
> I convinced it would've been more ergonomic to call it directly in the loop and have it switch through the `switch (attributeId)` every time. Since `attributeId` is constant a modern CPU would have the easiest time of its life to predict the correct switch case.

I would also prefer if it was a little less alloc-happy... but we need to give Carlos a good suggestion then, @github. I think the C-style way of declaring the methods is probably too gross (though it would avoid this.) Could we pass some static refs to these functions so they're only allocated once? Or hold them in a map? Or would holding onto them be a waste of memory long term?"
"> Native AssemblyLoadContext is not a native representation of the managed one, it just has a link to the managed, and can provide it via GetManagedAssemblyLoadContext

True, but for all intents and purposes `AssemblyLoadContext`-native has 1:1 relationship with `AssemblyLoadContext`-managed. The native one has a pointer to the managed one (and vice versa). Also all of the functionality of managed ALC is implemented (indirectly) in the native ALC (lot of this is hidden in the `ApplicationContext` which is embeded in the native ALC - and yes - that name is TERRIBLE and has to go :-), but that's a different refactoring)"
"Yah, string enums don't merge across files, while you can make an interface that does (via module augmentation). Downside is you have to use _assignments_ to actually create the value side. Terrible, I know."
"> I'm curious if aligned REP STOS measurably pays off (both for 16 and for 32 byte alignments).

I'm assuming it will be better than current, looking at Agner Fog instruction tables; for aligned Vector is definitely better, but I'd guess it hits instruction decoding costs when you have a large number of them + code size/icache.

For unaligned REP STOS looks terrible by comparison, whereas aligned to 32 bytes is same throughput as `ymm` movs?

![image](https://user-images.githubusercontent.com/1142958/74896839-31d8b000-538d-11ea-8386-adb8b4fab03f.png)

---

Thinking on the vector latency of 3 clocks; and perhaps same for `REP STOS`; methods seem to start using the highest stack values first, whereas current am clearing the highest values last. Might it make sense to reverse the clearing order?

Also would `REP STOS` be happy with a negative count so it goes backwards also?"
This is really kinda gross. I think we need to have some discussion before making a change like this. I don't want to see us keep evolving our testing strategy without careful consideration.
"Again - does this need `async/await`?  I'm terrible with the rules for lambdas.
"
"> How many strings are we talking about if we split them out. Unless it's insane, I'd recommend doing that and eliminating even having to worry about this.

It will end up at about 4ish resources per construct we want to support.  Not something really problematic.

Thanks @github and @github !"
"I wanted to avoid ""Rename"" terminology to leave it open ended for things like file addition or movement. While moving a file _is_ a rename as far as full path is concerned, it's harder to convey that information. Maybe if we move to a service it could be `IDocumentContentPolicyEnforcer` (terrible name, but gets my point across) 

```c# 
public interface IDocumentContentPolicyEnforcer
{
    Task<bool> TryApplyPolicy(DocumentId documentId, Document oldDocument, CancellationToken cancellationToken = CancellationToken.None) 
}
```"
Feels a little gross with it being just in the root namespace and not putting it lower like `::Microsoft::Terminal::CommandlineArgs` or something... but if we want to leave it here since `TerminalApp` was a bare one anyway... I'm not going to complain that hard.
"> That's a shame. I used to like having the panel and side bar next to each other with the code pushed all the way left.

So @github let me get this right - you have ""improved"" the code by removing functionality that a lot of users (including me) were happy with? For ... reasons? Thanks 🙄 Who exactly came to the unilateral decisions that the terminal can only be on the side opposite the file browser? wtf

Sometimes I wish MS could just leave the thing alone, I am happy with the way it works, why constantly ""enhance"" it and confuse your users... we got work to do. I guess I'll now go and spend a couple of hours of my time reading up on what the shiny new ""Side Panel"" behaviour and ""Terminal Editors"" are... 😡 

EDIT: I have read up on panels and terminal editors... it's an over complicated mess. Why have two different abstractions that do the same thing. Why force the users to get involved in understanding those concepts and configuring them. Basically you are trying to recreate Eclipse. Jesus. I miss the days when VSCode Just Worked"
this remains gloriously insane.
"> This is, unfortunately, how `enum` types work. There can only be one active value, unless you do explicit work to make it support multiple values.

Well, TIL I am stupid. Sorry, for wasting your time. 

Fixing code soon™"
"@github reordering them would certainly be a better choice, but it isn't trivial for me, as I'm no expert in the details of how the JIT really works. As the reverse p/invoke is added to the prolog/epilog in the flowgraph stage, and the inlined call frame logic is handled during lower; however, I'm not comfortable making such a change myself, as the fix looked to be more involved than I was prepared to handle, and prolog/epilog code is notoriously fussy to get right. That said, if this gets checked in in the current state, I'll open an issue against the JIT team to look at coming up with the more optimal fix. I've been able to get this to reproduce reliably by running the determinism test in a loop under jitstress1 mode, so verifying a more complex fix is not a difficult task.

@github Rare is possibly the wrong word.... possibly, less common would be a better term. There are certainly scenarios in which the reverse pinvoke to pinvoke logic is in the same function, but I don't see that its all THAT common. (Also, the penalty from using the helper functions isn't terrible.) I'm pretty sure that we don't have significant test coverage of this scenario in our test beds as the characteristic assertion messages are quite rare."
"I’m not sure if I’m qualified to speak with authority, but LLVM libunwind for ARM a bit undeveloped. Overall code looks like it is half done. I was able only fix gross issue like this https://github.com/llvm/llvm-project/commit/08a5ac36b956edeb989b4a65269a829eac26a5a2 In EHABI handling. For me this code is a bit scary"
"Gross. Even in Kestrel.Core! 😭 I think I should have made you put those methods in KestrelTrace.

Clearly we're inconsistent with whether we use extension methods on `ILogger` for structured logging or not. I vote for not using extension methods for this purpose going forward.

On an unrelated note, it looks like the consumers of Kestrel's LoggerExtensions are logging to `Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer` instead of `Microsoft.AspNetCore.Server.Kestrel` like the rest of the Kestrel.Core assembly. I guess at least we don't have EventId conflicts that way... Do you think it's worth consolidating these namespaces before 3.0, or is it not worth the break?"
"Or like one of my other suggestions, disallow this entirely and get users to use the endpoint routing authorization extensions: https://github.com/aspnet/AspNetCore/blob/16a47948f80fede807fabe3c291d793590e8fd17/src/Security/Authorization/Policy/src/AuthorizationEndpointConventionBuilderExtensions.cs#L14

While `HttpConnectionDispatcherOptions.AuthorizeData` is old API, the endpoint routing based extension methods are new. It doesn't seem terrible to say this feature does not work when using endpoint routing. We could also use the Startup analyzer to guide users to not use this property."
WTF is this?
.... Because I clearly wrote this with very little to no sleep 😅 yea wtf was I thinking. 
"> > Do we want to search for callers in the whole solution, or do we want to only search for them in the current document? Solution-wide is more difficult, but doable if we really want to.
> 
> Ugh. I'd assume this is going to need to be solution wide. I personally don't think we should be altering call-sites all that much but that isn't a popular opinion.

We do warn the user if we can't change all of the call-sites, so the experience isn't terrible. I'm fine holding off on this work until we get feedback that document-wide isn't enough.

> > is throwing after unmarshalling okay?
> 
> That can get tricky. This requires the state of the outs to be valid and that isn't always the case for out params of native functions. I can recall hitting older Win32 APIs that left outs in a dubious state, but I doubt that is any issue any longer.

I think we'll hold off on adding a custom marshaller then until we get feedback that there's APIs that don't work correctly with the new ordering."
"I'm fairly certain this code is pretty terrible.  However, i'm going to leave things as is so that we don't subtly break anything in 15.3"
"The commenting out does look gross, I'm OK deleting it 😄 "
"Oh crap I'm so sorry @github 😢 , I didn't refresh my tab this morning when I replied to this thread so I didn't see the `scope_exit` comment before pushing my wacky change! Both of you are totally right, it's a much better approach 😅 "
"Oooof. Might need to add this back to fix #11285, to make sure that we have some acrylic on win10. Gross. "
"> Previously, when a pull request's head branch was merged and deleted, all other open pull requests in the same repository with a base branch of the merged branch would be automatically closed.
> Now, instead of automatically closing these open pull requests, the pull requests will be retargeted—the base branch of each pull request will be updated to the merged pull request's base branch.

wtf"
"@github 

Those aren't terrible ideas at all! :smile:

> I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.

This would need to be a _yet another_ type than the ""context"" object that is passed by the completion service to `CompletionListProvider.ProduceCompletionListAsync`. I'd prefer not to introduce more of these. However, your point is taken. I was modeling CustomTags off of what we did with diagnostics, but perhaps that's not the best approach here.

> Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then perhaps we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could imagine people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am not saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that also might fix this problem too, I can't help but notice the coincidence.

This is the most appealing idea. Rather than having flags like IsDebugger and IsImmediateWindow that control random behaviors, capturing those behaviors in options is a good idea. I'll try this one out.

> Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.

Workspace kind is a pretty big hammer that I'd like to avoid. Of course, you probably listed it last because you'd like me to avoid it too. :smile:
"
"wtf.... what on earth is this skip-while for?!  That's just crazy.  I'd much rather remove this code, and fix whatever issue it was trying to work around.
"
"> @github could you please explain what you mean by
> 
> > It's also designed to be (partially) AOT friendly by making the core icall not generic.

At one point we had an invoke icall with a generic ```<T>``` return type, but that can't be AOTed (at least right now). So the current one returns object, which is inefficient (and kind of gross in terms of the burden it puts on both the caller and callee). We want strong types both for reliability and small, efficient codegen.

> 
> Also what's wrong with the existing `mono_wasm_invoke_js` ? (besides that it should not have `eval` and live in `EM_ASM_INT` macro, which I both fixed in my pending [PR](https://github.com/dotnet/runtime/pull/60504/files#diff-aeaa65b0a5528aaf1d5f89c138410cd639839359113f9c6a700efe2f9cf0e2caR479) .)

I could sit down and try to carefully enumerate why I think we need a new icall, but off the top of my head (this was a long design discussion that happened quite a while ago, so it's reasonable to revisit it):
* ```mono_wasm_invoke_js_with_args``` is not a tasteful API - the design does not have the traits of a good maintainable API. During the review for custom marshalers some of the same traits (weak types, boxing etc) that came up there as no-go apply to it as well.
* It's hard to optimize without compatibility breaks (for example, requiring that the method name be interned), and it's easy to hit performance pitfalls by using it in an inefficient way. Taking an object[] arg basically guarantees bad performance (the only real way to optimize the allocation out requires a ThreadLocal to be safe.)
* Many JS functions return undefined, and I think it's inappropriate to silently convert that to a null - it often indicates that you misunderstand the signature of the function you're calling and should be a failure.
* JS functions also happily accept extra arguments and sometimes will work if arguments are missing. This API makes it easy to do that, and I think we should be explicit about argument count. (The current icall doesn't enforce a callee argument count check... I could add that on the JS side if you want but I think there are cases where the callee won't have argument count data.)
* Aside from the general 'hard to optimize' problem I think making every single invoke create GC pressure is a very bad thing. We need to avoid it in the bindings.
* This new icall's signature is basically a cleaned up variation on ```mono_wasm_invoke_js_blazor``` (with the exception that the callee+caller need to collaborate to handle exceptions). I think it's best to ensure our API can efficiently be used to implement blazor, uno, etc.
* For ```mono_wasm_invoke_js```, the overhead of looking up the string literal is nonzero (especially because it's not required to be interned), and not being able to pass arguments requires the caller to do unclean things like shove arguments into globals (which is not a cheap thing to do via the current API... you'd have to do SetObjectProperty per-argument.)

My endgame for this is that we use source generators to create strongly-typed wrappers for specific methods (JS pinvoke, basically) that correctly and efficiently use this new icall under the hood. Later on those wrappers could transition to using dedicated JS and bypassing the icall machinery if necessary."
"Stupid question, but shouldn't expanding the nav bar block until it's ready anyway?"
Async methods can't be conditioned? WTF.
okay that's _insane_ but I can deal with it
"I'm not yet familiar with the regex handoffs between TS and ripgrep—would ripgrep have to support the same case change operations, or is TS performing the replacement and ripgrep is more of a file buffer, match-only iterator?

A String.replace() replacer() function defeats the internal parameter handling AFAICT, which means that the replacer has to walk the replacement pattern character at a time and replace the various $N instances. This isn't hugely challenging but it's very reinvent-the-wheel-y and duplicates a lot of the work and logic I see in `.../replacePattern.ts`.

So while I agree the second sounds easier, it also feels like it's fairly significantly increasing the difference between these fundamentally identical code paths. The current codepath is already applying the regex twice, once into `_regExp` and once with he `text.replace()`es.

Moving the vs/editor/contrib/find logic to vs/base/common might be the best use of time, even if it delays the case ops support. Just IMHO, still very much a noob to this codebase."
"An HTML tag can’t begin inside the attributes of another HTML tag.

On Wed, 25 Nov 2020 at 9:39 am, Alex Ross <notifications@github.com> wrote:

> *@github* requested changes on this pull request.
> ------------------------------
>
> In src/vs/base/browser/markdownRenderer.ts
> <https://github.com/microsoft/vscode/pull/111258#discussion_r530231953>:
>
> > @@ -218,7 +218,7 @@ export function renderMarkdown(markdown: IMarkdownString, options: MarkdownRende
>  	// We always pass the output through insane after this so that we don't rely on
>  	// marked for sanitization.
>  	markedOptions.sanitizer = (html: string): string => {
> -		const match = markdown.isTrusted ? html.match(/^(<span[^<]+>)|(<\/\s*span>)$/) : undefined;
> +		const match = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : undefined;
>
> I'm not sure that [^>] is correct. We still want to prevent html tags
> from beginning. [^<>] would probably be the best.
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/microsoft/vscode/pull/111258#pullrequestreview-538311922>,
> or unsubscribe
> <https://github.com/notifications/unsubscribe-auth/ABDJGLVPXQBRUCHBMT5S4H3SRTGEVANCNFSM4UBNVXZA>
> .
>
"
"> WTF

That's about our reaction :). Seems like it might be DI flakiness that just hit Negotiate tests (so the quarantine might not be super effective 🤷‍♀)"
"Yeah that is fine , we have been doing it so far and nothing terrible happened :)

But my followup work plan is to extract the crash reporter configuration as a separate CrashReporterService interface that can be shared by main, renderer and extension host, that way each can start the reporter at their convenience and share the base config."
"@github - what a nasty user :blush: I believe that the problem you describe exists in the original code as well.

From my understanding,  If the user triggers delayed sleep and then starts switching, what will happen right now is that we will still have TabPaletteItem populated in the switcher, but switching to it will have no action (as weak ref is empty). Not perfect, not terrible (or however they said this in Chernobyl). To resolve this we need to have the fully fledged binding that I planned for the next PR (where we do follow the changes in _tabs, _mruTabs that are observable collections)."
yea this looks insane as-is haha
Holy shit this is legendary. This has been my biggest pain point on Windows for many many years (remote tmux sessions were always garbled). Thank you!!!
"I'm stupid, I wanted to do the opposite 🤦‍♂ "
Do we trust people not doing 'stupid' things like Static etc..?
"Can you fold the previous `if` into part of the loop and iterate over 4 times? If it gets too gross, don't worry about it"
stupid question: why isn't `charSize(c) === 2 when c >= 0x10000` instead of `c > 0x10000`?
"Tagging subscribers to 'arch-wasm': @github
See info in area-owners.md if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

To get good behavior in typescript, your enums need to be 'const enum', otherwise it generates some really gross JS with runtime overhead. I didn't know this (thanks to @github for the tip)

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>kg</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`arch-wasm`, `area-System.Runtime.InteropServices.JavaScript`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
"Just to check, there's some terrible reason why the newer tools don't work against Preview 5? And if that file that it cant find is new since Preview 5, I think we just spotted your version check. ;-)
"
"    $""Warning: No Android message loop is available. Skipping invocation of `{d.Method.DeclaringType.FullName}.{d.Method.Name}`!""

This reduces terms like ""Looper"" (""wtf is a looper!""), replacing with a (hopefully?) more common term of ""message loop"", and also provides the callback method that won't be invoked. This should hopefully be useful for debugging/diagnostics."
"I think this implementation is terrible. Need more investigate and discussion.

Thank you for your review.
Sorry again"
"@github please excuse me if this is a stupid question, but how do our CI runs the WASM unit tests? Are they being executed on dedicated mobile devices or are we using V8 and running them on a VM? I am asking because I would like to repro the failure and according to my research, I should follow [these](https://github.com/dotnet/runtime/blob/main/docs/workflow/testing/libraries/testing-wasm.md#running-individual-test-suites-using-javascript-engine) instructions.

Also: I am experiencing a timeout, what could have possibly caused it? The tests are single-threaded FWIW."
"This is a little gross but the old obsolete API is sync, and IIssuerNameService is async only"
"Currently rebasing,
For my curiosity may I ask why `3.0` it it's now ""out of support"" and LTS are 2.1 / 3.1 and current it 3.1 ?

crap, my branch is based on `master` lmao, sorry, rebasing on `release/3.1` (I suppose)
mehhhh
"
"this type seems pretty insane to me.  why not have it point at something like  that 'result' instance, instead of needing to explode all the values inline into it..."
This whole test is the most insane thing I've ever seen but I love it
"I still think it's not a terrible idea to say ""we reserve all titles beginning with _"" (like a web-browser, even though you violently hated that when Dustin mentioned it being like an href target) just so we can add more things in the future, if necessary, without stomping on existing ones. An escape hatch, if you will."
"Both the old and the new formatting are terrible (too deeply indented), but that should be handled separately.
"
"@github I actually search twice per line so I don't miss cases like `foo?.bar.baz!.foo2;` Didn't want to mess with Regexes too much as it's easy to make stupid mistake.

<details>
<summary>Here is the code I used</summary>

```csharp
        static readonly Regex s_r1 = new Regex(@""[a-z0-9_]\?\."", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        static readonly Regex s_r2 = new Regex(@""[a-z0-9_]\!\."", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        static bool IsBuggyCompilerCase(string line)
        {
            Match m1 = s_r1.Match(line);
            if (m1.Success)
            {
                int start = m1.Index;
                foreach (Match m2 in s_r2.Matches(line))
                {
                    int end = m2.Index;
                    if (start < end)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
```

and searching in all directories for all .cs files

</details>"
"Are there other places where we do this kind of thing? I don't see any other places where we actually make use of the multiple-features thing. I understand how it works, but it feels gross. Can we put semicolons between them or something?"
"Ah, I've done something really stupid there haven't I?
😂"
wtf how did that happen.
"That's really a terrible style IMO. 😄 

Lack of braces makes various refactorings more complex and is one of the primary sources of bugs in a lot of C/C++ code."
"@github 
I have tested the multiplication on x64 and power. The program works fine on x64 and does not work on power Below are the console and generated IL codes for both plaforms along with the small test program. The only thing which I can think of is, this is too hardware specific and while passing '0x0000271000000001' int64 parameter as int32 parameter to mono_is_power_of_two function, power is somehow making it to power of 2 which is not happening on x64. 

Program:
public static void Main()
      {
          const ulong mul = 0x0000271000000001; // 1 + (10000ULL << 32)
          ulong val = 179769;
          ulong result = val * mul;
          Console.WriteLine(""val = {0}, mul = {1}, result = {2}"", val, mul, result);
      }

x64 console log:
root@dotnet-node3:~/dotnet-sdk-7.0.100-preview.5.22307.18-linux-x64/TestMultiplication/bin/Debug/net7.0# mono TestMultiplication.exe
**val = 179769, mul = 42949672960001, result = 7721019758346419769**
ppc64le console log:
root@dotnet:~/dotnet-ppc64le/runtime/artifacts/bin/TestMultiplication/Debug/net7.0# mono TestMultiplication.exe
**val = 179769, mul = 42949672960001, result = 179769**
Below are the IL code, on ppc64le multiplication instruction gets converted to left shit.
x64 IL code:
DTREE TestProgram.Program:Main () 0
BB0(dfn=0) (IDOM=BB-1): BB0
BB3(dfn=1) (IDOM=BB0): BB0 BB3
BB1(dfn=2) (IDOM=BB3): BB0 BB3 BB1
INSERTING SAFEPOINTS
BEFORE SAFEPOINTS 0: [IN: , OUT: BB3(1) ]
BEFORE SAFEPOINTS 3: [IN: BB0(0), OUT: BB1(2) ]
il_seq_point il: 0x0
il_seq_point il: 0x1
il_seq_point il: 0x8
i8const R20 <- [179769]
i8const R21 <- [42949672960001]
**long_mul R17 <- R20 R21 clobbers: 1**
ppc64le IL code:
DTREE TestProgram.Program:Main () 0
BB0(dfn=0) (IDOM=BB-1): BB0
BB2(dfn=1) (IDOM=BB0): BB0 BB2
BB1(dfn=2) (IDOM=BB2): BB0 BB2 BB1
INSERTING SAFEPOINTS
BEFORE SAFEPOINTS 0: [IN: , OUT: BB2(1) ]
BEFORE SAFEPOINTS 2: [IN: BB0(0), OUT: BB1(2) ]
il_seq_point intr il: 0x0
il_seq_point il: 0x1
il_seq_point il: 0x8
i8const R36 <- [179769]
**long_shl_imm R33 <- R36**"
"While checking what's consuming space this week in the AppData directory, I by chance came across this directory, and immediately warning bells started ringing. Both due to the size of the data it contained, and the name. ""RemoteWorkspace? Is this another data-exfiltration attempt without my consent?!"" was my first thought. Only (!) by doing a google search and by pure luck finding this very github issue did I find out that it's _yet another_ directory to maintain (clean out) where VS stores ton of junk.

Previously users knew about the option to delete the "".vs"" directory (and not infrequently got told by ""support"" to do so), but now there's yet _another_ directory, with a for-all-intents-and-purposes encrypted name, effectively **hidden** (worse, **intentionally** hidden) that I'm quite sure support don't have any idea whatsoever it even exists.

Some of the following could be considered ranting, but frankly I don't care anymore what you think when you dump waste products all over **my** storage, without neither my permission nor even the curtesy of telling me, much less providing the functionality to remove the crap.

@github 
> > so who delete db file left out?

> No one. It's just a cache.

To quote a greater person than I am: ""You keep using that word. I don't think that word means what you think it means"".

> This is equiv to the data stored by many apps in the .appdata folder. It isn't intended to ever be touched our used by the user.

There's a helluva lot of difference between ""cache"" and ""Dumpingspace landfill we take the liberty to rip off from the users. Let's fill it with excrements and never clean it, then we call it a _cache_ and go MUAHAHAHAHA when the users diskspace is completely consumend so it can't even update neither VS nor Windows itself after a while!"".

I have only used this version for a few weeks and already this ""cache"" is over a quarter of a gigabyte. Extrapolate until the end of the year, and the system volume would have zero bytes free space. Guess how happy I am to find out this is _intentional_.

I'm really, REALLY sick and tired of VS stealing (!) storage from me from all over the bloody place, without my consent. Now you created a mess where most users won't even know about this landfill you erroneously call ""cache"". I know about it now, so I can redirect that crap directory at the filesystem level to a junk volume I have redirected much other VS crap to, but what about the tens of thousands (or however many there are) users that _don't_ know about this? Are you gonna pay out of your own pocket for the downtimes this creates when they have to *reformat* and *install from scratch* Windows, VS, and who knows what other software, just because you filled up the users system volume -- behind their back, hidden in an obscure location they according to you shall never clean -- with data you erroneously call ""cache""?

I appreciate the effort to clean up the mess that the code apprently is, but replacing that with messing up users filesystems in an even _worse_ way is IMO not an acceptable tradeoff.

This could be fixed with a VS-wide setting, with user-interface, allowing users to redirect (and move, and clean) this directory, but the way it's currently implemented my position is that this is malware.

To round off... please learn what ""cache"" actually means before using that word again."
"Gross, but sure."
"No, the arrow function is fully annotated, but the assert declaration itself needs to be annotated. It's very stupid.

```diff
- const assert = (value: unknown): asserts value => { }
+ const assert: (value: unknown) => asserts value = (value: unknown): asserts value => { }
```"
"Thanks, @github.  Not stupid questions.  We handle merging.  I re-ran the failed leg and it passed.  Thanks for the contribution."
(I don't expect the perf hit due to filtering to be that detrimental on the AzDO build machine as it should be mostly empty as opposed to my HDD full of crap ;-).)
"Ah crap, sorry, was going through the servicing-approved PRs and didn't notice this hadn't been regular approved. Want me to open a revert?"
"Thank you for the debugging advice. I've spent few days trying comparing dasm files. It is very hard for me to tell what is exactly wrong, but I found some suspicious facts:
1. Regressions mostly occur when 'x' is a pointer (or ref variable). 
Here is the diff example https://www.diffchecker.com/fQLJQ4YW
2. Regressions mostly occur in `MoveNext()` method 
<details>
  <summary>Example</summary>
 <img width=""1201"" alt=""image"" src=""https://user-images.githubusercontent.com/18483133/147747869-a32338bd-d4fb-4ff3-89ad-2ea67fcc1b0f.png"">
</details>
3. Some regressed dasms show terrible PerfScore. Here is the example https://www.diffchecker.com/BQUzlt9K"
wtf
"The constructor thing on the collection is gross, but this works pretty much like what I expected. "
"If it is stupid and it works, is it really stupid? 🐴"
"Found the root cause. Had a stupid bug in the test (missing import for System) which caused Action to be error type, so the event implementation would not get matched with event from interface...
`ComputeType` indeed needs to be updated to ignore tuple name differences.

---

In reply to: [82700123](https://github.com/dotnet/roslyn/pull/14229#discussion_r82700123) [](ancestors = 82700123,82653989)
"
"I just noticed it looks like this isn't even an `InnerException`, but instead it's just used for to copy its `Message` to the `RpcException` that's ultimately thrown. Now I care less than before.

It's kinda gross the flow the exception message this way to the common throwing logic, but if that's really the best way to do it, just leave it as `Exception` instead of some derived type that makes no difference."
"> The complete absence of cancellation/timeout support in these code paths is terrible. Some streams allow sync operations to be cancelled by Disposing the stream.

The main SendAsync method is registering with the CancellationToken to tear down the connection/stream should cancellation be requested at any time before all the response headers are received, and the implementation enforces that the response content is fully sent before that point.
https://github.com/dotnet/runtime/pull/34948/files#diff-75931c95adb5205b557555a5cd4f966eR336"
"I'm of two minds here. 

I really like that you want to prevent the VT52 stuff from getting in the way or affecting the performance of the VT100 code. It's always nice to build something in a way that guarantees the other mechanism isn't going to be affected in any way.

However...

It's really not that big of a deal to change the `ActionEscDispatch` interface and method to have a parameter option if need be, it's not terrible to have a slightly diverging mode codepath in the `OutputStateMachineEngine` for this mode type, and I don't think there will be very much performance impact at all given the character parsing and twiddling of the VT engines tend to be a relatively small portion of CPU time when I've traced it in the past.

I'm a bit concerned that if we have two completely different implementations that it will be easier to completely forget about one when designing things around the other one and we'll be writing an exorbitant amount of boilerplate to do the 95% common things between the two of them.

Someone else (@github or others) are welcome to counter my point here. Just my opinion."
"I'm an idiot, I removed the TextDocumentIdentifier which was outside of our control and misremembered. YOu are 100% right"
"stupid efficiency question: Is it more efficient to have `createSignature` set these? (I'm guessing not, since probably composite signatures (1) are rare (2) have their own internal class.)"
"For now yes, although I've cleaned up all this crap"
"> > This is jank and it should work for any number of arguments even though 32 is insane. 64?
> 
> Changing the field to `long` would allow 64, I'd prefer not going bigger because then we'll need to allocate/lazy-alloc and have another field.

Sounds reasonable. I don't think allocating a `bool[]` once per hub method would be that bad, but it also doesn't feel that valuable to support a service argument after the 64th position. The startup error message is clear enough."
"> We'll have to discuss expectations. If we want to add tests, then we'll need a list.

We can def do this.  But team position (in the past at leasT) was that sanity coverage was covered by compiler.  i.e. new feature-work doesn't need to be done.  But ensuring existing features work fine (i.e. not crashing, not having a terrible user experience) needs to happen to merge into master.

We have a list somewhere.  @github can you point us at it?"
"I hate that the test param is named `closeOrDispose`, that's a terrible name for a bool param. But that predates this PR so not something to block on."
"> Actually I think I was stupid for obsoleting this at all. I'd actually say it's probably worth ""unobsoleting"" it. There's still value.

Fair point. Un-obsoleted.

> Hmmm you can validate to see if they're consumed at all in the Mvc 1_x / 2_x projects: https://github.com/dotnet/aspnetcore/tree/master/src/Razor/Microsoft.AspNetCore.Mvc.Razor.Extensions.Version1_X

There's not consumed there. Just the Razor tests. I guess that means safe to remove?"
Ugh yes I forgot this was the one stupid out-param function 
"Alright so this is a wack idea that might need socializing with the rest of the team, but I wonder if it would make sense to just combine this functionality with the `move-pane` action? Thoughts on the matter:
* `mptt` is kinda a black swan here - all the other short forms are two characters.
* for something like `mp -t 0`, the long form could actually just be `--tab` 🤔 
* `mp -t 0 left` now is a little weird, ""move the pane to tab 0 (to the left???)"" That doesn't make sense. The two options (`direction` and `--tab`) would have to be exclusive
* It's probably not _that_ insane to have two actions (`MovePane` and `MovePaneToTab`) that are exposed through a single commandline interface. 
* (as a follow up idea:) we could do something like `move-pane --tab 0 --parent 4` which would move the pane to be a sibling of pane 4 in tab 0. "
"(high horse) and *here* is where negative numeric types are handy!  *IF* (lol?) there were `uint.MaxValue/2` environment variables, this would become an infinite loop, as we'd loop from `uint.MaxValue-2` to 0 without nary a blip.

(Granted, that would require having a lib with `uint.MaxValue/2` environment variables, which is *insane*...but kinda/sorts shows the utility of negative numbers. :-)"
I'm stupid. PatternSyntax check already excludes a parenthesized designation. I'll adjust the comment.
"It has the base type of DocumentationProvider, not XmlDocumentationProvider. (I agree the names are terrible.)
"
"wtf...
"
"Well, so this _works_, but it has 2 problems:

1. Most consumers do not expect the very specific type the jsx factory function actually returns. Usually, this manifests in reassignments, where
```ts
let a = <div></div>;
a = <img />;
```
ends up being an error because rather than both being `JSX.Element`, the first assignment makes `a` a `React.ReactElement<HTMLDivElement>`, while the second line is a `React.ReactElement<HTMLImageElement>`. This is, unfortunately, a breaking change we'd force on people. It's not hard to fix (annotate `a` with the more vague `JSX.Element` yourself), but could be frustrating. That break reduces the appetite to take this change a bit.

2. Performance is _terrible_. Like beyond bad. This makes _every_ jsx tag tree in your program into a series of nested generic context sensitive function calls (and _most_ jsx apps have a _lot_ of nested tags!). That's just about the worst-case scenario for the type checker. If we could make nested context sensitive function calls much more performant to check, it's go a long way towards making merging this feasible."
This looks insane to me.
"Basically, it's not terrible if we offer keywords even when not always applicable.  That's still much better than *not* offering it.  Then, we could just make this cod really simple.  Basically: ""offer these things if it's in a parameter list"", even if that allows some things when not applicable."
"Wohoo. Five minutes after loading the PR and I can finally comment here. 

Oh crap I pressed Enter, another five second delay. 

Anyways yes this will fail if the file is missing. 

"
Wtf I know I changed that...
"Yea I can concur with that. I'd make sure that this is clear in the doc comment for this function, because it's definitely _not_ clear just reading the code wtf is happening here"
"> @github I think you meant to mention @github.

haha crap sorry!"
"I checked OS set to light and OS set to dark with the app following. If you switch it while it is open, it looks terrible. But if you close and reopen the page it's fine. I wasn't going to cry over that.

I can check and cross-reference the other bug I guess."
"This should be a more ""context free"" error message.  We certainly *don't* want the stack trace dumped to the ""error"" output, as this is user hostile (wtf are they supposed to do with it?), though that said, what are they supposed to do when this task fails, *period*? :-/

Regardless, I'd suggest:

```suggestion
				Log.LogCodedError (""XA3001"", $""Unable to generate `libxamarin-app.so`: {e.Message}"");
```"
"Loed, I'm stupid. Sorry for that."
"this is the meat of where things changed. unfortunately, the diff is terrible. effectively teh logic is pretty simple:

1. determine the expression we want to inline.
1. find the reference locations to inline and inline there.
1. if we had no conflicts, remove the declaration
1. add warning annotations for things like side-effects or moving code into conditionally compiled methods"
Gross 
"This is build time, but I agree this error message is terrible especially in light of the new convention-based inference of parameter sources. I want to track more information about the parameters when building up the RequestDelegate arguments which will lead to better errors, but I've already started on the culture stuff so I think I'll do this as part of this PR."
"We don't use it often (I think because people don't know about it), but if it makes things worse feel free to disregard this. It's sometimes cute, sometimes terrible."
"What's the best code pattern to do something like this? I feel like `Lazy` with a lambda is too heavyweight, and a `bool hasComputedIsAttribute; bool isAttribute;` is kind of gross (so I want confirmation before doing that). (Or did you mean something else by that? Not computing if `context.IncludePrivateMembers` is true or something like that?)"
"this seems inconspicuous, but also, wtf is it doing? A comment (below, outside the macro) might help enlighten as to why that's needed."
"> Does it need to be Roslyn specific?

Long term I think that terrapin will end up encompassing all of the tools in our build that contribute to how our DLL files are written. So there are some obvious examples that go past Roslyn: single file writer, F#, etc ... Hence I do think long term we will need a manifest file that encompasses the artifacts needed be the totality of these tools. 

At the same time I tried to write this section to be more general but had trouble doing so as we don't know the exact requirements of the tools. Given that the next six months is largely Terrapin focused I kept this doc fairly Roslyn specific to keep it concrete. 

I should add a section at the end though clarifying that the intent here is for this to envolve though. 

> So, I think we can have dotnet-build-dependencies tool that works with all managed binaries using a common set of entries that express dependencies.

As the end of the doc states, I'm terrible at naming. I'm fine with whatever name others agree on. @github do u have any opinions here?

"
HOLY SHIT that totally fixes it.
"> wait uh, I don't think we need this. Win+down will minimize a window

Ah crap I didn't even know about this shortcut 😅
Ok so with this shortcut, the user can minimize to tray with the keyboard as long as `minimizeToTray = true`.
What about users who have `minimizeToTray = false, alwaysShowTrayIcon = true`? They may not want all minimize actions to minimizeToTray, but they'd likely want some way of sending the window to the tray considering they want the icon there. Perhaps it should be a system menu item? Or maybe it should be a tray icon menu item? 🤔"
"Stupid context specific diff, did not notice."
">  all while continuing not to have evidence that this is actually a hot path for real-world apps. 

Signals Rosyln would move away from ImmuntableDictionary for a fast Dictionary clone method https://github.com/dotnet/roslyn/pull/47503#issuecomment-687917289

> Yes, ImmutableDictionary is really bad. We just haven't had cases yet that fell into the patterns for which we have production-ready alternatives. The main scenario that we have the ability to improve today is collections with the following characteristics:
>
>* The dictionary is built up from empty, as opposed to built by transforming a previous collection through add/remove operations
>* The collection has more than a few elements, but less than ~10K elements
>
>For this we could switch to an immutable wrapper around `Dictionary<TKey, TValue>`, similar to how we use `ImmutableArray<T>` instead of `ImmutableList<T>`.

/cc @github

and

> My gut tells me this should be a slam dunk win. The vast majority (probably nearly all) of cases where we use ImmutableDict, it's not to benefit from what ID is decent at, but just to ensure it will not be mutated post creation. For that purpose it's actually a pretty terrible choice and adds a tremendous amount of overhead for functionality that we're not needing in those scenarios.

/cc @github

Also for lockless read Dictionary, with very infrequent updates (where reallocating the entire dictionary is more lightweight than taking a lock on every read, or using `ConcurrentDictionary`) e.g.
``` C#
class LookupTable
{
    private Dictionary<int, string>? _lookUp;
    private readonly object _lock = new ();

    public bool TryGetValue(int key, [MaybeNullWhen(false)] out string value)
    {
        // No locks required for read
        var lookUp = _lookUp;
        if (lookUp is null)
        {
            value = default;
            return false;
        }

        return lookUp.TryGetValue(key, out value);
    }

    public void Add(int key, string value)
    {
        lock (_lock)
        {
            // Clone + Add
            var dict = _lookUp?.Clone() ?? new (capacity: 1);
            dict.Add(key, value);
            // Switch reference
            _lookUp = dict;
        }
    }

    public void AddRange(IEnumerable<KeyValuePair<int, string>> collection)
    {
        lock (_lock)
        {
            // Clone + Add
            var dict = _lookUp?.Clone() ?? new(capacity: 8);
            foreach (var entry in collection)
            {
                dict.Add(entry.Key, entry.Value);
            }
            // Switch reference
            _lookUp = dict;
        }
    }
}
```"
"Since we're having to update what is installed with VS too, can we just fix this for good? This was a terrible hack that's caused other problems in the past."
"Technically, 'an' is correct since MS is pronounced ""em ess"", and that leads with a vowel sound... :smile:

(English is a terrible language.)"
"Typo: overflow ar runtime

You basically say ""We are only able to provide an algorithm that fails at non deterministic occasions at runtime until you remove a safety net ( which many developers are not allowed to remove). Good luck with that."". I would say that anything, even the most terrible algorithm, is better than obviously buggy code."
"```suggestion
                        if (interfaceMethod.HasInstantiation)
```

If `interfaceMethod.HasInstantiation != methodImpl.Body.HasInstantiation`, terrible things will happen below, so we might as well assume that and consider the Body check redundant.

I believe InstantiateSignature is going to be a no-op if the constrained type has an instantiation because that part is already instantiated."
"Ideally we'd probably also check if `type.flags & ts.TypeFlags.TypeReference` just to be sure, but I don't think we'll do something stupid like `enum Array {}` anywhere, so it's likely safe to assume it's a `TypeReference`."
"@github Thanks. That makes sense. But in that case, it seems like its not really ok to be conservative about when to do the transformation? eg right now it would reject

```
type NotTransformed<T, U, V, W> = keyof { [K in keyof T as U extends V ? (K extends W ? K : never) : K]: T[K] }; 
```

even though it *is* distributive wrt K.

[edit: never mind about the last part, it is a bug, and it's fixed in the nightly. Sorry should have checked that first]. Can you explain what's going on with f3's parameter type? We know that `T1<M> extends T2<M>` and that `T2<M> extends T1<M>`, so the nested conditional *should* evaluate to `boolean`, but it doesn't seem to. Is that a bug? Or am I doing something stupid here? The really weird thing is that if I change it to `T1<M> extends T2<M> ? (T2<M> extends T1<M> ? true : false) : 42`, then f3 doesn't accept `true`, `false` *or* `42` as its parameter:

```
foo.ts:32:4 - error TS2345: Argument of type 'boolean' is not assignable to parameter of type '""a"" | ""b"" extends T1<M> ? true : false'.
```
"
"I see and understand the risk now.

I don't speak enough languages to demonstrate a counter-example, but I would not be surprised to see one. I think the only thing that is ""right"" in the sense that it can't go wrong in this way is to just have separate resources for each of the ""several strings we show user here"".

How many strings are we talking about if we split them out. Unless it's insane, I'd recommend doing that and eliminating even having to worry about this.

@github What do you think?
"
"Probably unrelated, but this is a terrible error message. We should say _what_ the inconsistencies are. #Resolved"
"Crap I broke something in the merge, I think the automationPeer is getting torn down in the wrong order. It's crashing on close again. 💩 "
`WTF?` WTF? 😛 Debug spew message??
"You're right - I was stupid enough to trust ILSpy to resolve the right dependency - and it resolved 3.1 version ... My bad.
In that case this should work (you would get a RUC warning when calling AddSingleton)."
It is a terrible terrible url for vsdrops. That is what it is used for a path in a vs drop. 🤦 
"> The performance of this is terrible for large buffers.

This should no longer be the case with .NET 6. Are you still seeing that?"
wat...  seriously.  wtf :)
"@github Thank you, that's the kind of response I was hoping for.
So is this a inherent design flaw of the original monaco editor (You are the expert on original Monaco)?
If so, do you have some ideas how we can mitigate this stupid design flaw? (Global solution to a local problem does not seem to work, (no surprise)).
(In other words) What can be done?"
"Yes, but I was thinking, is this ever going to be """" ever? That might seem strange for the API user, and I did not want us doing something wrong, returning """" and end up with issues. (mainly, ""I don't want me changing this ever to do something stupid"" ;) )"
"Oops. Stupid tab/spaces settings!
"
"This name is terrible.  Maybe `IsIdentifierAndNull(...)`?
"
"If you're going to make this less terrible, we probably should remove the . after this so it's grammatically correct.
"
"prototype assignments jump from the assignment location to the location of the constructor function and continues walking up the tree looking for type parameters. It does *not* fork and continue looking from the site of the assignment.

In a [hilarious tweet](https://twitter.com/sanders_n/status/1162131784009523202), I provided some code where this  difference could be observed, but it was clearly insane. I think this is a good solution, because it makes prototype assignments act as if they are effectively nested inside the constructor function, in the same way that methods are nested inside classes in modern JS."
"sorry about that delay I did not check the base branch, In fact I'm surprised I managed to apply a diff on master while it was fixed in `5.0` :D 
i feel stupid
"
"@github Are there any docs on the low level design of liveshare?  specifically, i'm looking to understand how it works from a client/server perspective.  Where is information expected to live?  Who is responsible for ""source of truth"".  How clients and servers synchronize and ask questions in a way that is consistent, etc. etc.

For example, here's an easy sort of problem i can envision, which i'd like an undertanding of how it is handled:

1. on the client (without roslyn), user makes some edits.  this increases the length of the file.
2. client then wants to classify the text at the end of the file.
3. tehy then communicate with server, but server doesn't have text/project that matches what client has.  server passes requests onto roslyn, which crashes because invariant is broken.

Now, given this is such a simple scenario, and you're likkely not crashing.  You have presumably solved this in some manner.  For example, some sort of syncing.  Or perhaps validating that the request can even be asked on the other end.  However, those designs and invariants are not clear here, and as such it makes it *very* hard to tell if the code here is correct.

--

To give some context, i was involved in the early days of the LSP with the TS lang server.  There were all sorts of assumptions and terrible practices going on between the clients and the servers, and at the end of the day, it became necessary for tons of hacks to be added all over the place to just paper over these places where little discussion/design had happened, and people jsut did random stuff because it seemed to work without understanding the implications of those decisions.

I would *very very* much like to avoid that in roslyn.  For a very large part of it we've operated under the assumption that it's much better to have strict invariatns and to fail early to ensure that people ""do the right thing"".  If we're still abiding by that, that's great.  But if we're not, it's important to document so we cna ensure everyone's mental model of responsibilities is accurate.

Thanks!"
"As I briefly mentioned in chat before the holidays - this _can_ be localized, but it will _hyperexplode_ the unittets. In my opinion, we should probably not hyperexplode the unittests. The solution to the unittests problem appears to be ""rewrite the entire thing"", but I need to do a bunch more investigation of WTF is going on there. I think the right path here is to do this non-localized for now, and file a follow up for adding localization to them. That way, we won't need to include a massive ""rewrite the unittests"" change as a part of this already hefty PR. Thoughts?"
"Okay, the Terrible solution I have is to have a `.../CommandlineArgs/Resources/en-us/Resources.resw`, and include it manually in each of TSE and `TerminalApp`. That'll get the resources added to the correct libraries, so `RS_A` will still work, regardless of which dll it's being called from. 

@github Will that still work for localization? "
Oh crap. I think I messed up the commits. Well this is indeed a lengthy thread. In fact I think this is most commented PR I've ever made on Github. I'll force push later.
"@github any specific preference to the preferred sort, or just sort via StringComparer.Ordinal or something?

Oddly the current comparer for the hashset-based comparer is PathComparer, which does a bunch of extra comparisons around relative pathing and such to attempt to ""normalize"" the path. I was going to just switch this over to an ImmutableSortedSet but PathComparer doesn't implement that (since it would seem insane to do so)."
"So this is a good point.  For clarity, whatever newline sequence you wrote, we will embed into your converted string.  This means from the language/compiler perspective, on that machine, the literal has the exact meaning as before (no semantics change).

Where it gets subtle though is the absolutely insane behavior of git where it may take a file and just change newlines *even that are language relevant* when sent to *another* machine.

In this case, the refactoring is in line with the lang and compiler.  However, it is *git* that ends up causing issues here as it thinks it is sensible to touch programming lines that relate to content.

--

Note that this is a refactoring though.  It is opted into the user, presumably because they actually think this is better.  And it will be very clear that a single line became multi-line.  So i think the user can be trusted to decide if that is acceptable for them given their git config."
"WTF are ""reverse forwarders""??
"
@github @github Is the stream context completing the transport output like this a terrible hack or an elegant solution? IDK 🤷 
"> Crap, before this will work we need to update the spa-templates submodule to reference the dotnet7 feed & ingest it. I'll update that repo now.

Presumably we also need to back-port this into release/6.0 as runtime's 6.0 contains the updated transport package."
"➡️ In the total absence of enforcement to date, we did a terrible job making sure tests clean up after themselves. I fixed enough cases in #25558 to make sure this change is viable, but I expect to see this condition hit in practice. Earlier portions of the cleanup code guarantee that all synchronous and immediately-queued cancellation requests are processed before reaching this condition. **All cases where this is hit are a bug.** However, the condition relaxes the overall acceptance criteria for this large change and allows us to pay off the debt over time."
"What happens when you have two text editors open to settings.json? Best case scenario, one tells you ""this file changed. want to reload it?"".

This is a case of ""play stupid games, win stupid prizes""."
"Not nearly as bad as enabling NRT for the first time. The `default` constraint is the only place I had trouble. We desperately need a code fix for this particular error or we're going to be fielding a ton of ""WTF"" questions."
"I concur - almost seems like we should have `ProfileSettingContainer : SettingContainer` that allows for reverting to the parent, but only for settings in profiles.

All this is terrible, but let's not pretend our settings model was designed for a GUI."
Ohhhhhhhhhh.  I'm an idiot.  we can use the return value to figure this out.  tnx.
these diffs are terrible.  I'm not srue why it threw it off so much to indent.  working on this.
"@github Can you add a comment stating the intent then? I could totally imagine somebody coming by, saying ""heh, that's stupid it's not sorted"", and adding in the exact thing you're removing.

(bonus points for having some sort of visible grouping so it's clear to users too.)"
"> Possibly a stupid question, but why rewrite this?

Short-circuiting binary operators imply a control flow. For example, if ```a``` in ```a || b``` is true, we jump over evaluation of ```b```. This should be explicitly reflected in the graph through links. See LogicalOrFlow_01 unit-test in IOperationTests_IBinaryOperatorExpression.cs.

---
In reply to: [162218816](https://github.com/dotnet/roslyn/pull/24263#discussion_r162218816) [](ancestors = 162218816)"
"I was going to suggest using `Task.WhenAll` to avoid the long declaration of `originalNodes` then I realized `GetDeclarationAsync` has side-effects. Maybe just call it something like `AddInlineWithVarEditsAsync` to make it more clear what it actually does? Sorry, I'm terrible at naming things, but I'm sure you know I'm saying :)"
"We use it to let the solution crawler back off. We have logic to back of if we are editing our files (to avoid us causing lots of GC for example), but if say you're editing a Readme file or something else we don't want to be making that terrible."
"> In order to diagnose it, I used hardcoded DebugBreak() since even ImageFileExecutionOptions didn't like running against conhost - is there are better way to debug and test these cases without being so invasive on the system?

Not really, no. `Conhost` is gross to debug.

"
"> the `ApplicationContext` which is embeded in the native ALC - and yes - that name is TERRIBLE and has to go

The `ApplicationContext` which also contains an `ExecutionContext` which is a subclass of  `LoadContext`! So much context."
"This may be out of scope for this but the old (and new) behavior seem. wrong to me.
Let say the kernel was built without IPv6 support (or v4 in distant future). The file would be missing and we would always throw even if there is nothing wrong.

In many cases like this it feels it would be better to return empty collection. Since the networking grabs massive amount of information had several cases in the past when we thrown on stupid things even if the caller really does not care.  "
"Holy crap, I saw this issue weeks ago and didn't expect this one to ever get fixed."
"> ""Wouldn't be surprised if other components in the ecosystem exhibited the same problem.""

I agree this is very likely not the only one, it's just one that keeps popping up quite often. It's been a pain point for years (first on WPF, then on UWP, now on both MAUI and WinUI 3, etc.), and something that has received countless feature requests for. The solution many have come up with is to just roll their own collection types with support for ""range operations"", with the big drawback being though that since no UI framework among these actually supports the API, they're just forced to either iterate over items one by one (which is just terrible for performance), or just reset the collection and reinitialize it (which is also bad for performance, maybe just a little bit less, and also completely breaks all animations). It's just a very unfortunate situation where customers get frustrated, and they often have to both do extra work to build these helpers, and then still end up with a suboptimal experience. I mean, we have the same exact custom collection type in the Microsoft Store too, and it has the same exact issues (and I hate it). It's just a really common issue, and I'm saying I'd love for us to find the time to coordinate with the right folks and maybe try to finally get this resolved at least for .NET 8 🙂

I've also received multiple requests to add such a custom collection type in the .NET Community Toolkit, and I've had to reject them for the reasons mentioned above (it still results in a very bad experience, and I'd much rather just fix this properly in the BCL). The net result though is that at least for now, the API is not there and plenty of folks are frustrated.

> ""but my recollection is that it broke in a substantial way as soon as runtime merged this change originally.""

I find that surprising and I'd love to learn more about that. Even with the new APIs, as long as nobody actually calls them, there should be no functional differences in the way the currently existing APIs work at all. So I'm not sure I understand what broke. Are you sure it wasn't just folks trying out the _new_ APIs, and then reporting WPF crashing/breaking in that scenario? 🤔

> ""Would doing that be a less disruptive way for newer frameworks to get range support?""

I personally don't think that'd be the correct solution for this issue, for a number of reasons:

- The core issue is that right now, the various UI frameworks don't support multiple collection updates. Where they come from is not what's causing the issue. That is, even with a new collection type, you'd get the same exact crashes until the frameworks were updated to handle the args. And if they were updated, then there would be no reason to have a separate collection type in the first place, as it'd just be the same exact one but with two new APIs. Those should just be added on what we have.
- It'd make updating codebases much more tedious, as now you'd have to swap the whole collection type in all locations rather than just being able to opt-in into a range update whenever necessary.
- I'd argue it'd be an abstraction leak. You want an observable collection, the fact that some callsites would need to perform range operations on that is just an implementation detail of your viewmodels. You shouldn't need to use a completely different collection type just to support this.

I would really love for us to just manage to coordinate across the various teams and officially add support for this in a future release, not sooner than .NET 8 at this point. We could both update all underlying frameworks to support this (which I realize is non trivial work, especially since eg. WinUI 3 would likely need some new WinRT APIs and projections for this), and then provide the necessary migration docs, if needed. I believe this would be the best long term solution for this issue 🙂"
"I initially went along with this, but when usability testing it locally I remembered why I had done it this way in the first place.

Basically I'm using exceptions to show the users their error messages, so it really ought to be more user friendly then your actual problem being buried in amongst an Aggregate exception format and a bunch of stack-trace stuff. This all stems from me using exceptions to bail out of functions early when we find argument problems (url is null, doesn't exist) so I don't have to make every method return `Result<T>` where Result could have an error that should cause us to bail early or the value we actually asked for. If you can think of a better paradigm than using exceptions of that gross Result<T> stuff I'm on board, because I agree that using exceptions this way isn't great, it's just the best I could come up with."
"oh right. Stupid API doesn't do what I want. :grumble:
"
"I was just testing the cmd defaults and one was enough there, but if there are shells that need 2 or 3 then maybe this is a good idea.  It's a trade-off of size for every scenario vs. speed for some scenarios.

With my change, each TextAttributeRun is 20 bytes, so given there are 9001 of these created in the default cmd scenario, each increase by 1 in this small_vector costs ~176KB, which seems like enough we should think carefully about what to tune for, but not so much that bumping to 2 or 3 is terrible.

Is there any data on how often different shells are used so we could try to tune for the most common ones?"
"I have a terrible workaround for the symlinking issue, which (unlike the compression option) is consistent with our symbol publishing :)

Technically, iOS-style unversioned frameworks are valid on macOS, so... flatten the framework post-creation. That should fix the Catalyst build"
the previously display text was just terrible.
"As a sentinel, if we decide that `OutputCellIterator` is globally stupid for making the caller maintain the walk-count... (which it is... in my opinion...) we can globally change it at some point by finding all affected areas.

I know I don't need to convince you any more, just giving more clarity on my thoughts."
"Sorry for the noob question: does `""T""` and `""x""` stand for ""Type"" and ""Value"" respectively? I'm trying to understand a little bit of the code by checking some PR's (yours is pretty cool!)"
"> For this we could switch to an immutable wrapper around Dictionary<TKey, TValue>, similar to how we use ImmutableArray<T> instead of ImmutableList<T>.

My gut tells me this should be a slam dunk win.  The vast majority (probably nearly all) of cases where we use ImmutableDict, it's not to benefit from what ID is decent at, but just to ensure it will not be mutated post creation.  For that purpose it's actually a pretty terrible choice and adds a tremendous amount of overhead for functionality that we're not needing in those scenarios."
cref? This might also be a nice place to use the list syntax @github was doing since this will format like crap in Quick Info otherwise.
"Should the test that the value shouldn't change just live in the compiler?

If nothing, I wonder if this deserves a good comment in the code. If I saw this I'd go ""WTF"" and just delete it without a second thought."
"This has me thinking about how we possibly do this for the DxRenderer.

I imagine that we will either have to...
1. Form all this data into an alternate stream that looks like a TTF/OTF font instead of this old Windows Font format that GDI seems to understand on `AddFontMemoryResourceEx` and then feed it into [IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference](https://docs.microsoft.com/windows/win32/api/dwrite_3/nn-dwrite_3-idwriteinmemoryfontfileloader) per the documentation at [Custom Font Sets](https://docs.microsoft.com/windows/win32/directwrite/custom-font-sets-win10#creating-a-custom-font-set-using-font-data-loaded-into-memory).
2. Make the DxRenderer load this HFONT into a GDI HDC and then call [IDWriteGdiInterop::CreateFontFaceFromHdc](https://docs.microsoft.com/windows/win32/api/dwrite/nf-dwrite-idwritegdiinterop-createfontfacefromhdc) and use the resulting `IDWriteFontFace` normally.

I bet the second one is easier but is a little gross for using GDI inside the DX renderer. The first one is probably difficult because I think TTF/OTF always specifies fonts as vector outlines, so I'm not sure how we'd live-specify these. Probably a lot more math...

Just ideas. "
"I agree with Dustin on this one. I'd reckon that most [questions](https://github.com/microsoft/terminal/issues?q=is%3Aissue+label%3AIssue-Question) actually start out as ""bug report""s that stem from a misunderstanding or generally not reading the docs. 

It's not a terrible lot of work to swap out the tags. I know that I personally reserve the Bug tag for when I'm fairly confident something actually is a bug and either needs more investigation or is generally on the backlog somewhere. I suppose that's really `Needs-Triage`'s job. "
yes.  that name was terrible. changed to `preferredMap`.
"> Performance at the full solution goes from:

You'll get at least 60 seconds gain my moving from MSBuildWorkspace to direct creation of compilations from csc invocations in the binlog. MSBuildWorkspace is extremely terrible for end-to-end performance because there is no parallelism in the MSBuild evaluation.

csc invocations have a secondary benefit of improved accuracy."
"note: IDE pattern is to name these MyCodeAction in almost all cases.  That said, that name is pretty terrible.  So if you want to keep the name like this, i'm ok with that."
"I tend to agree that these are truly special cases—since the relationship between `for`/`htmlFor` and `class`/`className` comes from the mapping between HTML attributes and DOM element property names, the spelling similarity is not a coincidence, but it’s not a given either. You can imagine a world where the DOM spec decided to map the `for` HTML attribute onto `HTMLLabelElement['targetInputId']`, or the `class` HTML attribute onto `Element['cascadingStyleSheetClassName']`. Both of these would be terrible APIs, but my point is that despite the fairly small string distance between these substitutions, the string distance is not the reason they should be offered. So I’m unconvinced that they merit a change to the string distance algorithm."
"Sorry, the part that I originally found ""gross"" was that this call was ever in the `if` in the first place, not your changes; now that you've moved the parameter out though, it's at least a lot cleaner.
"
"`Assert.Equal` does an IEnumerable-based comparison. The performance of this is terrible for large buffers. So terrible that it was dominating the total time of test runs in the stream conformance tests.

`AssertExtensions.SequenceEqual` does a span-based comparison, which is much much faster. Like 20x or more. 

`AssertExtensions.SequenceEqual` also has some logic around reporting differences that's kind of nice, but that's secondary to the performance issue.

We should always use `AssertExtensions.SequenceEqual` for comparing buffers. `Assert.Equal` is fine for non-buffers."
"@github oh my you're right, I feel so stupid! Thanks"
"To my knowledge the spec is not generated when you add the packages we add, so I think @github is right that we should reduce the timeout. I made it 5 seconds, which is still probably more than is needed, but not by an insane amount if you account for slow machines."
"This is stupid, everyone knows what whitelist means, and ignorableAssemblyList means nothing on the first read."
"> 
> 
> This is very clever, and I like it. It looks like it won't harm performance, but I do think that some caution is called-for around all the thread hopping.
> 
> @github: thanks for always cutting through our layers of crap (both organizationally and code-wise) and _getting good shit done_ 😄

Thanks! I want to be super cautious here - as the potential damage is... nice -  and  I am absolutely not in hurry to commit this one before we are fully confident! Just want to make sure we keep working on it - as it gets bigger and I am quite senile :blush:

I any case I found another concerning case:
* Assume we search backwards for some word, such that the matches are in lines 10, 20, 30:
* In this case we find the match at line 30
* Then assume the user scrolls up and selects a text in line 15. Then the user clicks ""search previous""
* We  will select the match at line 20 (because our state suggests to move from `3/3` to `2/3`), though probably the user expected to get the match in line 10 (at least VSCode in this case selects line 10 and puts the state at `1/3`)."
"Yeah it's not fun to hook this up. Not terrible, but not fun."
"Please add a comment here explaining this type lives in the VS side of things and exists to be the proxy. It makes sense to me since we have chatted about it, but @github can attest to having to debug through other frameworks where there was no documentation on what lived in what process and it drove him insane.
"
"Oh, that makes it terrible
`text%2Fplain%3B+charset%3DUTF-8`"
Terrible 😁. At least have a bool or enum property.
"It's grabbing it off of the getter.  The assumption being that the getter is normally before the setter.  Here it's suboptimal, but not terrible.  We can consider trying to do better in the cases where the getter is after the setter.  But i just wanted to ensure we weren't totally breaking code by removing preprocessor directives as the highest order thing to fix."
"(oh, i'm also an idiot since i read this as `Open Brace` not `Open Bracket`.  But the above points still stand)."
"> How does GetDiagnosticsUpdatedEventArgs work exactly?

You can think of the IDiagnosticsService as a mapping from special ""keys"" to the set of diagnostics for those keys.  This method name is actually *terrible* as these aren't really events or args.  They're really just saying ""what are all the keys we know about for this particular set of args"".  In this case, we're asking for all the keys associated with a particular document.  We can then use those keys to actually find out all the diagnostics for that doc.

You could imagine this exposed behind a helper method (which is what i think i will do :))."
"Thanks for the notice & discussion! TIL 😄 , and it makes a lot of sense.

This actually ended up not changing much in the output: 107e10d908 only showed a few _very_ edge case tests get a small amount of extra messages. Not so terrible. Phew."
"Stupid question - won't some of the changes by overwritten by arcade in some point in time - I don't know the flow of those, but I see some files are the same and looking at history they are updated?"
"> Ping @github - let me know if you disagree with the justification.

I don't like it.  I think we should not do this if we can't move the whole feature over (analyzer and diagnostic).  I worry that we'll just end up with crap left behind that we never get to.  But not moving this at all, it highly motivates solving this in an appropriate manner."
"**This is a warning**.

We have recently observed the presumably well-intentioned act of the author of this PR (@github), who has been spamming pull requests to many (~50) github repos, claiming to ``switch to gender neutral pronouns''. In reality, the bot performs a dictionary replace of gendered nouns and pronouns, and the outcome is questionable at best, and literally harmful at worst. See:
- The bot did a terrible job at replacing these words - [EbookFoundation/free-programming-books#6801](https://github.com/EbookFoundation/free-programming-books/pull/6801/commits/5257301642c173e2dc4f034f8c0460ce7ea99de6)
- The code fails to compile at [rust-lang/rust#95508](https://github.com/rust-lang/rust/pull/95508)
- The bot ignores all context whatsoever at [moby/moby#43441](https://github.com/moby/moby/pull/43441)
- After initial PR being closed, the bot keeps sending PRs, effectly spamming the repos. For example, these 5 PRs were sent to the same repo within 2 days [#1](https://github.com/EbookFoundation/free-programming-books/pull/6801) [#2](https://github.com/EbookFoundation/free-programming-books/pull/6803) [#3](https://github.com/EbookFoundation/free-programming-books/pull/6804) [#4](https://github.com/EbookFoundation/free-programming-books/pull/6805) [#5](https://github.com/EbookFoundation/free-programming-books/pull/6806)

We have reviewed the changes in this PR. Most of the changed words are ""accidental gender pronouns"" - `he` as a prefix of `hello`, or `his` as a suffix of `this`, and both examples come from test cases where inline comments are used to split words (like `t/**/his`), and the PR wants to change them into `t/**/theirs` etc.. These changes are obviously not helpful at all.

To save more time for the open-source community, we recommend the maintainers of this repo to close this PR and ban this bot from further spamming."
"> Many workloads for which tasks were originally introduced, actually. Consider, for example, parallelized divide and conquer. A worker partitions its work into multiple pieces, queues identical workers to process N - 1 of those pieces, processes its own, and then waits for those other workers to complete. Also think about algorithms that require coordination between those pieces, such as various operations used by PLINQ (e.g. OrderBy) that needs to block each of the workers until they reach a common point so that they can exchange data and all continue on, and what would happen if one of the workers was throttled indefinitely

Today do the implementation of those kick end up doing Task.Wait?

> I think that's the wrong direction, at least for the foreseeable future. If we decided to go with an approach like the one proposed in this draft, I have trouble seeing it as anything other than opt-in, given all of the previously cited concerns, the potential for introducing deadlocks where they weren't previously, the potential for casting way too wide a net, the potential for negatively impacting the throughput of unrelated workloads, etc. _If such a mitigation was added as opt-in, and if enough testing demonstrated it was a good decision for certain workloads, then it could potentially be automatically opted-in for those, e.g. if you felt ASP.NET should always turn this on. Even there, though, I'd be surprised if in the current configuration that was a wise choice.

Yes I have similar fears but I'm looking for solutions. Maybe this isn't this one but there are aspects of this that seem interesting. Say we added a public API to enable this and it was opt-in, I could see the potential for adding a piece of middleware or filters that enables this on the current workitem before the blocking code executed. Something like this:

```C#
[HttpGet(""/blocking"")]
[EnableBlockingMitigation] // This name is terrible
public string BlockingLegacyCodez()
{
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

That filter could yield to thread pool to get off the current work item and enable mitigation on a unique workitem that's closer to this code. The equivalent of doing this:

```C#
[HttpGet(""/blocking"")]
public async Task<string> BlockingLegacyCodez()
{
      await Task.Yield(); // Make a new work item
      ThreadPool.EnableBlockingWorkitem();
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

Thoughts?"
Shouldn't this be done in the other ctor? Also how do you feel about passing in an `ILogger` \ `ILoggerFactory` instead to the ctor? This feels a little gross.
"If `Bottom` and `Top` are both `SHORT`, then can't this technically cast into something gross when it's returned as `unsigned int`?"
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"@github Those are the default settings for insane (just copied over so I could add a few more attributes). The allowed tags are separate from the allowed attributes. The current setting just says: if we allow iframes (which we don't) here are the allowed attributes for them. We can remove the line since it has no effect

 @github I'm good with removing `marked.sanitize`. The setting is deprecated and has known issues, which is why we added `insane`.

My concern is just that allowing CSS brings up a number of other considerations:

- Which css rules do we allow? Do we try sanitizing the css? If we do have a whitelist of allowed css, how do we handle feature requests to support additional properties?

- Do we want extensions to control the styling insides hovers at all? Right now we control the presentation and can try our best to make sure the hovers look ok with all themes 

- Enabling css expands the potential attack surface. If someone finds an exploit in Chromium related to CSS, it could potentially now effect VS Code too.

My feeling is that we should think through this problem more and find some other potential use cases. Issues labels seem like a very specific use case"
"wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
[sceen](http://joxi.ru/EA4Rw3xHXyZbWm)"
"> That might just be a case of ""play stupid games, win stupid prizes"".

That is how I am thinking of this feature. There are cases where the compiler can definitely determine if the user is doing something wrong, but also where it _might_ be doing something wrong. The [`Span<T>.ToArray()`](https://docs.microsoft.com/dotnet/api/system.span-1.toarray) is another example. If a user calls `ToArray()` and `T` is known to be ByRefLike, the compiler could issue a failure. However, if `T` isn't know at compile time then it would be up to the implementer to have handled this appropriately using something like the proposed intrinsi-fication of `typeof(T.).IsByRefLike` in this document. The updated `Span<T>.ToArray()` would look as follows and handle the case at runtime. The other APIs in question would have similar checks.

```diff
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public T[] ToArray()
{
+    if (typeof(T).IsByRefLike)
+        throw new InvalidProgramException();

    if (_length == 0)
        return Array.Empty<T>();

    var destination = new T[_length];
    Buffer.Memmove(ref MemoryMarshal.GetArrayDataReference(destination), ref _pointer.Value, (uint)_length);
    return destination;
}
```"
"Do we have an issue somewhere to clean this up? Throwing inside dispose isn't a nice thing to do, especially when you have inheritance involved. There are a bunch of places in this PR that will leak stuff on failed dispose 😆 

I realize that you didn't make it worse in this PR, but it is gross so I want to make sure it's on someone's plate to fix. "
"Crap - the tree from the quarantined test jobs does appear to have https://github.com/dotnet/aspnetcore/commit/76fbd1a2831ae0d8c73afd2f3c7d8c531223a8b8, but doesn't produce binlogs. I'll see if I can find another public build since my commit that has the failures"
"this feels like a terrible nit, but all the other options are `--twoDashes` style, so this should probably be `--embedding`, right? 

(except `-ForceV1` which maybe raises more questions - maybe predates the other args)"
"Noob question 😅Does `[iOS (13,0)]` not mean anything 13+? Then are there two Exports for the same selector? How does it get resolved?"
"Hmm, yeah, I can see how those types are a disaster in a structural comparison. For example, to structurally compare two `List<T>` instantiations, we fan out to an insane number of comparisons between instantiations of the same generic types for different type parameters, which again fans out more, etc. The cycles are very long and apparently don't get to a depth of five before we run out of memory. I stopped it in the debugger and observed a relation stack 70 levels deep that still wasn't considered deeply nested. Tough one!"
"@github @github @github Ok, I am using the SharedFramework SDK to make a new `Microsoft.NETCore.App.Runtime.Mono.<RID>.Sdk` nuget - it seems to be working at least for `iossimulator-x64`.

There are some gross cmake hacks in here, too, because I don't really know cmake.

Could you take a look at what's here so far.

Next steps: update the workload manifest to use all these new nugets.  Figure out some way to test this. 

(I tested that the msbuild target works by copy-pasting to a dummy project and setting the appropriate props and looking that the properties are getting set to reasonable-looking values.)"
"Forgive me if it's a stupid question, but what's the point of adding an empty object as a value if we are only checking ContainsKey? Can't we set the value to null and get rid of the readonly property?"
"Yeah but that looks gross if I have to do it like this 
```
private static byte[] LookupTable => new byte[] {
    (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
    (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
    (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E',
    (byte)'F',
};
```"
"You're nullable disabling/enabling around the closing brace?

Regardless, yes, it's possible for someone to implement Fail in a way that still returns, but that goes against the purpose of the method.  If we held true to the possibility that someone did that, then we'd need to remove `[DoesNotReturnIf(false)]` from Debug.Assert and all such methods, which would be terrible. #Resolved"
This is a really confusing way to declare flyout... I mean I get what it does but holy crap did it hurt my head for a second. Can you please flip this if statement around even though it will increase nesting.
edit: I am stupid
"Part of the *intention* -- and *maybe* unnecessary? -- was that we'd only emit the `brew install` commands for applications which are not present.

This check can be done for `@(RequiredProgram)`, but not for `@(RequiredPackage)`: how do you check that the package is already installed?  ¯\_(ツ)_/¯

Then again, I'm not sure if this will be an *actual* problem in practice.

I have similar fears about `%(HomebrewTap)`: what happens if the same `brew tap` command is executed multiple times?

In my case, it errors, but it doesn't *error* (?!):

```bash
# I already previously ran `brew tap grendello/xawindeps`

$ brew tap grendello/xawindeps
Updating Homebrew...
==> Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==> Updated Formulae
container-diff               fwup                         gradle-completion            kibana                       logstash                     opa                          pgroonga                     postgresql@9.4               pushpin                      unrar                        wtf
file-formula                 git-quick-stats              groonga                      libmagic                     nexus                        osquery                      picat                        profanity                    rocksdb                      weaver

Error: Could not link:
/Users/jon/Dropbox/share/man/man1/brew-cask.1
/Users/jon/Dropbox/share/man/man1/brew.1

Please delete these paths and run `brew update`.
$ echo $?
0
```

I'm not even sure what to make of this state of affairs. :-/

Fortunately, reinstalling a package is a no-op:

```bash
# I previously ran `brew install grendello/xawindeps/mingw-zlib`
$ brew install grendello/xawindeps/mingw-zlib
Warning: grendello/xawindeps/mingw-zlib 1.2.11 is already installed and up-to-date
To reinstall 1.2.11, run `brew reinstall mingw-zlib`
$ echo $?
0
```"
I'm not sure using this `<PackageReference/>` will work? `xabuild` is this terrible thing that references `MSBuild.exe` directly.
"It doesn't report L3 on 12 core eMAG I have access to, Trust me, Windows team is aware and helping us here ;-)

> Can we not do something like the following?

No, only when we find a reliable mechanism to detect LLC or switch to something else to calculate Gen0 size. Till then we should not trust whatever API gives us or we might stuck with 256Kb Last-Level-Cache on a 30 core machine and hit a terrible penalty on GC-intensive workloads.

Small/Destkop class hardware should not be hurt with this intrinsic, for e.g. 8 cores it picks 1Mb cache (leading to 1.8Mb gen0 size) and for single/dual-cores it's around 480Kb for Gen0."
"Yes, though it took me a while to walk through this all (it's unpleasant that there's no grammar we can just look at at this point).  

Here's the chain of productions through which we can see the 'GeneratorParameter' being passed down:

```
GeneratorDeclaration[Yield, Default] :
  function * BindingIdentifier[?Yield] ( FormalParameters[Yield,GeneratorParameter] ) { GeneratorBody[Yield] }
  ... elided ...

// FormalParameters[yield,generateparameter] leads to:
FormalParameter[Yield,GeneratorParameter] :
  BindingElement[?Yield, ?GeneratorParameter]

BindingElement[Yield, GeneratorParameter ] : See 13.2.3
  ... elided ...
  [+GeneratorParameter] BindingPattern[?Yield,GeneratorParameter] Initializer[In]opt

BindingPattern[Yield,GeneratorParameter] :
  ObjectBindingPattern[?Yield,?GeneratorParameter]
  ... elided ...

ObjectBindingPattern[Yield,GeneratorParameter] :
  ... elided ...
  { BindingPropertyList[?Yield,?GeneratorParameter] }

BindingPropertyList[Yield,GeneratorParameter] :
  BindingProperty[?Yield, ?GeneratorParameter]
  ... elided ...

BindingProperty[Yield,GeneratorParameter] :
  ... elided ...
  PropertyName[?Yield, ?GeneratorParameter] : BindingElement[?Yield, ?GeneratorParameter]

PropertyName[Yield,GeneratorParameter] :
   LiteralPropertyName
   [+GeneratorParameter] ComputedPropertyName
   [~GeneratorParameter] ComputedPropertyName[?Yield]
```

So, if you have:

```
function * foo({ [x] : ..., [y] : ... }) {
}
```

Then 'generator parameter' is used ot indicate you're creating the parameters for hte generator.  And eventually that flag bubbles down to when you're doing the computed properties.  And, within those computed properties, yield is apparently disabled.  Meaning you can't use a yield expression inside a computed property name (which is not a terrible thing IMO).

(Hopefully i'm reading that right).

Now, oddly enough, outside of a generator parameter, i think it would be legal to use 'yield'.  so if you had:

```
function * f() {
   var v = { [yield 1] : 1 }
}
```

Then that would be fine.  'generator-parameter' is the context flag that enables us to flag this down.
"
"> I don't like it. I think we should not do this if we can't move the whole feature over (analyzer and diagnostic). I worry that we'll just end up with crap left behind that we never get to. But not moving this at all, it highly motivates solving this in an appropriate manner.

From an end-user perspective, this will make no difference at all. They just need the analyzer on CI, and code fix in IDE (regardless of whether it is invoked from a NuGet package or from an implementation in IDE). My point is, do we think it is worth blocking a user feature (CI enforcement) on just the fact that we'd like to cleanup and port the fixer to NuGet package?"
"> We are making the string marshaller types public, so the innovation that can be applied to them will be fairly limited.

I'd hope we have some latitude here, but your point is fair. I don't think this argument moves me much though.

> One of my motivations for doing this is to reduce the engineering dept in NativeAOT. The built-in system in NativeAOT is using different set of helpers for interop. I wanted to use this as an opportunity to get everything on the same plan.

Ugh. Well crap... this does change my perspective. I agree reconciling all of them would be a win. I will say the new entry points do seem to clutter the implementation and make something that is nicely standalone and easy to reason about more complicated. I guess I'm going to have to review this in detail. I think this is worth exploring."
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"These relations are insane! Everything looks good to me though! Perhaps remove the newline before the curly braces when starting interfaces though for style, but your call!"
"> wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
> [sceen](http://joxi.ru/EA4Rw3xHXyZbWm)

sorry, wrong autocomplete from github."
"@github Sure enough if there's people enthusiastic about it! It's not trivial to rebase it, but it's not completely terrible either. I might be a bit busy during the start of this week but might have time in latter half. Feel free to message me here and push me forward again If I don't write an update here during this week. :-)"
"This is kinda gross. This namespace doesn't exist in Ignitor, but I could make an empty one if that's cleaner?"
Oh crap! I thought about that when I started to write the tests and then I forgot about it!
"@github 
Yea stupid me, forgot to check in the added file.  Its up now.  I moved it because it is now used in three places TimePicker, DatePicker, & Entry.  The reality is, it will most likely need to be used in more places.  Check that out again and if you want to move the BoolEventArgs somewhere else, like a separate file then we can do that."
"## TODO for this PR
- [x] Update IDL with `Has...` functions
- [x] Runtime error when `_globals->CreateChild()` is being assigned (only when loading settings.json, fine otherwise)
- [x] Update spec and propagate changes from spec
- [x] Profile has a few settings we handle manually (i.e. BI alignment). I need to hook those up properly too
- [x] ~(Bonus Points) _maybe_ make these settings observable (we'll need that soon anyways)~ Nope

(new items!)
- [x] Fix `startingDirectory` being null
- [x] Fix tests
- [x] merge master (new Profile setting)
- [x] (after #7877 merges) address ""TODO CARLOS"", copy commands/keybindings/schemes in globals 

(new items 2!)

- [x] fix/add tests
- [x] remove IInspectable crap
- [x] fix/test Copy

(new items 3!)

- [x] really do get rid of `IReference` internally"
"Tagging subscribers to this area: @github/ncl
See info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

Note, the old Begin/EndAccept methods support doing an accept and receive in a single operation. Unfortunately the API for this is terrible and forces allocation. It's also not currently supported on non-Windows platforms. So, replace this with a helper routine that performs an accept followed by a receive, and works across all platforms.

Contributes to #43845

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>geoffkizer</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`area-System.Net.Sockets`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
@github how gross is this? Having this here avoids a second dictionary lookup per page invocation.
"I'm not sure that's necessarily an improvement?

If there should *never* be more than one License file, should we `<Error/>` on it?

If there *should* be more than one…but we only ever use one…wtf should happen?

This just ""feels weird""."
"Okay going to show my C++ noob here, what's the proper pattern to do this call then, do I need to explicitly copy the string into another variable, like hostFxrPath for it not to get destroyed?"
"Kinda nasty, but I think I did it correctly within the locks, and added a gross test that adds/removes a bunch of schemes for correctness"
"Verified, insane. "
"See, I wanted to ensure that whatever set of args the user provided always generated a unique string. Yea, if the user puts all the args into a keybinding/command, this will be stupid long like this. At that point, the user should probably have a better name they could give the command."
"Yeah, I'm not a fan of any of these extension methods that all take lambdas that call each other. I only looked at cleaning up the solution provider ones, but I can have a pass at the rest. I think this is part of an existing one that I pulled the filtering code out of, but the diff of this file looks pretty terrible in general."
"yeah, no problem, as I said, I'm terrible at naming :) "
"Are there any custom triggers being used to represent other types of triggering, or is it really being used as ""here's a way to pass ambient state along for the ride""? I recognize this might churn stuff, but it very much feels like this CustomTags exists on trigger just because it was the convenient type that happens to be there.

Three interesting, potentially controversial, and likely terrible ideas came to mind while writing that previous sentence:
1. I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.
2. Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then _perhaps_ we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could _imagine_ people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am _not_ saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that _also_ might fix this problem too, I can't help but notice the coincidence.
3. Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.
"
"If we allow `checkExpressionCached` to continue, the relevant symbol still ends up marked referenced via `checkExpressionCached` -> `checkIdentifier` -> `markAliasReferenced` -> `markAliasSymbolAsReferenced`. In other words, it's not only `markExportAsReferenced` that will end up marking it referenced.

So I think it's possible to alter `markExportAsReferenced` instead of `checkExportSpecifier`, though it may be a bit more awkward since `markExportAsReferenced` takes a couple different kinds of nodes.

And then we do still need to handle the other code path too. For that, nothing stands out as a great option. It feels like an `export type` ancestor check is possible, and similar to other checks that `markAliasReferenced` does already for example (`isInTypeQuery`), but depending on where we try to check, it could be an arbitrarily long ancestor walk.

I guess the choice I'm leaning towards for this other code path would be a check in `checkIdentifier` for the `node.parent.parent.parent` being a type only export declaration. This would be similar to the check for a property access expression and would go around the call to `markAliasReferenced`. Feels a bit gross, but we can know the exact ancestor to try to check from here."
"No, the feature is only set if an activity is created. (also there really should be comments about these different sections, maybe vs. sometimes, wtf?)"
"I don't think this is a terrible idea, but maybe one we do in another PR?"
"Downloaded the branch and tested it. Yeah, this works fine. And scenarios like ""opening the search box while the tab switcher is open"" would probably fall under the ""play stupid games"" category. Fixing this is probably more effort than it's worth right now, so good enough for me!"
"`_set_tcs_result_ref` does not propagate user's exception from whoever is awaiting the task.

It could only throw if runtime is in some terrible state already. In such case, I'm not sure what is the correct recovery.
As it is, the exception would bubble to main loop, as this is promise callback.

I at lest moved both `mono_wasm_release_cs_owned_object` and `teardown_managed_proxy` to `finally()`"
I guess we have to account for the offline client here which is gross. Yet another reason to figure out #7805.  
"_technically_ yes. But also technically, a caller could be stupid and set `FoundMatch(true)` _before_ calling this. Or you could be me in the tests, and reusing the same `args` across multiple calls, because you're too lazy to instantiate multiple. So I always think it's good form to have the handler manually set a result like this, so that _no matter what_, the result is initialized to a failure state, and only set to success when we know we're successful. "
"I actually split it up into two parts - one for unpacking the json (`GetGuidOrGenerateForJson`), and another for doing the source/name GUID generation. I had to split it up like that because the profile doesn't actually have a reference to its own JSON. i could have theoretically had the profile re-create a blob of json and call the json parsing function, but that seemed insane."
"Hmm

Would it make sense having _stream on Connection as private protected? (probably a terrible idea)
Or have you considered a different name here or the base type? _streamWrapper on the base type?
Or at least a comment explaining why this is different from the base type _stream.

Same for new Pipe below."
"That shouldn't be the case ... o_O the title should never be empty because it was getting set by `updateSettings`

oh crap i just realized i made you make a bad/annoying change"
"Ugh gross. OK, maybe don't put it in by default and let people override it for now and file a follow-on to make `file://` smarter."
"\<aside> Yea, this ""Capabilities"" section I've always hated. I think if you're outside MSFT, then you don't have any idea what to put here, and ""capabilities"" is a _terrible_ heading for it"
"> This PR fixes #127365
> 
> The added code follows the `IExplorerCommand + app identity` method recommended by [Windows Blog](https://blogs.windows.com/windowsdeveloper/2021/07/19/extending-the-context-menu-and-share-dialog-in-windows-11/), which is the minimal code necessary to implement this feature, and has _not been integrated into the Inno Setup script_. I hope that these codes can be used as an inspiration, and the VS Code developers would find out a sensible way to achieve this feature.
> 
> ![Screenshot 2021-12-22 230721](https://user-images.githubusercontent.com/26765742/147120434-0c54a018-ea84-471b-9498-cf904baa7117.png)
> 
> ![Screenshot 2021-12-22 230859](https://user-images.githubusercontent.com/26765742/147120449-c6eeb092-9678-4ade-a317-9f18f267a94c.png)
> 
> The added codes are located at `/build/win32/shell-extension-win11`, including an action handler, a minimal sparse package manifest, build script and setup script.
> 
> Because these are not integrated into Inno Setup, a manual build process is needed:
> 
> Assume that VS2019 with desktop development workload is installed in the working environment. `build.cmd` can make the sparse package and `.dll` library file for handling menu actions, which are needed by Windows. It also self-issues a test certificate to sign the sparse package. (This maybe needs to be implemented in a more formal way.)
> 
> By executing `build.cmd` 3 files will be put in the `/build/...-win11/Release` directory, namely `menuhandler.dll`, `Key.cer` and `code-sparse.appx`. The certificate issuance and signature process will prompt to enter a password for 3 times, just enter the same password.
> 
> Copy these 3 files with `setup.ps1` to anywhere inside an VS Code installation, and execute `setup.ps1` with administrator privileges. After restarting explorer.exe, you can see the option of ""Open by Code"" in context menus of files and directories.
> 
> The menu action is handled by C++ code implementing the COM interface, while currently for older versions of Windows this is achieved by the installer to directly write into registry. So the COM implemention directly reads the keys from registry to present the icon and determine the executable file path, to keep it simple and stupid. Perhaps this approach needs further improvement.
> 
> Localization has not been implemented yet, but by reading the registry, it should be easy.

Can you record short video?"
Just me being stupid... :-P
"One option is to pass the string and a variable number of arguments, and only smash them together in a string if we're called to walk the stack.

I discarded it due to complexity for now. I could write up a performance benchmark and see how much it helps, but went with the simple and stupid thing for a RFC PR."
"Is a result task, it would allocate a `Task<FlushResult>`. 

Thought about adding an extension method called `.AsNonGenericTask`; but that seemed a terrible name."
"wtf.

```suggestion
            => new AbstractFormattingRule[] { new ChangeSignatureFormattingRule(),  Formatter.GetDefaultFormattingRules(document) };
```

i.e. why on earth are we making a singleton enumerable, just to concat a single known value onto it.  it's an array with two elements.  just have it be that."
"> I guess if it was OK for BindableLayout, it should be OK for Map too?

Either that, or we made a terrible mistake merging 5582. That implementation of Replace in `Apply` is very suspect.

It looks like Map.Pins is an `ObservableCollection<Pin>`, so while I don't like this implementation of `Apply`, it should be fine for this purpose. It looks like the implementation of `ObservableCollection` only uses `NotifyCollectionChangedAction.Replace` for a single item being set. So at least for this specific application, it shouldn't cause any immediate problems.

"
"Possibly this is an example of me trying to outsmart the compiler and in the end doing something stupid 😄 Was trying to achieve inlining this method in its usages, given that it's just a simple expression, to avoid unnecessary calls to this method. The compiler will be smart enough to inline it without the attributes?"
"As a side note, the reason fixing this is important even given the obvious uselessness of the construct `const {} = anything` is that we ought to be able to deliver accurate completions inside the `{}`. Prior to this fix, you got both `a` and `b` since that’s what `T` had in its domain, but as soon as you accept the `a` completion, the contextual type changes and therefore the inference changes and it becomes an error, which is a terrible experience."
"It's sad to see that the work on this seems to have come to a halt.
Implementing would-be-convenient functionality now requires insane workarounds.

Bumping this again, in hope to see this released ♥️"
"This is where we call into the action constraints. 

The reasons that I went this way instead of using something new to solve the problem:
- This is the simplest thing to do for now
- I'm not sure how common this requirement is outside of MVC.

The thing that this solves is selecting between a GET endpoint and a POST endpoint, etc. It seems obvious someone layering a CMS on top of MVC needs this functionality. Maybe I am just being stupid and this needs to be *built-in*."
"> Shouldn't this be done in the other ctor?

Yes, absolutely right! I knew to do that earlier then for some reason started working on something else and forgot about it. Thanks for catching that.

> Also how do you feel about passing in an ILogger \ ILoggerFactory instead to the ctor? This feels a little gross. This feels a little gross.

I did this because we already take a `serviceProvider`, so why complicate things for the consumer? Under what circumstances would someone have reason to supply a different `ILogger` than the one the service provider would offer? I'm not absolutely set against it, but would like to make a choice based on practical reasoning.

In the long term, we may need to consume other services too. If we keep adding them as extra constructor overloads one-by-one, it will not be a nice experience for consumers."
I flipped this because _calling the destructor manually is terrible._
"holy shit this whole function is magic

"
Gross. OK.
"@github could this be something as stupid as not giving mlaunch enough time to finish?

Here's a good run:

```
[05:25:47] dbug: test[0]
      05:25:47.1394590 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmpmlrVXC.tmp --output-format=XML
[05:26:08] dbug: test[0]
      05:26:08.8570810 Simulator configuration written to /tmp/tmpmlrVXC.tmp
[05:26:08] dbug: test[0]
      05:26:08.9515020 Process exited with 0
[05:26:09] dbug: test[0]
      05:26:08.9536870 Simulator listing returned:
```

That took 22 seconds to return any results

Here's a bad one:

```
[02:06:49] dbug: test[0]
      02:06:49.7723290 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmp3dqcCa.tmp --output-format=XML
[02:07:19] dbug: test[0]
      02:07:19.8645850 Process 4094 didn't exit within 00:00:30 and will be killed
```

Timeout is 30 seconds

How close to the wire is it getting?"
python3 wtf. Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?
