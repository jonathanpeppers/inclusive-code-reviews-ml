Body
"Are there other places where we do this kind of thing? I don't see any other places where we actually make use of the multiple-features thing. I understand how it works, but it feels gross. Can we put semicolons between them or something?"
"Ah, I've done something really stupid there haven't I?
😂"
wtf how did that happen.
"That's really a terrible style IMO. 😄 

Lack of braces makes various refactorings more complex and is one of the primary sources of bugs in a lot of C/C++ code."
"@github 
I have tested the multiplication on x64 and power. The program works fine on x64 and does not work on power Below are the console and generated IL codes for both plaforms along with the small test program. The only thing which I can think of is, this is too hardware specific and while passing '0x0000271000000001' int64 parameter as int32 parameter to mono_is_power_of_two function, power is somehow making it to power of 2 which is not happening on x64. 

Program:
public static void Main()
      {
          const ulong mul = 0x0000271000000001; // 1 + (10000ULL << 32)
          ulong val = 179769;
          ulong result = val * mul;
          Console.WriteLine(""val = {0}, mul = {1}, result = {2}"", val, mul, result);
      }

x64 console log:
root@dotnet-node3:~/dotnet-sdk-7.0.100-preview.5.22307.18-linux-x64/TestMultiplication/bin/Debug/net7.0# mono TestMultiplication.exe
**val = 179769, mul = 42949672960001, result = 7721019758346419769**
ppc64le console log:
root@dotnet:~/dotnet-ppc64le/runtime/artifacts/bin/TestMultiplication/Debug/net7.0# mono TestMultiplication.exe
**val = 179769, mul = 42949672960001, result = 179769**
Below are the IL code, on ppc64le multiplication instruction gets converted to left shit.
x64 IL code:
DTREE TestProgram.Program:Main () 0
BB0(dfn=0) (IDOM=BB-1): BB0
BB3(dfn=1) (IDOM=BB0): BB0 BB3
BB1(dfn=2) (IDOM=BB3): BB0 BB3 BB1
INSERTING SAFEPOINTS
BEFORE SAFEPOINTS 0: [IN: , OUT: BB3(1) ]
BEFORE SAFEPOINTS 3: [IN: BB0(0), OUT: BB1(2) ]
il_seq_point il: 0x0
il_seq_point il: 0x1
il_seq_point il: 0x8
i8const R20 <- [179769]
i8const R21 <- [42949672960001]
**long_mul R17 <- R20 R21 clobbers: 1**
ppc64le IL code:
DTREE TestProgram.Program:Main () 0
BB0(dfn=0) (IDOM=BB-1): BB0
BB2(dfn=1) (IDOM=BB0): BB0 BB2
BB1(dfn=2) (IDOM=BB2): BB0 BB2 BB1
INSERTING SAFEPOINTS
BEFORE SAFEPOINTS 0: [IN: , OUT: BB2(1) ]
BEFORE SAFEPOINTS 2: [IN: BB0(0), OUT: BB1(2) ]
il_seq_point intr il: 0x0
il_seq_point il: 0x1
il_seq_point il: 0x8
i8const R36 <- [179769]
**long_shl_imm R33 <- R36**"
"While checking what's consuming space this week in the AppData directory, I by chance came across this directory, and immediately warning bells started ringing. Both due to the size of the data it contained, and the name. ""RemoteWorkspace? Is this another data-exfiltration attempt without my consent?!"" was my first thought. Only (!) by doing a google search and by pure luck finding this very github issue did I find out that it's _yet another_ directory to maintain (clean out) where VS stores ton of junk.

Previously users knew about the option to delete the "".vs"" directory (and not infrequently got told by ""support"" to do so), but now there's yet _another_ directory, with a for-all-intents-and-purposes encrypted name, effectively **hidden** (worse, **intentionally** hidden) that I'm quite sure support don't have any idea whatsoever it even exists.

Some of the following could be considered ranting, but frankly I don't care anymore what you think when you dump waste products all over **my** storage, without neither my permission nor even the curtesy of telling me, much less providing the functionality to remove the crap.

@github 
> > so who delete db file left out?

> No one. It's just a cache.

To quote a greater person than I am: ""You keep using that word. I don't think that word means what you think it means"".

> This is equiv to the data stored by many apps in the .appdata folder. It isn't intended to ever be touched our used by the user.

There's a helluva lot of difference between ""cache"" and ""Dumpingspace landfill we take the liberty to rip off from the users. Let's fill it with excrements and never clean it, then we call it a _cache_ and go MUAHAHAHAHA when the users diskspace is completely consumend so it can't even update neither VS nor Windows itself after a while!"".

I have only used this version for a few weeks and already this ""cache"" is over a quarter of a gigabyte. Extrapolate until the end of the year, and the system volume would have zero bytes free space. Guess how happy I am to find out this is _intentional_.

I'm really, REALLY sick and tired of VS stealing (!) storage from me from all over the bloody place, without my consent. Now you created a mess where most users won't even know about this landfill you erroneously call ""cache"". I know about it now, so I can redirect that crap directory at the filesystem level to a junk volume I have redirected much other VS crap to, but what about the tens of thousands (or however many there are) users that _don't_ know about this? Are you gonna pay out of your own pocket for the downtimes this creates when they have to *reformat* and *install from scratch* Windows, VS, and who knows what other software, just because you filled up the users system volume -- behind their back, hidden in an obscure location they according to you shall never clean -- with data you erroneously call ""cache""?

I appreciate the effort to clean up the mess that the code apprently is, but replacing that with messing up users filesystems in an even _worse_ way is IMO not an acceptable tradeoff.

This could be fixed with a VS-wide setting, with user-interface, allowing users to redirect (and move, and clean) this directory, but the way it's currently implemented my position is that this is malware.

To round off... please learn what ""cache"" actually means before using that word again."
"Gross, but sure."
"No, the arrow function is fully annotated, but the assert declaration itself needs to be annotated. It's very stupid.

```diff
- const assert = (value: unknown): asserts value => { }
+ const assert: (value: unknown) => asserts value = (value: unknown): asserts value => { }
```"
"Thanks, @github.  Not stupid questions.  We handle merging.  I re-ran the failed leg and it passed.  Thanks for the contribution."
(I don't expect the perf hit due to filtering to be that detrimental on the AzDO build machine as it should be mostly empty as opposed to my HDD full of crap ;-).)
"Ah crap, sorry, was going through the servicing-approved PRs and didn't notice this hadn't been regular approved. Want me to open a revert?"
"Thank you for the debugging advice. I've spent few days trying comparing dasm files. It is very hard for me to tell what is exactly wrong, but I found some suspicious facts:
1. Regressions mostly occur when 'x' is a pointer (or ref variable). 
Here is the diff example https://www.diffchecker.com/fQLJQ4YW
2. Regressions mostly occur in `MoveNext()` method 
<details>
  <summary>Example</summary>
 <img width=""1201"" alt=""image"" src=""https://user-images.githubusercontent.com/18483133/147747869-a32338bd-d4fb-4ff3-89ad-2ea67fcc1b0f.png"">
</details>
3. Some regressed dasms show terrible PerfScore. Here is the example https://www.diffchecker.com/BQUzlt9K"
wtf
"The constructor thing on the collection is gross, but this works pretty much like what I expected. "
"If it is stupid and it works, is it really stupid? 🐴"
"Found the root cause. Had a stupid bug in the test (missing import for System) which caused Action to be error type, so the event implementation would not get matched with event from interface...
`ComputeType` indeed needs to be updated to ignore tuple name differences.

---

In reply to: [82700123](https://github.com/dotnet/roslyn/pull/14229#discussion_r82700123) [](ancestors = 82700123,82653989)
"
"I just noticed it looks like this isn't even an `InnerException`, but instead it's just used for to copy its `Message` to the `RpcException` that's ultimately thrown. Now I care less than before.

It's kinda gross the flow the exception message this way to the common throwing logic, but if that's really the best way to do it, just leave it as `Exception` instead of some derived type that makes no difference."
"> The complete absence of cancellation/timeout support in these code paths is terrible. Some streams allow sync operations to be cancelled by Disposing the stream.

The main SendAsync method is registering with the CancellationToken to tear down the connection/stream should cancellation be requested at any time before all the response headers are received, and the implementation enforces that the response content is fully sent before that point.
https://github.com/dotnet/runtime/pull/34948/files#diff-75931c95adb5205b557555a5cd4f966eR336"
"I'm of two minds here. 

I really like that you want to prevent the VT52 stuff from getting in the way or affecting the performance of the VT100 code. It's always nice to build something in a way that guarantees the other mechanism isn't going to be affected in any way.

However...

It's really not that big of a deal to change the `ActionEscDispatch` interface and method to have a parameter option if need be, it's not terrible to have a slightly diverging mode codepath in the `OutputStateMachineEngine` for this mode type, and I don't think there will be very much performance impact at all given the character parsing and twiddling of the VT engines tend to be a relatively small portion of CPU time when I've traced it in the past.

I'm a bit concerned that if we have two completely different implementations that it will be easier to completely forget about one when designing things around the other one and we'll be writing an exorbitant amount of boilerplate to do the 95% common things between the two of them.

Someone else (@github or others) are welcome to counter my point here. Just my opinion."
"I'm an idiot, I removed the TextDocumentIdentifier which was outside of our control and misremembered. YOu are 100% right"
"stupid efficiency question: Is it more efficient to have `createSignature` set these? (I'm guessing not, since probably composite signatures (1) are rare (2) have their own internal class.)"
"For now yes, although I've cleaned up all this crap"
"> > This is jank and it should work for any number of arguments even though 32 is insane. 64?
> 
> Changing the field to `long` would allow 64, I'd prefer not going bigger because then we'll need to allocate/lazy-alloc and have another field.

Sounds reasonable. I don't think allocating a `bool[]` once per hub method would be that bad, but it also doesn't feel that valuable to support a service argument after the 64th position. The startup error message is clear enough."
"> We'll have to discuss expectations. If we want to add tests, then we'll need a list.

We can def do this.  But team position (in the past at leasT) was that sanity coverage was covered by compiler.  i.e. new feature-work doesn't need to be done.  But ensuring existing features work fine (i.e. not crashing, not having a terrible user experience) needs to happen to merge into master.

We have a list somewhere.  @github can you point us at it?"
"I hate that the test param is named `closeOrDispose`, that's a terrible name for a bool param. But that predates this PR so not something to block on."
"> Actually I think I was stupid for obsoleting this at all. I'd actually say it's probably worth ""unobsoleting"" it. There's still value.

Fair point. Un-obsoleted.

> Hmmm you can validate to see if they're consumed at all in the Mvc 1_x / 2_x projects: https://github.com/dotnet/aspnetcore/tree/master/src/Razor/Microsoft.AspNetCore.Mvc.Razor.Extensions.Version1_X

There's not consumed there. Just the Razor tests. I guess that means safe to remove?"
Ugh yes I forgot this was the one stupid out-param function 
"Alright so this is a wack idea that might need socializing with the rest of the team, but I wonder if it would make sense to just combine this functionality with the `move-pane` action? Thoughts on the matter:
* `mptt` is kinda a black swan here - all the other short forms are two characters.
* for something like `mp -t 0`, the long form could actually just be `--tab` 🤔 
* `mp -t 0 left` now is a little weird, ""move the pane to tab 0 (to the left???)"" That doesn't make sense. The two options (`direction` and `--tab`) would have to be exclusive
* It's probably not _that_ insane to have two actions (`MovePane` and `MovePaneToTab`) that are exposed through a single commandline interface. 
* (as a follow up idea:) we could do something like `move-pane --tab 0 --parent 4` which would move the pane to be a sibling of pane 4 in tab 0. "
"(high horse) and *here* is where negative numeric types are handy!  *IF* (lol?) there were `uint.MaxValue/2` environment variables, this would become an infinite loop, as we'd loop from `uint.MaxValue-2` to 0 without nary a blip.

(Granted, that would require having a lib with `uint.MaxValue/2` environment variables, which is *insane*...but kinda/sorts shows the utility of negative numbers. :-)"
I'm stupid. PatternSyntax check already excludes a parenthesized designation. I'll adjust the comment.
"It has the base type of DocumentationProvider, not XmlDocumentationProvider. (I agree the names are terrible.)
"
"wtf...
"
"Well, so this _works_, but it has 2 problems:

1. Most consumers do not expect the very specific type the jsx factory function actually returns. Usually, this manifests in reassignments, where
```ts
let a = <div></div>;
a = <img />;
```
ends up being an error because rather than both being `JSX.Element`, the first assignment makes `a` a `React.ReactElement<HTMLDivElement>`, while the second line is a `React.ReactElement<HTMLImageElement>`. This is, unfortunately, a breaking change we'd force on people. It's not hard to fix (annotate `a` with the more vague `JSX.Element` yourself), but could be frustrating. That break reduces the appetite to take this change a bit.

2. Performance is _terrible_. Like beyond bad. This makes _every_ jsx tag tree in your program into a series of nested generic context sensitive function calls (and _most_ jsx apps have a _lot_ of nested tags!). That's just about the worst-case scenario for the type checker. If we could make nested context sensitive function calls much more performant to check, it's go a long way towards making merging this feasible."
This looks insane to me.
"Basically, it's not terrible if we offer keywords even when not always applicable.  That's still much better than *not* offering it.  Then, we could just make this cod really simple.  Basically: ""offer these things if it's in a parameter list"", even if that allows some things when not applicable."
"Wohoo. Five minutes after loading the PR and I can finally comment here. 

Oh crap I pressed Enter, another five second delay. 

Anyways yes this will fail if the file is missing. 

"
Wtf I know I changed that...
"Yea I can concur with that. I'd make sure that this is clear in the doc comment for this function, because it's definitely _not_ clear just reading the code wtf is happening here"
"> @github I think you meant to mention @github.

haha crap sorry!"
"I checked OS set to light and OS set to dark with the app following. If you switch it while it is open, it looks terrible. But if you close and reopen the page it's fine. I wasn't going to cry over that.

I can check and cross-reference the other bug I guess."
"This should be a more ""context free"" error message.  We certainly *don't* want the stack trace dumped to the ""error"" output, as this is user hostile (wtf are they supposed to do with it?), though that said, what are they supposed to do when this task fails, *period*? :-/

Regardless, I'd suggest:

```suggestion
				Log.LogCodedError (""XA3001"", $""Unable to generate `libxamarin-app.so`: {e.Message}"");
```"
"Loed, I'm stupid. Sorry for that."
"this is the meat of where things changed. unfortunately, the diff is terrible. effectively teh logic is pretty simple:

1. determine the expression we want to inline.
1. find the reference locations to inline and inline there.
1. if we had no conflicts, remove the declaration
1. add warning annotations for things like side-effects or moving code into conditionally compiled methods"
Gross 
"This is build time, but I agree this error message is terrible especially in light of the new convention-based inference of parameter sources. I want to track more information about the parameters when building up the RequestDelegate arguments which will lead to better errors, but I've already started on the culture stuff so I think I'll do this as part of this PR."
"We don't use it often (I think because people don't know about it), but if it makes things worse feel free to disregard this. It's sometimes cute, sometimes terrible."
"What's the best code pattern to do something like this? I feel like `Lazy` with a lambda is too heavyweight, and a `bool hasComputedIsAttribute; bool isAttribute;` is kind of gross (so I want confirmation before doing that). (Or did you mean something else by that? Not computing if `context.IncludePrivateMembers` is true or something like that?)"
"this seems inconspicuous, but also, wtf is it doing? A comment (below, outside the macro) might help enlighten as to why that's needed."
"> Does it need to be Roslyn specific?

Long term I think that terrapin will end up encompassing all of the tools in our build that contribute to how our DLL files are written. So there are some obvious examples that go past Roslyn: single file writer, F#, etc ... Hence I do think long term we will need a manifest file that encompasses the artifacts needed be the totality of these tools. 

At the same time I tried to write this section to be more general but had trouble doing so as we don't know the exact requirements of the tools. Given that the next six months is largely Terrapin focused I kept this doc fairly Roslyn specific to keep it concrete. 

I should add a section at the end though clarifying that the intent here is for this to envolve though. 

> So, I think we can have dotnet-build-dependencies tool that works with all managed binaries using a common set of entries that express dependencies.

As the end of the doc states, I'm terrible at naming. I'm fine with whatever name others agree on. @github do u have any opinions here?

"
HOLY SHIT that totally fixes it.
"> wait uh, I don't think we need this. Win+down will minimize a window

Ah crap I didn't even know about this shortcut 😅
Ok so with this shortcut, the user can minimize to tray with the keyboard as long as `minimizeToTray = true`.
What about users who have `minimizeToTray = false, alwaysShowTrayIcon = true`? They may not want all minimize actions to minimizeToTray, but they'd likely want some way of sending the window to the tray considering they want the icon there. Perhaps it should be a system menu item? Or maybe it should be a tray icon menu item? 🤔"
"Stupid context specific diff, did not notice."
">  all while continuing not to have evidence that this is actually a hot path for real-world apps. 

Signals Rosyln would move away from ImmuntableDictionary for a fast Dictionary clone method https://github.com/dotnet/roslyn/pull/47503#issuecomment-687917289

> Yes, ImmutableDictionary is really bad. We just haven't had cases yet that fell into the patterns for which we have production-ready alternatives. The main scenario that we have the ability to improve today is collections with the following characteristics:
>
>* The dictionary is built up from empty, as opposed to built by transforming a previous collection through add/remove operations
>* The collection has more than a few elements, but less than ~10K elements
>
>For this we could switch to an immutable wrapper around `Dictionary<TKey, TValue>`, similar to how we use `ImmutableArray<T>` instead of `ImmutableList<T>`.

/cc @github

and

> My gut tells me this should be a slam dunk win. The vast majority (probably nearly all) of cases where we use ImmutableDict, it's not to benefit from what ID is decent at, but just to ensure it will not be mutated post creation. For that purpose it's actually a pretty terrible choice and adds a tremendous amount of overhead for functionality that we're not needing in those scenarios.

/cc @github

Also for lockless read Dictionary, with very infrequent updates (where reallocating the entire dictionary is more lightweight than taking a lock on every read, or using `ConcurrentDictionary`) e.g.
``` C#
class LookupTable
{
    private Dictionary<int, string>? _lookUp;
    private readonly object _lock = new ();

    public bool TryGetValue(int key, [MaybeNullWhen(false)] out string value)
    {
        // No locks required for read
        var lookUp = _lookUp;
        if (lookUp is null)
        {
            value = default;
            return false;
        }

        return lookUp.TryGetValue(key, out value);
    }

    public void Add(int key, string value)
    {
        lock (_lock)
        {
            // Clone + Add
            var dict = _lookUp?.Clone() ?? new (capacity: 1);
            dict.Add(key, value);
            // Switch reference
            _lookUp = dict;
        }
    }

    public void AddRange(IEnumerable<KeyValuePair<int, string>> collection)
    {
        lock (_lock)
        {
            // Clone + Add
            var dict = _lookUp?.Clone() ?? new(capacity: 8);
            foreach (var entry in collection)
            {
                dict.Add(entry.Key, entry.Value);
            }
            // Switch reference
            _lookUp = dict;
        }
    }
}
```"
"Since we're having to update what is installed with VS too, can we just fix this for good? This was a terrible hack that's caused other problems in the past."
"Technically, 'an' is correct since MS is pronounced ""em ess"", and that leads with a vowel sound... :smile:

(English is a terrible language.)"
"Typo: overflow ar runtime

You basically say ""We are only able to provide an algorithm that fails at non deterministic occasions at runtime until you remove a safety net ( which many developers are not allowed to remove). Good luck with that."". I would say that anything, even the most terrible algorithm, is better than obviously buggy code."
"```suggestion
                        if (interfaceMethod.HasInstantiation)
```

If `interfaceMethod.HasInstantiation != methodImpl.Body.HasInstantiation`, terrible things will happen below, so we might as well assume that and consider the Body check redundant.

I believe InstantiateSignature is going to be a no-op if the constrained type has an instantiation because that part is already instantiated."
"Ideally we'd probably also check if `type.flags & ts.TypeFlags.TypeReference` just to be sure, but I don't think we'll do something stupid like `enum Array {}` anywhere, so it's likely safe to assume it's a `TypeReference`."
"@github Thanks. That makes sense. But in that case, it seems like its not really ok to be conservative about when to do the transformation? eg right now it would reject

```
type NotTransformed<T, U, V, W> = keyof { [K in keyof T as U extends V ? (K extends W ? K : never) : K]: T[K] }; 
```

even though it *is* distributive wrt K.

[edit: never mind about the last part, it is a bug, and it's fixed in the nightly. Sorry should have checked that first]. Can you explain what's going on with f3's parameter type? We know that `T1<M> extends T2<M>` and that `T2<M> extends T1<M>`, so the nested conditional *should* evaluate to `boolean`, but it doesn't seem to. Is that a bug? Or am I doing something stupid here? The really weird thing is that if I change it to `T1<M> extends T2<M> ? (T2<M> extends T1<M> ? true : false) : 42`, then f3 doesn't accept `true`, `false` *or* `42` as its parameter:

```
foo.ts:32:4 - error TS2345: Argument of type 'boolean' is not assignable to parameter of type '""a"" | ""b"" extends T1<M> ? true : false'.
```
"
"I see and understand the risk now.

I don't speak enough languages to demonstrate a counter-example, but I would not be surprised to see one. I think the only thing that is ""right"" in the sense that it can't go wrong in this way is to just have separate resources for each of the ""several strings we show user here"".

How many strings are we talking about if we split them out. Unless it's insane, I'd recommend doing that and eliminating even having to worry about this.

@github What do you think?
"
"Probably unrelated, but this is a terrible error message. We should say _what_ the inconsistencies are. #Resolved"
"Crap I broke something in the merge, I think the automationPeer is getting torn down in the wrong order. It's crashing on close again. 💩 "
`WTF?` WTF? 😛 Debug spew message??
"You're right - I was stupid enough to trust ILSpy to resolve the right dependency - and it resolved 3.1 version ... My bad.
In that case this should work (you would get a RUC warning when calling AddSingleton)."
It is a terrible terrible url for vsdrops. That is what it is used for a path in a vs drop. 🤦 
"> The performance of this is terrible for large buffers.

This should no longer be the case with .NET 6. Are you still seeing that?"
wat...  seriously.  wtf :)
"@github Thank you, that's the kind of response I was hoping for.
So is this a inherent design flaw of the original monaco editor (You are the expert on original Monaco)?
If so, do you have some ideas how we can mitigate this stupid design flaw? (Global solution to a local problem does not seem to work, (no surprise)).
(In other words) What can be done?"
"Yes, but I was thinking, is this ever going to be """" ever? That might seem strange for the API user, and I did not want us doing something wrong, returning """" and end up with issues. (mainly, ""I don't want me changing this ever to do something stupid"" ;) )"
"Oops. Stupid tab/spaces settings!
"
"This name is terrible.  Maybe `IsIdentifierAndNull(...)`?
"
"If you're going to make this less terrible, we probably should remove the . after this so it's grammatically correct.
"
"prototype assignments jump from the assignment location to the location of the constructor function and continues walking up the tree looking for type parameters. It does *not* fork and continue looking from the site of the assignment.

In a [hilarious tweet](https://twitter.com/sanders_n/status/1162131784009523202), I provided some code where this  difference could be observed, but it was clearly insane. I think this is a good solution, because it makes prototype assignments act as if they are effectively nested inside the constructor function, in the same way that methods are nested inside classes in modern JS."
"sorry about that delay I did not check the base branch, In fact I'm surprised I managed to apply a diff on master while it was fixed in `5.0` :D 
i feel stupid
"
"@github Are there any docs on the low level design of liveshare?  specifically, i'm looking to understand how it works from a client/server perspective.  Where is information expected to live?  Who is responsible for ""source of truth"".  How clients and servers synchronize and ask questions in a way that is consistent, etc. etc.

For example, here's an easy sort of problem i can envision, which i'd like an undertanding of how it is handled:

1. on the client (without roslyn), user makes some edits.  this increases the length of the file.
2. client then wants to classify the text at the end of the file.
3. tehy then communicate with server, but server doesn't have text/project that matches what client has.  server passes requests onto roslyn, which crashes because invariant is broken.

Now, given this is such a simple scenario, and you're likkely not crashing.  You have presumably solved this in some manner.  For example, some sort of syncing.  Or perhaps validating that the request can even be asked on the other end.  However, those designs and invariants are not clear here, and as such it makes it *very* hard to tell if the code here is correct.

--

To give some context, i was involved in the early days of the LSP with the TS lang server.  There were all sorts of assumptions and terrible practices going on between the clients and the servers, and at the end of the day, it became necessary for tons of hacks to be added all over the place to just paper over these places where little discussion/design had happened, and people jsut did random stuff because it seemed to work without understanding the implications of those decisions.

I would *very very* much like to avoid that in roslyn.  For a very large part of it we've operated under the assumption that it's much better to have strict invariatns and to fail early to ensure that people ""do the right thing"".  If we're still abiding by that, that's great.  But if we're not, it's important to document so we cna ensure everyone's mental model of responsibilities is accurate.

Thanks!"
"As I briefly mentioned in chat before the holidays - this _can_ be localized, but it will _hyperexplode_ the unittets. In my opinion, we should probably not hyperexplode the unittests. The solution to the unittests problem appears to be ""rewrite the entire thing"", but I need to do a bunch more investigation of WTF is going on there. I think the right path here is to do this non-localized for now, and file a follow up for adding localization to them. That way, we won't need to include a massive ""rewrite the unittests"" change as a part of this already hefty PR. Thoughts?"
"Okay, the Terrible solution I have is to have a `.../CommandlineArgs/Resources/en-us/Resources.resw`, and include it manually in each of TSE and `TerminalApp`. That'll get the resources added to the correct libraries, so `RS_A` will still work, regardless of which dll it's being called from. 

@github Will that still work for localization? "
Oh crap. I think I messed up the commits. Well this is indeed a lengthy thread. In fact I think this is most commented PR I've ever made on Github. I'll force push later.
"@github any specific preference to the preferred sort, or just sort via StringComparer.Ordinal or something?

Oddly the current comparer for the hashset-based comparer is PathComparer, which does a bunch of extra comparisons around relative pathing and such to attempt to ""normalize"" the path. I was going to just switch this over to an ImmutableSortedSet but PathComparer doesn't implement that (since it would seem insane to do so)."
"So this is a good point.  For clarity, whatever newline sequence you wrote, we will embed into your converted string.  This means from the language/compiler perspective, on that machine, the literal has the exact meaning as before (no semantics change).

Where it gets subtle though is the absolutely insane behavior of git where it may take a file and just change newlines *even that are language relevant* when sent to *another* machine.

In this case, the refactoring is in line with the lang and compiler.  However, it is *git* that ends up causing issues here as it thinks it is sensible to touch programming lines that relate to content.

--

Note that this is a refactoring though.  It is opted into the user, presumably because they actually think this is better.  And it will be very clear that a single line became multi-line.  So i think the user can be trusted to decide if that is acceptable for them given their git config."
"WTF are ""reverse forwarders""??
"
@github @github Is the stream context completing the transport output like this a terrible hack or an elegant solution? IDK 🤷 
"> Crap, before this will work we need to update the spa-templates submodule to reference the dotnet7 feed & ingest it. I'll update that repo now.

Presumably we also need to back-port this into release/6.0 as runtime's 6.0 contains the updated transport package."
"➡️ In the total absence of enforcement to date, we did a terrible job making sure tests clean up after themselves. I fixed enough cases in #25558 to make sure this change is viable, but I expect to see this condition hit in practice. Earlier portions of the cleanup code guarantee that all synchronous and immediately-queued cancellation requests are processed before reaching this condition. **All cases where this is hit are a bug.** However, the condition relaxes the overall acceptance criteria for this large change and allows us to pay off the debt over time."
"What happens when you have two text editors open to settings.json? Best case scenario, one tells you ""this file changed. want to reload it?"".

This is a case of ""play stupid games, win stupid prizes""."
"Not nearly as bad as enabling NRT for the first time. The `default` constraint is the only place I had trouble. We desperately need a code fix for this particular error or we're going to be fielding a ton of ""WTF"" questions."
"I concur - almost seems like we should have `ProfileSettingContainer : SettingContainer` that allows for reverting to the parent, but only for settings in profiles.

All this is terrible, but let's not pretend our settings model was designed for a GUI."
Ohhhhhhhhhh.  I'm an idiot.  we can use the return value to figure this out.  tnx.
these diffs are terrible.  I'm not srue why it threw it off so much to indent.  working on this.
"@github Can you add a comment stating the intent then? I could totally imagine somebody coming by, saying ""heh, that's stupid it's not sorted"", and adding in the exact thing you're removing.

(bonus points for having some sort of visible grouping so it's clear to users too.)"
"> Possibly a stupid question, but why rewrite this?

Short-circuiting binary operators imply a control flow. For example, if ```a``` in ```a || b``` is true, we jump over evaluation of ```b```. This should be explicitly reflected in the graph through links. See LogicalOrFlow_01 unit-test in IOperationTests_IBinaryOperatorExpression.cs.

---
In reply to: [162218816](https://github.com/dotnet/roslyn/pull/24263#discussion_r162218816) [](ancestors = 162218816)"
"I was going to suggest using `Task.WhenAll` to avoid the long declaration of `originalNodes` then I realized `GetDeclarationAsync` has side-effects. Maybe just call it something like `AddInlineWithVarEditsAsync` to make it more clear what it actually does? Sorry, I'm terrible at naming things, but I'm sure you know I'm saying :)"
"We use it to let the solution crawler back off. We have logic to back of if we are editing our files (to avoid us causing lots of GC for example), but if say you're editing a Readme file or something else we don't want to be making that terrible."
"> In order to diagnose it, I used hardcoded DebugBreak() since even ImageFileExecutionOptions didn't like running against conhost - is there are better way to debug and test these cases without being so invasive on the system?

Not really, no. `Conhost` is gross to debug.

"
"> the `ApplicationContext` which is embeded in the native ALC - and yes - that name is TERRIBLE and has to go

The `ApplicationContext` which also contains an `ExecutionContext` which is a subclass of  `LoadContext`! So much context."
"This may be out of scope for this but the old (and new) behavior seem. wrong to me.
Let say the kernel was built without IPv6 support (or v4 in distant future). The file would be missing and we would always throw even if there is nothing wrong.

In many cases like this it feels it would be better to return empty collection. Since the networking grabs massive amount of information had several cases in the past when we thrown on stupid things even if the caller really does not care.  "
"Holy crap, I saw this issue weeks ago and didn't expect this one to ever get fixed."
"> ""Wouldn't be surprised if other components in the ecosystem exhibited the same problem.""

I agree this is very likely not the only one, it's just one that keeps popping up quite often. It's been a pain point for years (first on WPF, then on UWP, now on both MAUI and WinUI 3, etc.), and something that has received countless feature requests for. The solution many have come up with is to just roll their own collection types with support for ""range operations"", with the big drawback being though that since no UI framework among these actually supports the API, they're just forced to either iterate over items one by one (which is just terrible for performance), or just reset the collection and reinitialize it (which is also bad for performance, maybe just a little bit less, and also completely breaks all animations). It's just a very unfortunate situation where customers get frustrated, and they often have to both do extra work to build these helpers, and then still end up with a suboptimal experience. I mean, we have the same exact custom collection type in the Microsoft Store too, and it has the same exact issues (and I hate it). It's just a really common issue, and I'm saying I'd love for us to find the time to coordinate with the right folks and maybe try to finally get this resolved at least for .NET 8 🙂

I've also received multiple requests to add such a custom collection type in the .NET Community Toolkit, and I've had to reject them for the reasons mentioned above (it still results in a very bad experience, and I'd much rather just fix this properly in the BCL). The net result though is that at least for now, the API is not there and plenty of folks are frustrated.

> ""but my recollection is that it broke in a substantial way as soon as runtime merged this change originally.""

I find that surprising and I'd love to learn more about that. Even with the new APIs, as long as nobody actually calls them, there should be no functional differences in the way the currently existing APIs work at all. So I'm not sure I understand what broke. Are you sure it wasn't just folks trying out the _new_ APIs, and then reporting WPF crashing/breaking in that scenario? 🤔

> ""Would doing that be a less disruptive way for newer frameworks to get range support?""

I personally don't think that'd be the correct solution for this issue, for a number of reasons:

- The core issue is that right now, the various UI frameworks don't support multiple collection updates. Where they come from is not what's causing the issue. That is, even with a new collection type, you'd get the same exact crashes until the frameworks were updated to handle the args. And if they were updated, then there would be no reason to have a separate collection type in the first place, as it'd just be the same exact one but with two new APIs. Those should just be added on what we have.
- It'd make updating codebases much more tedious, as now you'd have to swap the whole collection type in all locations rather than just being able to opt-in into a range update whenever necessary.
- I'd argue it'd be an abstraction leak. You want an observable collection, the fact that some callsites would need to perform range operations on that is just an implementation detail of your viewmodels. You shouldn't need to use a completely different collection type just to support this.

I would really love for us to just manage to coordinate across the various teams and officially add support for this in a future release, not sooner than .NET 8 at this point. We could both update all underlying frameworks to support this (which I realize is non trivial work, especially since eg. WinUI 3 would likely need some new WinRT APIs and projections for this), and then provide the necessary migration docs, if needed. I believe this would be the best long term solution for this issue 🙂"
"I initially went along with this, but when usability testing it locally I remembered why I had done it this way in the first place.

Basically I'm using exceptions to show the users their error messages, so it really ought to be more user friendly then your actual problem being buried in amongst an Aggregate exception format and a bunch of stack-trace stuff. This all stems from me using exceptions to bail out of functions early when we find argument problems (url is null, doesn't exist) so I don't have to make every method return `Result<T>` where Result could have an error that should cause us to bail early or the value we actually asked for. If you can think of a better paradigm than using exceptions of that gross Result<T> stuff I'm on board, because I agree that using exceptions this way isn't great, it's just the best I could come up with."
"oh right. Stupid API doesn't do what I want. :grumble:
"
"I was just testing the cmd defaults and one was enough there, but if there are shells that need 2 or 3 then maybe this is a good idea.  It's a trade-off of size for every scenario vs. speed for some scenarios.

With my change, each TextAttributeRun is 20 bytes, so given there are 9001 of these created in the default cmd scenario, each increase by 1 in this small_vector costs ~176KB, which seems like enough we should think carefully about what to tune for, but not so much that bumping to 2 or 3 is terrible.

Is there any data on how often different shells are used so we could try to tune for the most common ones?"
"I have a terrible workaround for the symlinking issue, which (unlike the compression option) is consistent with our symbol publishing :)

Technically, iOS-style unversioned frameworks are valid on macOS, so... flatten the framework post-creation. That should fix the Catalyst build"
the previously display text was just terrible.
"As a sentinel, if we decide that `OutputCellIterator` is globally stupid for making the caller maintain the walk-count... (which it is... in my opinion...) we can globally change it at some point by finding all affected areas.

I know I don't need to convince you any more, just giving more clarity on my thoughts."
"Sorry for the noob question: does `""T""` and `""x""` stand for ""Type"" and ""Value"" respectively? I'm trying to understand a little bit of the code by checking some PR's (yours is pretty cool!)"
"> For this we could switch to an immutable wrapper around Dictionary<TKey, TValue>, similar to how we use ImmutableArray<T> instead of ImmutableList<T>.

My gut tells me this should be a slam dunk win.  The vast majority (probably nearly all) of cases where we use ImmutableDict, it's not to benefit from what ID is decent at, but just to ensure it will not be mutated post creation.  For that purpose it's actually a pretty terrible choice and adds a tremendous amount of overhead for functionality that we're not needing in those scenarios."
cref? This might also be a nice place to use the list syntax @github was doing since this will format like crap in Quick Info otherwise.
"Should the test that the value shouldn't change just live in the compiler?

If nothing, I wonder if this deserves a good comment in the code. If I saw this I'd go ""WTF"" and just delete it without a second thought."
"This has me thinking about how we possibly do this for the DxRenderer.

I imagine that we will either have to...
1. Form all this data into an alternate stream that looks like a TTF/OTF font instead of this old Windows Font format that GDI seems to understand on `AddFontMemoryResourceEx` and then feed it into [IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference](https://docs.microsoft.com/windows/win32/api/dwrite_3/nn-dwrite_3-idwriteinmemoryfontfileloader) per the documentation at [Custom Font Sets](https://docs.microsoft.com/windows/win32/directwrite/custom-font-sets-win10#creating-a-custom-font-set-using-font-data-loaded-into-memory).
2. Make the DxRenderer load this HFONT into a GDI HDC and then call [IDWriteGdiInterop::CreateFontFaceFromHdc](https://docs.microsoft.com/windows/win32/api/dwrite/nf-dwrite-idwritegdiinterop-createfontfacefromhdc) and use the resulting `IDWriteFontFace` normally.

I bet the second one is easier but is a little gross for using GDI inside the DX renderer. The first one is probably difficult because I think TTF/OTF always specifies fonts as vector outlines, so I'm not sure how we'd live-specify these. Probably a lot more math...

Just ideas. "
"I agree with Dustin on this one. I'd reckon that most [questions](https://github.com/microsoft/terminal/issues?q=is%3Aissue+label%3AIssue-Question) actually start out as ""bug report""s that stem from a misunderstanding or generally not reading the docs. 

It's not a terrible lot of work to swap out the tags. I know that I personally reserve the Bug tag for when I'm fairly confident something actually is a bug and either needs more investigation or is generally on the backlog somewhere. I suppose that's really `Needs-Triage`'s job. "
yes.  that name was terrible. changed to `preferredMap`.
"> Performance at the full solution goes from:

You'll get at least 60 seconds gain my moving from MSBuildWorkspace to direct creation of compilations from csc invocations in the binlog. MSBuildWorkspace is extremely terrible for end-to-end performance because there is no parallelism in the MSBuild evaluation.

csc invocations have a secondary benefit of improved accuracy."
"note: IDE pattern is to name these MyCodeAction in almost all cases.  That said, that name is pretty terrible.  So if you want to keep the name like this, i'm ok with that."
"I tend to agree that these are truly special cases—since the relationship between `for`/`htmlFor` and `class`/`className` comes from the mapping between HTML attributes and DOM element property names, the spelling similarity is not a coincidence, but it’s not a given either. You can imagine a world where the DOM spec decided to map the `for` HTML attribute onto `HTMLLabelElement['targetInputId']`, or the `class` HTML attribute onto `Element['cascadingStyleSheetClassName']`. Both of these would be terrible APIs, but my point is that despite the fairly small string distance between these substitutions, the string distance is not the reason they should be offered. So I’m unconvinced that they merit a change to the string distance algorithm."
"Sorry, the part that I originally found ""gross"" was that this call was ever in the `if` in the first place, not your changes; now that you've moved the parameter out though, it's at least a lot cleaner.
"
"`Assert.Equal` does an IEnumerable-based comparison. The performance of this is terrible for large buffers. So terrible that it was dominating the total time of test runs in the stream conformance tests.

`AssertExtensions.SequenceEqual` does a span-based comparison, which is much much faster. Like 20x or more. 

`AssertExtensions.SequenceEqual` also has some logic around reporting differences that's kind of nice, but that's secondary to the performance issue.

We should always use `AssertExtensions.SequenceEqual` for comparing buffers. `Assert.Equal` is fine for non-buffers."
"@github oh my you're right, I feel so stupid! Thanks"
"To my knowledge the spec is not generated when you add the packages we add, so I think @github is right that we should reduce the timeout. I made it 5 seconds, which is still probably more than is needed, but not by an insane amount if you account for slow machines."
"This is stupid, everyone knows what whitelist means, and ignorableAssemblyList means nothing on the first read."
"> 
> 
> This is very clever, and I like it. It looks like it won't harm performance, but I do think that some caution is called-for around all the thread hopping.
> 
> @github: thanks for always cutting through our layers of crap (both organizationally and code-wise) and _getting good shit done_ 😄

Thanks! I want to be super cautious here - as the potential damage is... nice -  and  I am absolutely not in hurry to commit this one before we are fully confident! Just want to make sure we keep working on it - as it gets bigger and I am quite senile :blush:

I any case I found another concerning case:
* Assume we search backwards for some word, such that the matches are in lines 10, 20, 30:
* In this case we find the match at line 30
* Then assume the user scrolls up and selects a text in line 15. Then the user clicks ""search previous""
* We  will select the match at line 20 (because our state suggests to move from `3/3` to `2/3`), though probably the user expected to get the match in line 10 (at least VSCode in this case selects line 10 and puts the state at `1/3`)."
"Yeah it's not fun to hook this up. Not terrible, but not fun."
"Please add a comment here explaining this type lives in the VS side of things and exists to be the proxy. It makes sense to me since we have chatted about it, but @github can attest to having to debug through other frameworks where there was no documentation on what lived in what process and it drove him insane.
"
"Oh, that makes it terrible
`text%2Fplain%3B+charset%3DUTF-8`"
Terrible 😁. At least have a bool or enum property.
"It's grabbing it off of the getter.  The assumption being that the getter is normally before the setter.  Here it's suboptimal, but not terrible.  We can consider trying to do better in the cases where the getter is after the setter.  But i just wanted to ensure we weren't totally breaking code by removing preprocessor directives as the highest order thing to fix."
"(oh, i'm also an idiot since i read this as `Open Brace` not `Open Bracket`.  But the above points still stand)."
"> How does GetDiagnosticsUpdatedEventArgs work exactly?

You can think of the IDiagnosticsService as a mapping from special ""keys"" to the set of diagnostics for those keys.  This method name is actually *terrible* as these aren't really events or args.  They're really just saying ""what are all the keys we know about for this particular set of args"".  In this case, we're asking for all the keys associated with a particular document.  We can then use those keys to actually find out all the diagnostics for that doc.

You could imagine this exposed behind a helper method (which is what i think i will do :))."
"Thanks for the notice & discussion! TIL 😄 , and it makes a lot of sense.

This actually ended up not changing much in the output: 107e10d908 only showed a few _very_ edge case tests get a small amount of extra messages. Not so terrible. Phew."
"Stupid question - won't some of the changes by overwritten by arcade in some point in time - I don't know the flow of those, but I see some files are the same and looking at history they are updated?"
"> Ping @github - let me know if you disagree with the justification.

I don't like it.  I think we should not do this if we can't move the whole feature over (analyzer and diagnostic).  I worry that we'll just end up with crap left behind that we never get to.  But not moving this at all, it highly motivates solving this in an appropriate manner."
"**This is a warning**.

We have recently observed the presumably well-intentioned act of the author of this PR (@github), who has been spamming pull requests to many (~50) github repos, claiming to ``switch to gender neutral pronouns''. In reality, the bot performs a dictionary replace of gendered nouns and pronouns, and the outcome is questionable at best, and literally harmful at worst. See:
- The bot did a terrible job at replacing these words - [EbookFoundation/free-programming-books#6801](https://github.com/EbookFoundation/free-programming-books/pull/6801/commits/5257301642c173e2dc4f034f8c0460ce7ea99de6)
- The code fails to compile at [rust-lang/rust#95508](https://github.com/rust-lang/rust/pull/95508)
- The bot ignores all context whatsoever at [moby/moby#43441](https://github.com/moby/moby/pull/43441)
- After initial PR being closed, the bot keeps sending PRs, effectly spamming the repos. For example, these 5 PRs were sent to the same repo within 2 days [#1](https://github.com/EbookFoundation/free-programming-books/pull/6801) [#2](https://github.com/EbookFoundation/free-programming-books/pull/6803) [#3](https://github.com/EbookFoundation/free-programming-books/pull/6804) [#4](https://github.com/EbookFoundation/free-programming-books/pull/6805) [#5](https://github.com/EbookFoundation/free-programming-books/pull/6806)

We have reviewed the changes in this PR. Most of the changed words are ""accidental gender pronouns"" - `he` as a prefix of `hello`, or `his` as a suffix of `this`, and both examples come from test cases where inline comments are used to split words (like `t/**/his`), and the PR wants to change them into `t/**/theirs` etc.. These changes are obviously not helpful at all.

To save more time for the open-source community, we recommend the maintainers of this repo to close this PR and ban this bot from further spamming."
"> Many workloads for which tasks were originally introduced, actually. Consider, for example, parallelized divide and conquer. A worker partitions its work into multiple pieces, queues identical workers to process N - 1 of those pieces, processes its own, and then waits for those other workers to complete. Also think about algorithms that require coordination between those pieces, such as various operations used by PLINQ (e.g. OrderBy) that needs to block each of the workers until they reach a common point so that they can exchange data and all continue on, and what would happen if one of the workers was throttled indefinitely

Today do the implementation of those kick end up doing Task.Wait?

> I think that's the wrong direction, at least for the foreseeable future. If we decided to go with an approach like the one proposed in this draft, I have trouble seeing it as anything other than opt-in, given all of the previously cited concerns, the potential for introducing deadlocks where they weren't previously, the potential for casting way too wide a net, the potential for negatively impacting the throughput of unrelated workloads, etc. _If such a mitigation was added as opt-in, and if enough testing demonstrated it was a good decision for certain workloads, then it could potentially be automatically opted-in for those, e.g. if you felt ASP.NET should always turn this on. Even there, though, I'd be surprised if in the current configuration that was a wise choice.

Yes I have similar fears but I'm looking for solutions. Maybe this isn't this one but there are aspects of this that seem interesting. Say we added a public API to enable this and it was opt-in, I could see the potential for adding a piece of middleware or filters that enables this on the current workitem before the blocking code executed. Something like this:

```C#
[HttpGet(""/blocking"")]
[EnableBlockingMitigation] // This name is terrible
public string BlockingLegacyCodez()
{
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

That filter could yield to thread pool to get off the current work item and enable mitigation on a unique workitem that's closer to this code. The equivalent of doing this:

```C#
[HttpGet(""/blocking"")]
public async Task<string> BlockingLegacyCodez()
{
      await Task.Yield(); // Make a new work item
      ThreadPool.EnableBlockingWorkitem();
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

Thoughts?"
Shouldn't this be done in the other ctor? Also how do you feel about passing in an `ILogger` \ `ILoggerFactory` instead to the ctor? This feels a little gross.
"If `Bottom` and `Top` are both `SHORT`, then can't this technically cast into something gross when it's returned as `unsigned int`?"
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"@github Those are the default settings for insane (just copied over so I could add a few more attributes). The allowed tags are separate from the allowed attributes. The current setting just says: if we allow iframes (which we don't) here are the allowed attributes for them. We can remove the line since it has no effect

 @github I'm good with removing `marked.sanitize`. The setting is deprecated and has known issues, which is why we added `insane`.

My concern is just that allowing CSS brings up a number of other considerations:

- Which css rules do we allow? Do we try sanitizing the css? If we do have a whitelist of allowed css, how do we handle feature requests to support additional properties?

- Do we want extensions to control the styling insides hovers at all? Right now we control the presentation and can try our best to make sure the hovers look ok with all themes 

- Enabling css expands the potential attack surface. If someone finds an exploit in Chromium related to CSS, it could potentially now effect VS Code too.

My feeling is that we should think through this problem more and find some other potential use cases. Issues labels seem like a very specific use case"
"wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
[sceen](http://joxi.ru/EA4Rw3xHXyZbWm)"
"> That might just be a case of ""play stupid games, win stupid prizes"".

That is how I am thinking of this feature. There are cases where the compiler can definitely determine if the user is doing something wrong, but also where it _might_ be doing something wrong. The [`Span<T>.ToArray()`](https://docs.microsoft.com/dotnet/api/system.span-1.toarray) is another example. If a user calls `ToArray()` and `T` is known to be ByRefLike, the compiler could issue a failure. However, if `T` isn't know at compile time then it would be up to the implementer to have handled this appropriately using something like the proposed intrinsi-fication of `typeof(T.).IsByRefLike` in this document. The updated `Span<T>.ToArray()` would look as follows and handle the case at runtime. The other APIs in question would have similar checks.

```diff
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public T[] ToArray()
{
+    if (typeof(T).IsByRefLike)
+        throw new InvalidProgramException();

    if (_length == 0)
        return Array.Empty<T>();

    var destination = new T[_length];
    Buffer.Memmove(ref MemoryMarshal.GetArrayDataReference(destination), ref _pointer.Value, (uint)_length);
    return destination;
}
```"
"Do we have an issue somewhere to clean this up? Throwing inside dispose isn't a nice thing to do, especially when you have inheritance involved. There are a bunch of places in this PR that will leak stuff on failed dispose 😆 

I realize that you didn't make it worse in this PR, but it is gross so I want to make sure it's on someone's plate to fix. "
"Crap - the tree from the quarantined test jobs does appear to have https://github.com/dotnet/aspnetcore/commit/76fbd1a2831ae0d8c73afd2f3c7d8c531223a8b8, but doesn't produce binlogs. I'll see if I can find another public build since my commit that has the failures"
"this feels like a terrible nit, but all the other options are `--twoDashes` style, so this should probably be `--embedding`, right? 

(except `-ForceV1` which maybe raises more questions - maybe predates the other args)"
"Noob question 😅Does `[iOS (13,0)]` not mean anything 13+? Then are there two Exports for the same selector? How does it get resolved?"
"Hmm, yeah, I can see how those types are a disaster in a structural comparison. For example, to structurally compare two `List<T>` instantiations, we fan out to an insane number of comparisons between instantiations of the same generic types for different type parameters, which again fans out more, etc. The cycles are very long and apparently don't get to a depth of five before we run out of memory. I stopped it in the debugger and observed a relation stack 70 levels deep that still wasn't considered deeply nested. Tough one!"
"@github @github @github Ok, I am using the SharedFramework SDK to make a new `Microsoft.NETCore.App.Runtime.Mono.<RID>.Sdk` nuget - it seems to be working at least for `iossimulator-x64`.

There are some gross cmake hacks in here, too, because I don't really know cmake.

Could you take a look at what's here so far.

Next steps: update the workload manifest to use all these new nugets.  Figure out some way to test this. 

(I tested that the msbuild target works by copy-pasting to a dummy project and setting the appropriate props and looking that the properties are getting set to reasonable-looking values.)"
"Forgive me if it's a stupid question, but what's the point of adding an empty object as a value if we are only checking ContainsKey? Can't we set the value to null and get rid of the readonly property?"
"Yeah but that looks gross if I have to do it like this 
```
private static byte[] LookupTable => new byte[] {
    (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
    (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
    (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E',
    (byte)'F',
};
```"
"You're nullable disabling/enabling around the closing brace?

Regardless, yes, it's possible for someone to implement Fail in a way that still returns, but that goes against the purpose of the method.  If we held true to the possibility that someone did that, then we'd need to remove `[DoesNotReturnIf(false)]` from Debug.Assert and all such methods, which would be terrible. #Resolved"
This is a really confusing way to declare flyout... I mean I get what it does but holy crap did it hurt my head for a second. Can you please flip this if statement around even though it will increase nesting.
edit: I am stupid
"Part of the *intention* -- and *maybe* unnecessary? -- was that we'd only emit the `brew install` commands for applications which are not present.

This check can be done for `@(RequiredProgram)`, but not for `@(RequiredPackage)`: how do you check that the package is already installed?  ¯\_(ツ)_/¯

Then again, I'm not sure if this will be an *actual* problem in practice.

I have similar fears about `%(HomebrewTap)`: what happens if the same `brew tap` command is executed multiple times?

In my case, it errors, but it doesn't *error* (?!):

```bash
# I already previously ran `brew tap grendello/xawindeps`

$ brew tap grendello/xawindeps
Updating Homebrew...
==> Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==> Updated Formulae
container-diff               fwup                         gradle-completion            kibana                       logstash                     opa                          pgroonga                     postgresql@9.4               pushpin                      unrar                        wtf
file-formula                 git-quick-stats              groonga                      libmagic                     nexus                        osquery                      picat                        profanity                    rocksdb                      weaver

Error: Could not link:
/Users/jon/Dropbox/share/man/man1/brew-cask.1
/Users/jon/Dropbox/share/man/man1/brew.1

Please delete these paths and run `brew update`.
$ echo $?
0
```

I'm not even sure what to make of this state of affairs. :-/

Fortunately, reinstalling a package is a no-op:

```bash
# I previously ran `brew install grendello/xawindeps/mingw-zlib`
$ brew install grendello/xawindeps/mingw-zlib
Warning: grendello/xawindeps/mingw-zlib 1.2.11 is already installed and up-to-date
To reinstall 1.2.11, run `brew reinstall mingw-zlib`
$ echo $?
0
```"
I'm not sure using this `<PackageReference/>` will work? `xabuild` is this terrible thing that references `MSBuild.exe` directly.
"It doesn't report L3 on 12 core eMAG I have access to, Trust me, Windows team is aware and helping us here ;-)

> Can we not do something like the following?

No, only when we find a reliable mechanism to detect LLC or switch to something else to calculate Gen0 size. Till then we should not trust whatever API gives us or we might stuck with 256Kb Last-Level-Cache on a 30 core machine and hit a terrible penalty on GC-intensive workloads.

Small/Destkop class hardware should not be hurt with this intrinsic, for e.g. 8 cores it picks 1Mb cache (leading to 1.8Mb gen0 size) and for single/dual-cores it's around 480Kb for Gen0."
"Yes, though it took me a while to walk through this all (it's unpleasant that there's no grammar we can just look at at this point).  

Here's the chain of productions through which we can see the 'GeneratorParameter' being passed down:

```
GeneratorDeclaration[Yield, Default] :
  function * BindingIdentifier[?Yield] ( FormalParameters[Yield,GeneratorParameter] ) { GeneratorBody[Yield] }
  ... elided ...

// FormalParameters[yield,generateparameter] leads to:
FormalParameter[Yield,GeneratorParameter] :
  BindingElement[?Yield, ?GeneratorParameter]

BindingElement[Yield, GeneratorParameter ] : See 13.2.3
  ... elided ...
  [+GeneratorParameter] BindingPattern[?Yield,GeneratorParameter] Initializer[In]opt

BindingPattern[Yield,GeneratorParameter] :
  ObjectBindingPattern[?Yield,?GeneratorParameter]
  ... elided ...

ObjectBindingPattern[Yield,GeneratorParameter] :
  ... elided ...
  { BindingPropertyList[?Yield,?GeneratorParameter] }

BindingPropertyList[Yield,GeneratorParameter] :
  BindingProperty[?Yield, ?GeneratorParameter]
  ... elided ...

BindingProperty[Yield,GeneratorParameter] :
  ... elided ...
  PropertyName[?Yield, ?GeneratorParameter] : BindingElement[?Yield, ?GeneratorParameter]

PropertyName[Yield,GeneratorParameter] :
   LiteralPropertyName
   [+GeneratorParameter] ComputedPropertyName
   [~GeneratorParameter] ComputedPropertyName[?Yield]
```

So, if you have:

```
function * foo({ [x] : ..., [y] : ... }) {
}
```

Then 'generator parameter' is used ot indicate you're creating the parameters for hte generator.  And eventually that flag bubbles down to when you're doing the computed properties.  And, within those computed properties, yield is apparently disabled.  Meaning you can't use a yield expression inside a computed property name (which is not a terrible thing IMO).

(Hopefully i'm reading that right).

Now, oddly enough, outside of a generator parameter, i think it would be legal to use 'yield'.  so if you had:

```
function * f() {
   var v = { [yield 1] : 1 }
}
```

Then that would be fine.  'generator-parameter' is the context flag that enables us to flag this down.
"
"> I don't like it. I think we should not do this if we can't move the whole feature over (analyzer and diagnostic). I worry that we'll just end up with crap left behind that we never get to. But not moving this at all, it highly motivates solving this in an appropriate manner.

From an end-user perspective, this will make no difference at all. They just need the analyzer on CI, and code fix in IDE (regardless of whether it is invoked from a NuGet package or from an implementation in IDE). My point is, do we think it is worth blocking a user feature (CI enforcement) on just the fact that we'd like to cleanup and port the fixer to NuGet package?"
"> We are making the string marshaller types public, so the innovation that can be applied to them will be fairly limited.

I'd hope we have some latitude here, but your point is fair. I don't think this argument moves me much though.

> One of my motivations for doing this is to reduce the engineering dept in NativeAOT. The built-in system in NativeAOT is using different set of helpers for interop. I wanted to use this as an opportunity to get everything on the same plan.

Ugh. Well crap... this does change my perspective. I agree reconciling all of them would be a win. I will say the new entry points do seem to clutter the implementation and make something that is nicely standalone and easy to reason about more complicated. I guess I'm going to have to review this in detail. I think this is worth exploring."
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"These relations are insane! Everything looks good to me though! Perhaps remove the newline before the curly braces when starting interfaces though for style, but your call!"
"> wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
> [sceen](http://joxi.ru/EA4Rw3xHXyZbWm)

sorry, wrong autocomplete from github."
"@github Sure enough if there's people enthusiastic about it! It's not trivial to rebase it, but it's not completely terrible either. I might be a bit busy during the start of this week but might have time in latter half. Feel free to message me here and push me forward again If I don't write an update here during this week. :-)"
"This is kinda gross. This namespace doesn't exist in Ignitor, but I could make an empty one if that's cleaner?"
Oh crap! I thought about that when I started to write the tests and then I forgot about it!
"@github 
Yea stupid me, forgot to check in the added file.  Its up now.  I moved it because it is now used in three places TimePicker, DatePicker, & Entry.  The reality is, it will most likely need to be used in more places.  Check that out again and if you want to move the BoolEventArgs somewhere else, like a separate file then we can do that."
"## TODO for this PR
- [x] Update IDL with `Has...` functions
- [x] Runtime error when `_globals->CreateChild()` is being assigned (only when loading settings.json, fine otherwise)
- [x] Update spec and propagate changes from spec
- [x] Profile has a few settings we handle manually (i.e. BI alignment). I need to hook those up properly too
- [x] ~(Bonus Points) _maybe_ make these settings observable (we'll need that soon anyways)~ Nope

(new items!)
- [x] Fix `startingDirectory` being null
- [x] Fix tests
- [x] merge master (new Profile setting)
- [x] (after #7877 merges) address ""TODO CARLOS"", copy commands/keybindings/schemes in globals 

(new items 2!)

- [x] fix/add tests
- [x] remove IInspectable crap
- [x] fix/test Copy

(new items 3!)

- [x] really do get rid of `IReference` internally"
"Tagging subscribers to this area: @github/ncl
See info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

Note, the old Begin/EndAccept methods support doing an accept and receive in a single operation. Unfortunately the API for this is terrible and forces allocation. It's also not currently supported on non-Windows platforms. So, replace this with a helper routine that performs an accept followed by a receive, and works across all platforms.

Contributes to #43845

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>geoffkizer</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`area-System.Net.Sockets`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
@github how gross is this? Having this here avoids a second dictionary lookup per page invocation.
"I'm not sure that's necessarily an improvement?

If there should *never* be more than one License file, should we `<Error/>` on it?

If there *should* be more than one…but we only ever use one…wtf should happen?

This just ""feels weird""."
"Okay going to show my C++ noob here, what's the proper pattern to do this call then, do I need to explicitly copy the string into another variable, like hostFxrPath for it not to get destroyed?"
"Kinda nasty, but I think I did it correctly within the locks, and added a gross test that adds/removes a bunch of schemes for correctness"
"Verified, insane. "
"See, I wanted to ensure that whatever set of args the user provided always generated a unique string. Yea, if the user puts all the args into a keybinding/command, this will be stupid long like this. At that point, the user should probably have a better name they could give the command."
"Yeah, I'm not a fan of any of these extension methods that all take lambdas that call each other. I only looked at cleaning up the solution provider ones, but I can have a pass at the rest. I think this is part of an existing one that I pulled the filtering code out of, but the diff of this file looks pretty terrible in general."
"yeah, no problem, as I said, I'm terrible at naming :) "
"Are there any custom triggers being used to represent other types of triggering, or is it really being used as ""here's a way to pass ambient state along for the ride""? I recognize this might churn stuff, but it very much feels like this CustomTags exists on trigger just because it was the convenient type that happens to be there.

Three interesting, potentially controversial, and likely terrible ideas came to mind while writing that previous sentence:
1. I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.
2. Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then _perhaps_ we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could _imagine_ people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am _not_ saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that _also_ might fix this problem too, I can't help but notice the coincidence.
3. Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.
"
"If we allow `checkExpressionCached` to continue, the relevant symbol still ends up marked referenced via `checkExpressionCached` -> `checkIdentifier` -> `markAliasReferenced` -> `markAliasSymbolAsReferenced`. In other words, it's not only `markExportAsReferenced` that will end up marking it referenced.

So I think it's possible to alter `markExportAsReferenced` instead of `checkExportSpecifier`, though it may be a bit more awkward since `markExportAsReferenced` takes a couple different kinds of nodes.

And then we do still need to handle the other code path too. For that, nothing stands out as a great option. It feels like an `export type` ancestor check is possible, and similar to other checks that `markAliasReferenced` does already for example (`isInTypeQuery`), but depending on where we try to check, it could be an arbitrarily long ancestor walk.

I guess the choice I'm leaning towards for this other code path would be a check in `checkIdentifier` for the `node.parent.parent.parent` being a type only export declaration. This would be similar to the check for a property access expression and would go around the call to `markAliasReferenced`. Feels a bit gross, but we can know the exact ancestor to try to check from here."
"No, the feature is only set if an activity is created. (also there really should be comments about these different sections, maybe vs. sometimes, wtf?)"
"I don't think this is a terrible idea, but maybe one we do in another PR?"
"Downloaded the branch and tested it. Yeah, this works fine. And scenarios like ""opening the search box while the tab switcher is open"" would probably fall under the ""play stupid games"" category. Fixing this is probably more effort than it's worth right now, so good enough for me!"
"`_set_tcs_result_ref` does not propagate user's exception from whoever is awaiting the task.

It could only throw if runtime is in some terrible state already. In such case, I'm not sure what is the correct recovery.
As it is, the exception would bubble to main loop, as this is promise callback.

I at lest moved both `mono_wasm_release_cs_owned_object` and `teardown_managed_proxy` to `finally()`"
I guess we have to account for the offline client here which is gross. Yet another reason to figure out #7805.  
"_technically_ yes. But also technically, a caller could be stupid and set `FoundMatch(true)` _before_ calling this. Or you could be me in the tests, and reusing the same `args` across multiple calls, because you're too lazy to instantiate multiple. So I always think it's good form to have the handler manually set a result like this, so that _no matter what_, the result is initialized to a failure state, and only set to success when we know we're successful. "
"I actually split it up into two parts - one for unpacking the json (`GetGuidOrGenerateForJson`), and another for doing the source/name GUID generation. I had to split it up like that because the profile doesn't actually have a reference to its own JSON. i could have theoretically had the profile re-create a blob of json and call the json parsing function, but that seemed insane."
"Hmm

Would it make sense having _stream on Connection as private protected? (probably a terrible idea)
Or have you considered a different name here or the base type? _streamWrapper on the base type?
Or at least a comment explaining why this is different from the base type _stream.

Same for new Pipe below."
"That shouldn't be the case ... o_O the title should never be empty because it was getting set by `updateSettings`

oh crap i just realized i made you make a bad/annoying change"
"Ugh gross. OK, maybe don't put it in by default and let people override it for now and file a follow-on to make `file://` smarter."
"\<aside> Yea, this ""Capabilities"" section I've always hated. I think if you're outside MSFT, then you don't have any idea what to put here, and ""capabilities"" is a _terrible_ heading for it"
"> This PR fixes #127365
> 
> The added code follows the `IExplorerCommand + app identity` method recommended by [Windows Blog](https://blogs.windows.com/windowsdeveloper/2021/07/19/extending-the-context-menu-and-share-dialog-in-windows-11/), which is the minimal code necessary to implement this feature, and has _not been integrated into the Inno Setup script_. I hope that these codes can be used as an inspiration, and the VS Code developers would find out a sensible way to achieve this feature.
> 
> ![Screenshot 2021-12-22 230721](https://user-images.githubusercontent.com/26765742/147120434-0c54a018-ea84-471b-9498-cf904baa7117.png)
> 
> ![Screenshot 2021-12-22 230859](https://user-images.githubusercontent.com/26765742/147120449-c6eeb092-9678-4ade-a317-9f18f267a94c.png)
> 
> The added codes are located at `/build/win32/shell-extension-win11`, including an action handler, a minimal sparse package manifest, build script and setup script.
> 
> Because these are not integrated into Inno Setup, a manual build process is needed:
> 
> Assume that VS2019 with desktop development workload is installed in the working environment. `build.cmd` can make the sparse package and `.dll` library file for handling menu actions, which are needed by Windows. It also self-issues a test certificate to sign the sparse package. (This maybe needs to be implemented in a more formal way.)
> 
> By executing `build.cmd` 3 files will be put in the `/build/...-win11/Release` directory, namely `menuhandler.dll`, `Key.cer` and `code-sparse.appx`. The certificate issuance and signature process will prompt to enter a password for 3 times, just enter the same password.
> 
> Copy these 3 files with `setup.ps1` to anywhere inside an VS Code installation, and execute `setup.ps1` with administrator privileges. After restarting explorer.exe, you can see the option of ""Open by Code"" in context menus of files and directories.
> 
> The menu action is handled by C++ code implementing the COM interface, while currently for older versions of Windows this is achieved by the installer to directly write into registry. So the COM implemention directly reads the keys from registry to present the icon and determine the executable file path, to keep it simple and stupid. Perhaps this approach needs further improvement.
> 
> Localization has not been implemented yet, but by reading the registry, it should be easy.

Can you record short video?"
Just me being stupid... :-P
"One option is to pass the string and a variable number of arguments, and only smash them together in a string if we're called to walk the stack.

I discarded it due to complexity for now. I could write up a performance benchmark and see how much it helps, but went with the simple and stupid thing for a RFC PR."
"Is a result task, it would allocate a `Task<FlushResult>`. 

Thought about adding an extension method called `.AsNonGenericTask`; but that seemed a terrible name."
"wtf.

```suggestion
            => new AbstractFormattingRule[] { new ChangeSignatureFormattingRule(),  Formatter.GetDefaultFormattingRules(document) };
```

i.e. why on earth are we making a singleton enumerable, just to concat a single known value onto it.  it's an array with two elements.  just have it be that."
"> I guess if it was OK for BindableLayout, it should be OK for Map too?

Either that, or we made a terrible mistake merging 5582. That implementation of Replace in `Apply` is very suspect.

It looks like Map.Pins is an `ObservableCollection<Pin>`, so while I don't like this implementation of `Apply`, it should be fine for this purpose. It looks like the implementation of `ObservableCollection` only uses `NotifyCollectionChangedAction.Replace` for a single item being set. So at least for this specific application, it shouldn't cause any immediate problems.

"
"Possibly this is an example of me trying to outsmart the compiler and in the end doing something stupid 😄 Was trying to achieve inlining this method in its usages, given that it's just a simple expression, to avoid unnecessary calls to this method. The compiler will be smart enough to inline it without the attributes?"
"As a side note, the reason fixing this is important even given the obvious uselessness of the construct `const {} = anything` is that we ought to be able to deliver accurate completions inside the `{}`. Prior to this fix, you got both `a` and `b` since that’s what `T` had in its domain, but as soon as you accept the `a` completion, the contextual type changes and therefore the inference changes and it becomes an error, which is a terrible experience."
"It's sad to see that the work on this seems to have come to a halt.
Implementing would-be-convenient functionality now requires insane workarounds.

Bumping this again, in hope to see this released ♥️"
"This is where we call into the action constraints. 

The reasons that I went this way instead of using something new to solve the problem:
- This is the simplest thing to do for now
- I'm not sure how common this requirement is outside of MVC.

The thing that this solves is selecting between a GET endpoint and a POST endpoint, etc. It seems obvious someone layering a CMS on top of MVC needs this functionality. Maybe I am just being stupid and this needs to be *built-in*."
"> Shouldn't this be done in the other ctor?

Yes, absolutely right! I knew to do that earlier then for some reason started working on something else and forgot about it. Thanks for catching that.

> Also how do you feel about passing in an ILogger \ ILoggerFactory instead to the ctor? This feels a little gross. This feels a little gross.

I did this because we already take a `serviceProvider`, so why complicate things for the consumer? Under what circumstances would someone have reason to supply a different `ILogger` than the one the service provider would offer? I'm not absolutely set against it, but would like to make a choice based on practical reasoning.

In the long term, we may need to consume other services too. If we keep adding them as extra constructor overloads one-by-one, it will not be a nice experience for consumers."
I flipped this because _calling the destructor manually is terrible._
"holy shit this whole function is magic

"
Gross. OK.
"@github could this be something as stupid as not giving mlaunch enough time to finish?

Here's a good run:

```
[05:25:47] dbug: test[0]
      05:25:47.1394590 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmpmlrVXC.tmp --output-format=XML
[05:26:08] dbug: test[0]
      05:26:08.8570810 Simulator configuration written to /tmp/tmpmlrVXC.tmp
[05:26:08] dbug: test[0]
      05:26:08.9515020 Process exited with 0
[05:26:09] dbug: test[0]
      05:26:08.9536870 Simulator listing returned:
```

That took 22 seconds to return any results

Here's a bad one:

```
[02:06:49] dbug: test[0]
      02:06:49.7723290 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmp3dqcCa.tmp --output-format=XML
[02:07:19] dbug: test[0]
      02:07:19.8645850 Process 4094 didn't exit within 00:00:30 and will be killed
```

Timeout is 30 seconds

How close to the wire is it getting?"
python3 wtf. Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?
