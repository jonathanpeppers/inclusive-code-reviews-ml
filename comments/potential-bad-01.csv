Body
"It's grabbing it off of the getter.  The assumption being that the getter is normally before the setter.  Here it's suboptimal, but not terrible.  We can consider trying to do better in the cases where the getter is after the setter.  But i just wanted to ensure we weren't totally breaking code by removing preprocessor directives as the highest order thing to fix."
"(oh, i'm also an idiot since i read this as `Open Brace` not `Open Bracket`.  But the above points still stand)."
"> How does GetDiagnosticsUpdatedEventArgs work exactly?

You can think of the IDiagnosticsService as a mapping from special ""keys"" to the set of diagnostics for those keys.  This method name is actually *terrible* as these aren't really events or args.  They're really just saying ""what are all the keys we know about for this particular set of args"".  In this case, we're asking for all the keys associated with a particular document.  We can then use those keys to actually find out all the diagnostics for that doc.

You could imagine this exposed behind a helper method (which is what i think i will do :))."
"Thanks for the notice & discussion! TIL 😄 , and it makes a lot of sense.

This actually ended up not changing much in the output: 107e10d908 only showed a few _very_ edge case tests get a small amount of extra messages. Not so terrible. Phew."
"Stupid question - won't some of the changes by overwritten by arcade in some point in time - I don't know the flow of those, but I see some files are the same and looking at history they are updated?"
"> Ping @github - let me know if you disagree with the justification.

I don't like it.  I think we should not do this if we can't move the whole feature over (analyzer and diagnostic).  I worry that we'll just end up with crap left behind that we never get to.  But not moving this at all, it highly motivates solving this in an appropriate manner."
"**This is a warning**.

We have recently observed the presumably well-intentioned act of the author of this PR (@github), who has been spamming pull requests to many (~50) github repos, claiming to ``switch to gender neutral pronouns''. In reality, the bot performs a dictionary replace of gendered nouns and pronouns, and the outcome is questionable at best, and literally harmful at worst. See:
- The bot did a terrible job at replacing these words - [EbookFoundation/free-programming-books#6801](https://github.com/EbookFoundation/free-programming-books/pull/6801/commits/5257301642c173e2dc4f034f8c0460ce7ea99de6)
- The code fails to compile at [rust-lang/rust#95508](https://github.com/rust-lang/rust/pull/95508)
- The bot ignores all context whatsoever at [moby/moby#43441](https://github.com/moby/moby/pull/43441)
- After initial PR being closed, the bot keeps sending PRs, effectly spamming the repos. For example, these 5 PRs were sent to the same repo within 2 days [#1](https://github.com/EbookFoundation/free-programming-books/pull/6801) [#2](https://github.com/EbookFoundation/free-programming-books/pull/6803) [#3](https://github.com/EbookFoundation/free-programming-books/pull/6804) [#4](https://github.com/EbookFoundation/free-programming-books/pull/6805) [#5](https://github.com/EbookFoundation/free-programming-books/pull/6806)

We have reviewed the changes in this PR. Most of the changed words are ""accidental gender pronouns"" - `he` as a prefix of `hello`, or `his` as a suffix of `this`, and both examples come from test cases where inline comments are used to split words (like `t/**/his`), and the PR wants to change them into `t/**/theirs` etc.. These changes are obviously not helpful at all.

To save more time for the open-source community, we recommend the maintainers of this repo to close this PR and ban this bot from further spamming."
"> Many workloads for which tasks were originally introduced, actually. Consider, for example, parallelized divide and conquer. A worker partitions its work into multiple pieces, queues identical workers to process N - 1 of those pieces, processes its own, and then waits for those other workers to complete. Also think about algorithms that require coordination between those pieces, such as various operations used by PLINQ (e.g. OrderBy) that needs to block each of the workers until they reach a common point so that they can exchange data and all continue on, and what would happen if one of the workers was throttled indefinitely

Today do the implementation of those kick end up doing Task.Wait?

> I think that's the wrong direction, at least for the foreseeable future. If we decided to go with an approach like the one proposed in this draft, I have trouble seeing it as anything other than opt-in, given all of the previously cited concerns, the potential for introducing deadlocks where they weren't previously, the potential for casting way too wide a net, the potential for negatively impacting the throughput of unrelated workloads, etc. _If such a mitigation was added as opt-in, and if enough testing demonstrated it was a good decision for certain workloads, then it could potentially be automatically opted-in for those, e.g. if you felt ASP.NET should always turn this on. Even there, though, I'd be surprised if in the current configuration that was a wise choice.

Yes I have similar fears but I'm looking for solutions. Maybe this isn't this one but there are aspects of this that seem interesting. Say we added a public API to enable this and it was opt-in, I could see the potential for adding a piece of middleware or filters that enables this on the current workitem before the blocking code executed. Something like this:

```C#
[HttpGet(""/blocking"")]
[EnableBlockingMitigation] // This name is terrible
public string BlockingLegacyCodez()
{
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

That filter could yield to thread pool to get off the current work item and enable mitigation on a unique workitem that's closer to this code. The equivalent of doing this:

```C#
[HttpGet(""/blocking"")]
public async Task<string> BlockingLegacyCodez()
{
      await Task.Yield(); // Make a new work item
      ThreadPool.EnableBlockingWorkitem();
      return new WebClient().DownloadString(...); // I know we're never supposed to use this API
}
```

Thoughts?"
Shouldn't this be done in the other ctor? Also how do you feel about passing in an `ILogger` \ `ILoggerFactory` instead to the ctor? This feels a little gross.
"If `Bottom` and `Top` are both `SHORT`, then can't this technically cast into something gross when it's returned as `unsigned int`?"
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"@github Those are the default settings for insane (just copied over so I could add a few more attributes). The allowed tags are separate from the allowed attributes. The current setting just says: if we allow iframes (which we don't) here are the allowed attributes for them. We can remove the line since it has no effect

 @github I'm good with removing `marked.sanitize`. The setting is deprecated and has known issues, which is why we added `insane`.

My concern is just that allowing CSS brings up a number of other considerations:

- Which css rules do we allow? Do we try sanitizing the css? If we do have a whitelist of allowed css, how do we handle feature requests to support additional properties?

- Do we want extensions to control the styling insides hovers at all? Right now we control the presentation and can try our best to make sure the hovers look ok with all themes 

- Enabling css expands the potential attack surface. If someone finds an exploit in Chromium related to CSS, it could potentially now effect VS Code too.

My feeling is that we should think through this problem more and find some other potential use cases. Issues labels seem like a very specific use case"
"wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
[sceen](http://joxi.ru/EA4Rw3xHXyZbWm)"
"> That might just be a case of ""play stupid games, win stupid prizes"".

That is how I am thinking of this feature. There are cases where the compiler can definitely determine if the user is doing something wrong, but also where it _might_ be doing something wrong. The [`Span<T>.ToArray()`](https://docs.microsoft.com/dotnet/api/system.span-1.toarray) is another example. If a user calls `ToArray()` and `T` is known to be ByRefLike, the compiler could issue a failure. However, if `T` isn't know at compile time then it would be up to the implementer to have handled this appropriately using something like the proposed intrinsi-fication of `typeof(T.).IsByRefLike` in this document. The updated `Span<T>.ToArray()` would look as follows and handle the case at runtime. The other APIs in question would have similar checks.

```diff
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public T[] ToArray()
{
+    if (typeof(T).IsByRefLike)
+        throw new InvalidProgramException();

    if (_length == 0)
        return Array.Empty<T>();

    var destination = new T[_length];
    Buffer.Memmove(ref MemoryMarshal.GetArrayDataReference(destination), ref _pointer.Value, (uint)_length);
    return destination;
}
```"
"Do we have an issue somewhere to clean this up? Throwing inside dispose isn't a nice thing to do, especially when you have inheritance involved. There are a bunch of places in this PR that will leak stuff on failed dispose 😆 

I realize that you didn't make it worse in this PR, but it is gross so I want to make sure it's on someone's plate to fix. "
"Crap - the tree from the quarantined test jobs does appear to have https://github.com/dotnet/aspnetcore/commit/76fbd1a2831ae0d8c73afd2f3c7d8c531223a8b8, but doesn't produce binlogs. I'll see if I can find another public build since my commit that has the failures"
"this feels like a terrible nit, but all the other options are `--twoDashes` style, so this should probably be `--embedding`, right? 

(except `-ForceV1` which maybe raises more questions - maybe predates the other args)"
"Noob question 😅Does `[iOS (13,0)]` not mean anything 13+? Then are there two Exports for the same selector? How does it get resolved?"
"Hmm, yeah, I can see how those types are a disaster in a structural comparison. For example, to structurally compare two `List<T>` instantiations, we fan out to an insane number of comparisons between instantiations of the same generic types for different type parameters, which again fans out more, etc. The cycles are very long and apparently don't get to a depth of five before we run out of memory. I stopped it in the debugger and observed a relation stack 70 levels deep that still wasn't considered deeply nested. Tough one!"
"@github @github @github Ok, I am using the SharedFramework SDK to make a new `Microsoft.NETCore.App.Runtime.Mono.<RID>.Sdk` nuget - it seems to be working at least for `iossimulator-x64`.

There are some gross cmake hacks in here, too, because I don't really know cmake.

Could you take a look at what's here so far.

Next steps: update the workload manifest to use all these new nugets.  Figure out some way to test this. 

(I tested that the msbuild target works by copy-pasting to a dummy project and setting the appropriate props and looking that the properties are getting set to reasonable-looking values.)"
"Forgive me if it's a stupid question, but what's the point of adding an empty object as a value if we are only checking ContainsKey? Can't we set the value to null and get rid of the readonly property?"
"Yeah but that looks gross if I have to do it like this 
```
private static byte[] LookupTable => new byte[] {
    (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
    (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
    (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E',
    (byte)'F',
};
```"
"You're nullable disabling/enabling around the closing brace?

Regardless, yes, it's possible for someone to implement Fail in a way that still returns, but that goes against the purpose of the method.  If we held true to the possibility that someone did that, then we'd need to remove `[DoesNotReturnIf(false)]` from Debug.Assert and all such methods, which would be terrible. #Resolved"
This is a really confusing way to declare flyout... I mean I get what it does but holy crap did it hurt my head for a second. Can you please flip this if statement around even though it will increase nesting.
edit: I am stupid
"Part of the *intention* -- and *maybe* unnecessary? -- was that we'd only emit the `brew install` commands for applications which are not present.

This check can be done for `@(RequiredProgram)`, but not for `@(RequiredPackage)`: how do you check that the package is already installed?  ¯\_(ツ)_/¯

Then again, I'm not sure if this will be an *actual* problem in practice.

I have similar fears about `%(HomebrewTap)`: what happens if the same `brew tap` command is executed multiple times?

In my case, it errors, but it doesn't *error* (?!):

```bash
# I already previously ran `brew tap grendello/xawindeps`

$ brew tap grendello/xawindeps
Updating Homebrew...
==> Auto-updated Homebrew!
Updated 1 tap (homebrew/core).
==> Updated Formulae
container-diff               fwup                         gradle-completion            kibana                       logstash                     opa                          pgroonga                     postgresql@9.4               pushpin                      unrar                        wtf
file-formula                 git-quick-stats              groonga                      libmagic                     nexus                        osquery                      picat                        profanity                    rocksdb                      weaver

Error: Could not link:
/Users/jon/Dropbox/share/man/man1/brew-cask.1
/Users/jon/Dropbox/share/man/man1/brew.1

Please delete these paths and run `brew update`.
$ echo $?
0
```

I'm not even sure what to make of this state of affairs. :-/

Fortunately, reinstalling a package is a no-op:

```bash
# I previously ran `brew install grendello/xawindeps/mingw-zlib`
$ brew install grendello/xawindeps/mingw-zlib
Warning: grendello/xawindeps/mingw-zlib 1.2.11 is already installed and up-to-date
To reinstall 1.2.11, run `brew reinstall mingw-zlib`
$ echo $?
0
```"
I'm not sure using this `<PackageReference/>` will work? `xabuild` is this terrible thing that references `MSBuild.exe` directly.
"It doesn't report L3 on 12 core eMAG I have access to, Trust me, Windows team is aware and helping us here ;-)

> Can we not do something like the following?

No, only when we find a reliable mechanism to detect LLC or switch to something else to calculate Gen0 size. Till then we should not trust whatever API gives us or we might stuck with 256Kb Last-Level-Cache on a 30 core machine and hit a terrible penalty on GC-intensive workloads.

Small/Destkop class hardware should not be hurt with this intrinsic, for e.g. 8 cores it picks 1Mb cache (leading to 1.8Mb gen0 size) and for single/dual-cores it's around 480Kb for Gen0."
"Yes, though it took me a while to walk through this all (it's unpleasant that there's no grammar we can just look at at this point).  

Here's the chain of productions through which we can see the 'GeneratorParameter' being passed down:

```
GeneratorDeclaration[Yield, Default] :
  function * BindingIdentifier[?Yield] ( FormalParameters[Yield,GeneratorParameter] ) { GeneratorBody[Yield] }
  ... elided ...

// FormalParameters[yield,generateparameter] leads to:
FormalParameter[Yield,GeneratorParameter] :
  BindingElement[?Yield, ?GeneratorParameter]

BindingElement[Yield, GeneratorParameter ] : See 13.2.3
  ... elided ...
  [+GeneratorParameter] BindingPattern[?Yield,GeneratorParameter] Initializer[In]opt

BindingPattern[Yield,GeneratorParameter] :
  ObjectBindingPattern[?Yield,?GeneratorParameter]
  ... elided ...

ObjectBindingPattern[Yield,GeneratorParameter] :
  ... elided ...
  { BindingPropertyList[?Yield,?GeneratorParameter] }

BindingPropertyList[Yield,GeneratorParameter] :
  BindingProperty[?Yield, ?GeneratorParameter]
  ... elided ...

BindingProperty[Yield,GeneratorParameter] :
  ... elided ...
  PropertyName[?Yield, ?GeneratorParameter] : BindingElement[?Yield, ?GeneratorParameter]

PropertyName[Yield,GeneratorParameter] :
   LiteralPropertyName
   [+GeneratorParameter] ComputedPropertyName
   [~GeneratorParameter] ComputedPropertyName[?Yield]
```

So, if you have:

```
function * foo({ [x] : ..., [y] : ... }) {
}
```

Then 'generator parameter' is used ot indicate you're creating the parameters for hte generator.  And eventually that flag bubbles down to when you're doing the computed properties.  And, within those computed properties, yield is apparently disabled.  Meaning you can't use a yield expression inside a computed property name (which is not a terrible thing IMO).

(Hopefully i'm reading that right).

Now, oddly enough, outside of a generator parameter, i think it would be legal to use 'yield'.  so if you had:

```
function * f() {
   var v = { [yield 1] : 1 }
}
```

Then that would be fine.  'generator-parameter' is the context flag that enables us to flag this down.
"
"> I don't like it. I think we should not do this if we can't move the whole feature over (analyzer and diagnostic). I worry that we'll just end up with crap left behind that we never get to. But not moving this at all, it highly motivates solving this in an appropriate manner.

From an end-user perspective, this will make no difference at all. They just need the analyzer on CI, and code fix in IDE (regardless of whether it is invoked from a NuGet package or from an implementation in IDE). My point is, do we think it is worth blocking a user feature (CI enforcement) on just the fact that we'd like to cleanup and port the fixer to NuGet package?"
"> We are making the string marshaller types public, so the innovation that can be applied to them will be fairly limited.

I'd hope we have some latitude here, but your point is fair. I don't think this argument moves me much though.

> One of my motivations for doing this is to reduce the engineering dept in NativeAOT. The built-in system in NativeAOT is using different set of helpers for interop. I wanted to use this as an opportunity to get everything on the same plan.

Ugh. Well crap... this does change my perspective. I agree reconciling all of them would be a win. I will say the new entry points do seem to clutter the implementation and make something that is nicely standalone and easy to reason about more complicated. I guess I'm going to have to review this in detail. I think this is worth exploring."
"I spent some time yesterday looking through the implementations of ReplacePattern in vs/editor/contrib/find/replacePattern.ts and vs/workbench/services/search/common/replace.ts. Each of these implements different mechanisms for the CharCode `switch`es, so a small CharCode-aware-only helper function doesn't seem viable.

The alternative IMO is to choose (or combine) one of the ReplacePattern implementations, move it to vs/base/common/search.ts (or perhaps .../replace.ts) and tweak the small handful of callers.

I'm probably not the best choice to perform a nuanced refactor since I'm a TS noob; however I can likely implement the replacement change in .../replace.ts as a parallel to .../replacePattern.ts.

Thoughts?"
"These relations are insane! Everything looks good to me though! Perhaps remove the newline before the curly braces when starting interfaces though for style, but your call!"
"> wtf i get notifications and i can approve MR. i see this repository first time in my life and i have permissions
> [sceen](http://joxi.ru/EA4Rw3xHXyZbWm)

sorry, wrong autocomplete from github."
"@github Sure enough if there's people enthusiastic about it! It's not trivial to rebase it, but it's not completely terrible either. I might be a bit busy during the start of this week but might have time in latter half. Feel free to message me here and push me forward again If I don't write an update here during this week. :-)"
"This is kinda gross. This namespace doesn't exist in Ignitor, but I could make an empty one if that's cleaner?"
Oh crap! I thought about that when I started to write the tests and then I forgot about it!
"@github 
Yea stupid me, forgot to check in the added file.  Its up now.  I moved it because it is now used in three places TimePicker, DatePicker, & Entry.  The reality is, it will most likely need to be used in more places.  Check that out again and if you want to move the BoolEventArgs somewhere else, like a separate file then we can do that."
"## TODO for this PR
- [x] Update IDL with `Has...` functions
- [x] Runtime error when `_globals->CreateChild()` is being assigned (only when loading settings.json, fine otherwise)
- [x] Update spec and propagate changes from spec
- [x] Profile has a few settings we handle manually (i.e. BI alignment). I need to hook those up properly too
- [x] ~(Bonus Points) _maybe_ make these settings observable (we'll need that soon anyways)~ Nope

(new items!)
- [x] Fix `startingDirectory` being null
- [x] Fix tests
- [x] merge master (new Profile setting)
- [x] (after #7877 merges) address ""TODO CARLOS"", copy commands/keybindings/schemes in globals 

(new items 2!)

- [x] fix/add tests
- [x] remove IInspectable crap
- [x] fix/test Copy

(new items 3!)

- [x] really do get rid of `IReference` internally"
"Tagging subscribers to this area: @github/ncl
See info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.
<details>
<summary>Issue Details</summary>
<hr />

Note, the old Begin/EndAccept methods support doing an accept and receive in a single operation. Unfortunately the API for this is terrible and forces allocation. It's also not currently supported on non-Windows platforms. So, replace this with a helper routine that performs an accept followed by a receive, and works across all platforms.

Contributes to #43845

<table>
  <tr>
    <th align=""left"">Author:</th>
    <td>geoffkizer</td>
  </tr>
  <tr>
    <th align=""left"">Assignees:</th>
    <td>-</td>
  </tr>
  <tr>
    <th align=""left"">Labels:</th>
    <td>

`area-System.Net.Sockets`

</td>
  </tr>
  <tr>
    <th align=""left"">Milestone:</th>
    <td>-</td>
  </tr>
</table>
</details>"
@github how gross is this? Having this here avoids a second dictionary lookup per page invocation.
"I'm not sure that's necessarily an improvement?

If there should *never* be more than one License file, should we `<Error/>` on it?

If there *should* be more than one…but we only ever use one…wtf should happen?

This just ""feels weird""."
"Okay going to show my C++ noob here, what's the proper pattern to do this call then, do I need to explicitly copy the string into another variable, like hostFxrPath for it not to get destroyed?"
"Kinda nasty, but I think I did it correctly within the locks, and added a gross test that adds/removes a bunch of schemes for correctness"
"Verified, insane. "
"See, I wanted to ensure that whatever set of args the user provided always generated a unique string. Yea, if the user puts all the args into a keybinding/command, this will be stupid long like this. At that point, the user should probably have a better name they could give the command."
"Yeah, I'm not a fan of any of these extension methods that all take lambdas that call each other. I only looked at cleaning up the solution provider ones, but I can have a pass at the rest. I think this is part of an existing one that I pulled the filtering code out of, but the diff of this file looks pretty terrible in general."
"yeah, no problem, as I said, I'm terrible at naming :) "
"Are there any custom triggers being used to represent other types of triggering, or is it really being used as ""here's a way to pass ambient state along for the ride""? I recognize this might churn stuff, but it very much feels like this CustomTags exists on trigger just because it was the convenient type that happens to be there.

Three interesting, potentially controversial, and likely terrible ideas came to mind while writing that previous sentence:
1. I think you already had some sort of ""context"" object that was beginning to congeal. Perhaps a type that is the ""context"" that contains the trigger, various ""environment"" flags (notably this debugger flag and the interactive flag), and maybe some other pieces of information could become the replacement.
2. Is the debugger flag only being used to control whether we list completion items before their declaration point? And do completion providers get passed an OptionSet from the originating workspace (or can get at it)? If both are ""yes"", then _perhaps_ we should instead have there be a not-UI-exposed completion option that simply specifies that debugger behavior, and the debugger workspace we create just sets that option explicitly. I could _imagine_ people might actually like that behavior during real typing as well. It's not rare that you might write some code and realize you need to use a local declared farther down. Rather than me breaking context, moving the local up, and then writing the code again, that it's perhaps OK to actually complete it anyways. It's I am _not_ saying we should expose it in a UI (at least not until customers come with pitchforks asking for it :smile:), but if they did come along and ask for that we'd implement that with an option. Given that _also_ might fix this problem too, I can't help but notice the coincidence.
3. Rather than having some additional way to shuttle info, this could just be checking the workspace kind. It's still comparing magic strings, but at least without the baggage of extra types.
"
"If we allow `checkExpressionCached` to continue, the relevant symbol still ends up marked referenced via `checkExpressionCached` -> `checkIdentifier` -> `markAliasReferenced` -> `markAliasSymbolAsReferenced`. In other words, it's not only `markExportAsReferenced` that will end up marking it referenced.

So I think it's possible to alter `markExportAsReferenced` instead of `checkExportSpecifier`, though it may be a bit more awkward since `markExportAsReferenced` takes a couple different kinds of nodes.

And then we do still need to handle the other code path too. For that, nothing stands out as a great option. It feels like an `export type` ancestor check is possible, and similar to other checks that `markAliasReferenced` does already for example (`isInTypeQuery`), but depending on where we try to check, it could be an arbitrarily long ancestor walk.

I guess the choice I'm leaning towards for this other code path would be a check in `checkIdentifier` for the `node.parent.parent.parent` being a type only export declaration. This would be similar to the check for a property access expression and would go around the call to `markAliasReferenced`. Feels a bit gross, but we can know the exact ancestor to try to check from here."
"No, the feature is only set if an activity is created. (also there really should be comments about these different sections, maybe vs. sometimes, wtf?)"
"I don't think this is a terrible idea, but maybe one we do in another PR?"
"Downloaded the branch and tested it. Yeah, this works fine. And scenarios like ""opening the search box while the tab switcher is open"" would probably fall under the ""play stupid games"" category. Fixing this is probably more effort than it's worth right now, so good enough for me!"
"`_set_tcs_result_ref` does not propagate user's exception from whoever is awaiting the task.

It could only throw if runtime is in some terrible state already. In such case, I'm not sure what is the correct recovery.
As it is, the exception would bubble to main loop, as this is promise callback.

I at lest moved both `mono_wasm_release_cs_owned_object` and `teardown_managed_proxy` to `finally()`"
"I guess we have to account for the offline client here which is gross. Yet another reason to figure out #7805.  "
"_technically_ yes. But also technically, a caller could be stupid and set `FoundMatch(true)` _before_ calling this. Or you could be me in the tests, and reusing the same `args` across multiple calls, because you're too lazy to instantiate multiple. So I always think it's good form to have the handler manually set a result like this, so that _no matter what_, the result is initialized to a failure state, and only set to success when we know we're successful. "
"I actually split it up into two parts - one for unpacking the json (`GetGuidOrGenerateForJson`), and another for doing the source/name GUID generation. I had to split it up like that because the profile doesn't actually have a reference to its own JSON. i could have theoretically had the profile re-create a blob of json and call the json parsing function, but that seemed insane."
"Hmm

Would it make sense having _stream on Connection as private protected? (probably a terrible idea)
Or have you considered a different name here or the base type? _streamWrapper on the base type?
Or at least a comment explaining why this is different from the base type _stream.

Same for new Pipe below."
"That shouldn't be the case ... o_O the title should never be empty because it was getting set by `updateSettings`

oh crap i just realized i made you make a bad/annoying change"
"Ugh gross. OK, maybe don't put it in by default and let people override it for now and file a follow-on to make `file://` smarter."
"\<aside> Yea, this ""Capabilities"" section I've always hated. I think if you're outside MSFT, then you don't have any idea what to put here, and ""capabilities"" is a _terrible_ heading for it"
"> This PR fixes #127365
> 
> The added code follows the `IExplorerCommand + app identity` method recommended by [Windows Blog](https://blogs.windows.com/windowsdeveloper/2021/07/19/extending-the-context-menu-and-share-dialog-in-windows-11/), which is the minimal code necessary to implement this feature, and has _not been integrated into the Inno Setup script_. I hope that these codes can be used as an inspiration, and the VS Code developers would find out a sensible way to achieve this feature.
> 
> ![Screenshot 2021-12-22 230721](https://user-images.githubusercontent.com/26765742/147120434-0c54a018-ea84-471b-9498-cf904baa7117.png)
> 
> ![Screenshot 2021-12-22 230859](https://user-images.githubusercontent.com/26765742/147120449-c6eeb092-9678-4ade-a317-9f18f267a94c.png)
> 
> The added codes are located at `/build/win32/shell-extension-win11`, including an action handler, a minimal sparse package manifest, build script and setup script.
> 
> Because these are not integrated into Inno Setup, a manual build process is needed:
> 
> Assume that VS2019 with desktop development workload is installed in the working environment. `build.cmd` can make the sparse package and `.dll` library file for handling menu actions, which are needed by Windows. It also self-issues a test certificate to sign the sparse package. (This maybe needs to be implemented in a more formal way.)
> 
> By executing `build.cmd` 3 files will be put in the `/build/...-win11/Release` directory, namely `menuhandler.dll`, `Key.cer` and `code-sparse.appx`. The certificate issuance and signature process will prompt to enter a password for 3 times, just enter the same password.
> 
> Copy these 3 files with `setup.ps1` to anywhere inside an VS Code installation, and execute `setup.ps1` with administrator privileges. After restarting explorer.exe, you can see the option of ""Open by Code"" in context menus of files and directories.
> 
> The menu action is handled by C++ code implementing the COM interface, while currently for older versions of Windows this is achieved by the installer to directly write into registry. So the COM implemention directly reads the keys from registry to present the icon and determine the executable file path, to keep it simple and stupid. Perhaps this approach needs further improvement.
> 
> Localization has not been implemented yet, but by reading the registry, it should be easy.

Can you record short video?"
Just me being stupid... :-P
"One option is to pass the string and a variable number of arguments, and only smash them together in a string if we're called to walk the stack.

I discarded it due to complexity for now. I could write up a performance benchmark and see how much it helps, but went with the simple and stupid thing for a RFC PR."
"Is a result task, it would allocate a `Task<FlushResult>`. 

Thought about adding an extension method called `.AsNonGenericTask`; but that seemed a terrible name."
"wtf.

```suggestion
            => new AbstractFormattingRule[] { new ChangeSignatureFormattingRule(),  Formatter.GetDefaultFormattingRules(document) };
```

i.e. why on earth are we making a singleton enumerable, just to concat a single known value onto it.  it's an array with two elements.  just have it be that."
"> I guess if it was OK for BindableLayout, it should be OK for Map too?

Either that, or we made a terrible mistake merging 5582. That implementation of Replace in `Apply` is very suspect.

It looks like Map.Pins is an `ObservableCollection<Pin>`, so while I don't like this implementation of `Apply`, it should be fine for this purpose. It looks like the implementation of `ObservableCollection` only uses `NotifyCollectionChangedAction.Replace` for a single item being set. So at least for this specific application, it shouldn't cause any immediate problems.

"
"Possibly this is an example of me trying to outsmart the compiler and in the end doing something stupid 😄 Was trying to achieve inlining this method in its usages, given that it's just a simple expression, to avoid unnecessary calls to this method. The compiler will be smart enough to inline it without the attributes?"
"As a side note, the reason fixing this is important even given the obvious uselessness of the construct `const {} = anything` is that we ought to be able to deliver accurate completions inside the `{}`. Prior to this fix, you got both `a` and `b` since that’s what `T` had in its domain, but as soon as you accept the `a` completion, the contextual type changes and therefore the inference changes and it becomes an error, which is a terrible experience."
"It's sad to see that the work on this seems to have come to a halt.
Implementing would-be-convenient functionality now requires insane workarounds.

Bumping this again, in hope to see this released ♥️"
"This is where we call into the action constraints. 

The reasons that I went this way instead of using something new to solve the problem:
- This is the simplest thing to do for now
- I'm not sure how common this requirement is outside of MVC.

The thing that this solves is selecting between a GET endpoint and a POST endpoint, etc. It seems obvious someone layering a CMS on top of MVC needs this functionality. Maybe I am just being stupid and this needs to be *built-in*."
"> Shouldn't this be done in the other ctor?

Yes, absolutely right! I knew to do that earlier then for some reason started working on something else and forgot about it. Thanks for catching that.

> Also how do you feel about passing in an ILogger \ ILoggerFactory instead to the ctor? This feels a little gross. This feels a little gross.

I did this because we already take a `serviceProvider`, so why complicate things for the consumer? Under what circumstances would someone have reason to supply a different `ILogger` than the one the service provider would offer? I'm not absolutely set against it, but would like to make a choice based on practical reasoning.

In the long term, we may need to consume other services too. If we keep adding them as extra constructor overloads one-by-one, it will not be a nice experience for consumers."
I flipped this because _calling the destructor manually is terrible._
"holy shit this whole function is magic

"
Gross. OK.
"@github could this be something as stupid as not giving mlaunch enough time to finish?

Here's a good run:

```
[05:25:47] dbug: test[0]
      05:25:47.1394590 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmpmlrVXC.tmp --output-format=XML
[05:26:08] dbug: test[0]
      05:26:08.8570810 Simulator configuration written to /tmp/tmpmlrVXC.tmp
[05:26:08] dbug: test[0]
      05:26:08.9515020 Process exited with 0
[05:26:09] dbug: test[0]
      05:26:08.9536870 Simulator listing returned:
```

That took 22 seconds to return any results

Here's a bad one:

```
[02:06:49] dbug: test[0]
      02:06:49.7723290 /private/tmp/helix/working/A9DE099B/p/microsoft.dotnet.xharness.cli/1.0.0-prerelease.20352.3/tools/netcoreapp3.1/any/../../../runtimes/any/native/mlaunch/bin/mlaunch --sdkroot /Applications/Xcode115.app --listsim=/tmp/tmp3dqcCa.tmp --output-format=XML
[02:07:19] dbug: test[0]
      02:07:19.8645850 Process 4094 didn't exit within 00:00:30 and will be killed
```

Timeout is 30 seconds

How close to the wire is it getting?"
python3 wtf. Is there an easy way to run on the same hardware? Also do I need to manually patch bits and run before and after?
